<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[c++]继承与多态</title>
      <link href="/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="公有继承和is-a关系"><a href="#公有继承和is-a关系" class="headerlink" title="公有继承和is-a关系"></a>公有继承和is-a关系</h1><h2 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h2><p><code>派生</code>：同一个类可以派生出多个子类，将这个类称为<strong>基类</strong>，派生出的子类称为<strong>派生类</strong>，同时把子类简介派生出的所有类统称为它的<strong>子孙类</strong>，把一个子类之前的所有类都统称为它的<strong>祖先类</strong></p><p><code>继承</code>：每个派生出的子类继承了基类的<strong>公有(public)属性</strong>和<strong>公有函数</strong>描述的功能</p><p><code>is-a关系</code>（公有继承）：指一个类是另一个类的一种特殊形式，通常用于描述继承关系。比如，狗是一种动物，所以狗类可以继承自动物类。在代码中通常体现为类的继承关系。</p><p>再复习一下<strong>has-a</strong>关系</p><p><code>has-a</code>（私有继承）：指一个类包含另一个类的对象作为其成员变量，通常用于描述组合关系。比如，汽车有一个引擎，所以汽车类可以包含一个引擎对象作为其成员变量。在代码中通常体现为类的成员变量。</p><hr><h1 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h1><h2 id="派生类定义"><a href="#派生类定义" class="headerlink" title="派生类定义"></a>派生类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类公有函数成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//派生类私有数据成员</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="派生类访问控制"><a href="#派生类访问控制" class="headerlink" title="派生类访问控制"></a>派生类访问控制</h2><p><strong>可以访问</strong>：<strong>public</strong> ,<strong>protected</strong></p><p><strong>不可以访问</strong>：<strong>private</strong></p><h2 id="派生类定义样例"><a href="#派生类定义样例" class="headerlink" title="派生类定义样例"></a>派生类定义样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is sleeping&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed) : <span class="built_in">Animal</span>(name), <span class="built_in">m_breed</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_breed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造与析构"><a href="#派生类构造与析构" class="headerlink" title="派生类构造与析构"></a>派生类构造与析构</h2><blockquote><p><strong>注意</strong>：在调用派生类构造函数时如果不显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。如果基类没有默认构造函数，且派生类构造函数没有显式调用基类构造函数，则会导致编译错误。</p><blockquote><details class="toggle" ><summary class="toggle-button" style="">具体示例</summary><div class="toggle-content"><blockquote><p>在下面的示例中，基类Person没有默认构造函数，而派生类Student的构造函数没有显式调用基类构造函数，将会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> grade) : <span class="built_in">m_grade</span>(grade) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">myStudent</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，派生类Student的构造函数没有显式调用基类Person的构造函数，因为基类Person没有默认构造函数，编译器无法自动调用基类的构造函数，导致编译错误。为了避免这种情况，应该在派生类的构造函数中显式调用基类的构造函数，以确保正确地初始化基类的成员变量。</p><blockquote></blockquote></blockquote></div></details></blockquote></blockquote><p><strong>派生类构造函数示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPerson</span>(string name,<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)</span><br><span class="line">&#123;&#125;<span class="comment">//基类构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CStudent</span>(string name,<span class="type">int</span> age,<span class="type">int</span> number)</span><br><span class="line">:<span class="built_in">CPerson</span>(name,age),<span class="built_in">number</span>(number)</span><br><span class="line">&#123;&#125;<span class="comment">//派生类构造函数</span></span><br></pre></td></tr></table></figure><hr><h1 id="同名覆盖原则"><a href="#同名覆盖原则" class="headerlink" title="同名覆盖原则"></a>同名覆盖原则</h1><p><strong>定义：</strong>如果派生类新增的数据成员或函数成员与基类同名，则基类中的同名成员会被覆盖，如果要访问基类中的同名函数，则需要添加基类名<code>::</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studZhang.Person::<span class="built_in">show</span>();  <span class="comment">//studZhang是一个CStudent类的对象，Person是它的基类</span></span><br></pre></td></tr></table></figure><h1 id="赋值兼容原则"><a href="#赋值兼容原则" class="headerlink" title="赋值兼容原则"></a>赋值兼容原则</h1><p><strong>定义：</strong></p><p><strong>基类指针</strong>可以指向<strong>派生类对象</strong>（本质是派生类对象）</p><p><strong>基类引用对象</strong>可以引用<strong>派生类对象</strong>（本质是派生类对象）</p><p>普通变量，函数传参，函数返回对象时将子孙类对象赋值给基类对象时，会存在切片现象。（变成基类对象）</p><hr><h1 id="多态性与虚函数"><a href="#多态性与虚函数" class="headerlink" title="多态性与虚函数"></a>多态性与虚函数</h1><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p><code>静态多态性</code>：通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现（根据传参类型即可确定要调用的函数，<strong>在编译时完成（静态绑定）</strong>，所以是静态）</p><p><code>动态多态性</code>：通过<strong>虚函数</strong>实现（根据基类指针实际指向的对象类型来确定调用的函数，<strong>在运行时完成（动态绑定）</strong>） </p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ol><li>声明语法：</li></ol><p>在基类中声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在派生类中重写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>到底是干嘛的</li></ol><p>比如同样是叫，狗是bark，猫是meow，这个时候就有动态多态性的感觉了，就会使用虚函数。</p><ol start="3"><li>和普通函数的区别</li></ol><p>有一个基类指针<code>Person</code>指向派生类对象<code>Student</code>,基类和派生类中都有一个函数是<code>show()</code></p><p>如果<code>show()</code>是虚函数：</p><p><code>Person-&gt;show()</code>调用的是派生类<code>Student</code>的<code>show()</code></p><p>如果不是：</p><p>调用的就是基类<code>person</code>的<code>show()</code>函数</p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><ol><li>声明语法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Funtion</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><code>抽象类</code>：包含纯虚函数的类</p><h2 id="派生类对象的克隆"><a href="#派生类对象的克隆" class="headerlink" title="派生类对象的克隆"></a>派生类对象的克隆</h2><blockquote><p>用虚函数来克隆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* clonedBase = base-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* clonedDerived = derived-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedDerived-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">delete</span> clonedBase;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> clonedDerived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写点什么"><a href="#写点什么" class="headerlink" title="写点什么"></a>写点什么</h1><p>想了很久我的第一篇博客应该写点什么，但是突然发现这好像违背了我创建博客的初心，在我看来博客应该想写什么就写什么，我希望把我的博客当作一个树洞，既可以记录我的生活，又可以倾诉我的情绪，在这里可以看到最真实的自己。</p><p>至于为什么到现在才搭建好我的博客，想到这个问题脑子里突然闪过好多理由，但里有终究是理由，根本还是我自己的原因，因此我想做出改变，我一定可以看到自己的改变。</p><h1 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h1><h3 id="搭博客"><a href="#搭博客" class="headerlink" title="搭博客"></a>搭博客</h3><p>首先奉上我跟的教程</p><p>​<a href="https://nickxu.me/tags/%E5%BB%BA%E7%AB%99%E6%8A%80%E5%B7%A7/">标签: 建站技巧 | NX の 博客 (nickxu.me)</a></p><p>​<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>搭博客的过程可谓曲折，捣鼓了5、6天却一直报出奇怪的错误，不过也让我对流程十分熟悉，以后有机会一定要写一篇搭博客的教程。</p><h3 id="期中考试-0512"><a href="#期中考试-0512" class="headerlink" title="期中考试(0512)"></a>期中考试(0512)</h3><p>上个礼拜都在复习昨天的期中考试，这个学期想努力一下，要拿到奖学金（因为感觉上学期不是很认真都差点成功了），但是昨天的大物让我一言难尽，感觉一拳打在棉花上的感觉，无法读懂出题老师的意图，而且考的知识点像高中物理，甚至出现了万有引力。至于高数感觉还是上学期挖的坑太大了，输在了微积分基础上。但是现在还没出成绩，也许等出了成绩之后会更破防。</p><h3 id="Debug杯-0508"><a href="#Debug杯-0508" class="headerlink" title="Debug杯(0508)"></a>Debug杯(0508)</h3><p>第一次参加大学里的比赛，目标是为了混到德育分，但是没想到大部分的人和我的想法是一样的，以至于我最后甚至混到了一个三等奖，真是抽象。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>忘记还想要写些什么了，下次再来补吧。最后送自己一句话：Think Less,Do More.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/06/hello-world/"/>
      <url>/2024/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
