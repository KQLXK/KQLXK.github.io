<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[c++]运算符重载</title>
      <link href="/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="第一操作数"><a href="#第一操作数" class="headerlink" title="第一操作数"></a>第一操作数</h1><ul><li><strong>第一操作数</strong>：运算符左侧的操作数</li></ul><h1 id="成员运算符重载"><a href="#成员运算符重载" class="headerlink" title="成员运算符重载"></a>成员运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数是当前类对象时</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (const  第二操作数的引用){</p><p>​&#x2F;&#x2F;所进行的操作</p><p>​return …</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex <span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">        complex result;</span><br><span class="line">        result.real = real + c.real;</span><br><span class="line">        result.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> real;</span><br><span class="line">    <span class="type">int</span> imag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ul><h1 id="友元运算符重载"><a href="#友元运算符重载" class="headerlink" title="友元运算符重载"></a>友元运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数不是当前类对象，但是要访问到类中的私有成员时</p></li><li><p><strong>实现方式</strong>：</p><p>friend  返回值类型  operator  运算符  (第一操作数的引用，第二操作数的引用){</p><p>​&#x2F;&#x2F;操作</p><p>​return….</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">    os&lt;&lt;c.real&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么返回值要设为ostream&amp; ：允许连续输出，例如cout&lt;&lt;c1&lt;&lt;c2&lt;&lt;c3&lt;&lt;endl</p></blockquote></li></ul><h1 id="非成员函数重载"><a href="#非成员函数重载" class="headerlink" title="非成员函数重载"></a>非成员函数重载</h1><ul><li><p><strong>适用场景</strong>：既不需要访问类的私有成员，也不需要直接修改类的对象</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (常引用)  {</p><p>​…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-num.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]继承与多态</title>
      <link href="/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="公有继承和is-a关系"><a href="#公有继承和is-a关系" class="headerlink" title="公有继承和is-a关系"></a>公有继承和is-a关系</h1><h2 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h2><p><code>派生</code>：同一个类可以派生出多个子类，将这个类称为<strong>基类</strong>，派生出的子类称为<strong>派生类</strong>，同时把子类简介派生出的所有类统称为它的<strong>子孙类</strong>，把一个子类之前的所有类都统称为它的<strong>祖先类</strong></p><p><code>继承</code>：每个派生出的子类继承了基类的<strong>公有(public)属性</strong>和<strong>公有函数</strong>描述的功能</p><p><code>is-a关系</code>（公有继承）：指一个类是另一个类的一种特殊形式，通常用于描述继承关系。比如，狗是一种动物，所以狗类可以继承自动物类。在代码中通常体现为类的继承关系。</p><p>再复习一下<strong>has-a</strong>关系</p><p><code>has-a</code>（私有继承）：指一个类包含另一个类的对象作为其成员变量，通常用于描述组合关系。比如，汽车有一个引擎，所以汽车类可以包含一个引擎对象作为其成员变量。在代码中通常体现为类的成员变量。</p><hr><h1 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h1><h2 id="派生类定义"><a href="#派生类定义" class="headerlink" title="派生类定义"></a>派生类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类公有函数成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//派生类私有数据成员</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="派生类访问控制"><a href="#派生类访问控制" class="headerlink" title="派生类访问控制"></a>派生类访问控制</h2><p><strong>可以访问</strong>：<strong>public</strong> ,<strong>protected</strong></p><p><strong>不可以访问</strong>：<strong>private</strong></p><p><strong>如何访问</strong>：</p><p>有基类<code>person</code> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有派生类<code>student</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问<code>student</code>的<code>name</code>和<code>age</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; student.name;</span><br><span class="line">cout &lt;&lt; student.age;</span><br></pre></td></tr></table></figure><h2 id="派生类定义样例"><a href="#派生类定义样例" class="headerlink" title="派生类定义样例"></a>派生类定义样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is sleeping&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed) : <span class="built_in">Animal</span>(name), <span class="built_in">m_breed</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_breed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造与析构"><a href="#派生类构造与析构" class="headerlink" title="派生类构造与析构"></a>派生类构造与析构</h2><blockquote><p><strong>注意</strong>：在调用派生类构造函数时如果不显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。如果基类没有默认构造函数，且派生类构造函数没有显式调用基类构造函数，则会导致编译错误。</p><blockquote><details class="toggle" ><summary class="toggle-button" style="">具体示例</summary><div class="toggle-content"><blockquote><p>在下面的示例中，基类Person没有默认构造函数，而派生类Student的构造函数没有显式调用基类构造函数，将会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> grade) : <span class="built_in">m_grade</span>(grade) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">myStudent</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，派生类Student的构造函数没有显式调用基类Person的构造函数，因为基类Person没有默认构造函数，编译器无法自动调用基类的构造函数，导致编译错误。为了避免这种情况，应该在派生类的构造函数中显式调用基类的构造函数，以确保正确地初始化基类的成员变量。</p><blockquote></blockquote></blockquote></div></details></blockquote></blockquote><p><strong>派生类构造函数示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPerson</span>(string name,<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)</span><br><span class="line">&#123;&#125;<span class="comment">//基类构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CStudent</span>(string name,<span class="type">int</span> age,<span class="type">int</span> number)</span><br><span class="line">:<span class="built_in">CPerson</span>(name,age),<span class="built_in">number</span>(number)</span><br><span class="line">&#123;&#125;<span class="comment">//派生类构造函数</span></span><br></pre></td></tr></table></figure><hr><h1 id="同名覆盖原则"><a href="#同名覆盖原则" class="headerlink" title="同名覆盖原则"></a>同名覆盖原则</h1><p><strong>定义：</strong>如果派生类新增的数据成员或函数成员与基类同名，则基类中的同名成员会被覆盖，如果要访问基类中的同名函数，则需要添加基类名<code>::</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studZhang.Person::<span class="built_in">show</span>();  <span class="comment">//studZhang是一个CStudent类的对象，Person是它的基类</span></span><br></pre></td></tr></table></figure><h1 id="赋值兼容原则"><a href="#赋值兼容原则" class="headerlink" title="赋值兼容原则"></a>赋值兼容原则</h1><p><strong>定义：</strong></p><ol><li><p><strong>基类指针</strong>可以指向<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p><strong>基类引用对象</strong>可以引用<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p>普通变量，函数传参，函数返回对象时将子孙类对象赋值给基类对象时，会存在切片现象。（变成基类对象）</p></li></ol><hr><h1 id="多态性与虚函数"><a href="#多态性与虚函数" class="headerlink" title="多态性与虚函数"></a>多态性与虚函数</h1><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p><code>静态多态性</code>：通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现（根据传参类型即可确定要调用的函数，<strong>在编译时完成（静态绑定）</strong>，所以是静态）</p><p><code>动态多态性</code>：通过<strong>虚函数</strong>实现（根据基类指针实际指向的对象类型来确定调用的函数，<strong>在运行时完成（动态绑定）</strong>） ，<strong>在基类指针&#x2F;对象指向派生类指针&#x2F;对象时最能体现</strong>。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ol><li><p>声明语法：</p><p>在基类中声明：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​在派生类中重写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>到底是干嘛的</p><p>比如同样是动物的叫，狗是bark，猫是meow，这个时候就有动态多态性的感觉了，就会使用虚函数。</p><p>动物是基类，狗和猫是派生类，叫就是一个虚函数。</p></li><li><p>使用时和普通函数的区别</p><p>前文提到了在基类指针&#x2F;对象指向派生类指针&#x2F;对象时最能体现动态多样性，这是因为在通过基类指针&#x2F;对象访问派生类指针&#x2F;对象的函数时，如果这个函数是虚函数，那么编译器就会在这个类的虚函数表中找到对应的虚函数来调用（这就是动态多样性），而如果是普通函数，那就会直接调用基类的这个函数。</p><p>例如：有一个基类指针<code>Person</code>指向派生类对象<code>Student</code>,基类和派生类中都有一个函数是<code>show()</code></p><ul><li>如果<code>show()</code>是虚函数：</li></ul><p><code>Person-&gt;show()</code>调用的是派生类<code>Student</code>的<code>show()</code></p><ul><li>如果不是：</li></ul><p><code>Person-&gt;show()</code>调用的就是基类<code>person</code>的<code>show()</code>函数</p><ul><li>如果基类没有这个函数：</li></ul><p>编译器会直接报错</p></li><li><p>底层逻辑</p></li></ol><p>对于使用虚函数的类，编译器会在其内部生成一个虚函数表，用来存储该类所有的虚函数，用基类指针或引用调用虚函数时，会从这个表中找到对应的虚函数并返回指针，从而实现动态绑定。</p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><ol><li>声明语法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Funtion</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><code>抽象类</code>：包含纯虚函数的类</p><h2 id="派生类对象的克隆"><a href="#派生类对象的克隆" class="headerlink" title="派生类对象的克隆"></a>派生类对象的克隆</h2><blockquote><p>用虚函数来克隆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* clonedBase = base-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* clonedDerived = derived-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedDerived-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">delete</span> clonedBase;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> clonedDerived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚基类？？？？？？？？？？？？？？？？？"><a href="#虚基类？？？？？？？？？？？？？？？？？" class="headerlink" title="虚基类？？？？？？？？？？？？？？？？？"></a>虚基类？？？？？？？？？？？？？？？？？</h1><h2 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h2><p><strong>在类的继承关系如下时发生</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure><p>在上面的继承结构中，类 <code>A</code> 是基类，类 <code>B</code> 和 <code>C</code> 都直接继承自 <code>A</code>，而类 <code>D</code> 继承自 <code>B</code> 和 <code>C</code>。由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在 <code>D</code> 中将会包含两份来自 <code>A</code> 的数据。这就是有菱形继承问题的原因。</p><p><strong>导致以下问题</strong>：</p><ol><li><p>内存浪费</p></li><li><p>二义性：</p><p>如果 <code>A</code> 类定义了一个成员函数 <code>foo()</code>，<code>B</code> 类和 <code>C</code> 类分别重写了这个函数，在 <code>D</code> 类中调用 <code>foo()</code> 函数，编译器就无法确定应该调用哪个版本的 <code>foo()</code> 函数，从而产生二义性。</p></li></ol><h2 id="用虚基类解决菱形继承问题"><a href="#用虚基类解决菱形继承问题" class="headerlink" title="用虚基类解决菱形继承问题"></a>用虚基类解决菱形继承问题</h2><ul><li><p><strong>如何解决</strong>：</p><p>声明虚基类后，编译器会自动调用最终重写的版本。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling A&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling B&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling C&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        B::<span class="built_in">foo</span>(); <span class="comment">// 明确调用 B 类的 foo()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();  <span class="comment">// 在 D 类中调用 foo() 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">callFoo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling B<span class="number">&#x27;</span><span class="function">s <span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>如果没有声明虚基类，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference to &#x27;foo&#x27; is ambiguous</span><br></pre></td></tr></table></figure><p>如果没有最终的重写函数，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no unique final overrider <span class="keyword">for</span> &#x27;virtual void A::foo()&#x27; <span class="keyword">in</span> &#x27;D&#x27;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li><p><strong>将构造函数定义为纯虚函数是没有意义的</strong></p><p>构造函数是用来创造对象的，而含有纯虚函数的类不能创造对象，所以无意义</p></li><li><p><strong>动态绑定只发生在，用基类指针或基类引用调用虚函数时，用派生类指针或引用调用虚函数时会直接确定要调用的虚函数，这是静态绑定</strong></p><p>例：有一个派生类对象a，a类中有虚函数b()，使用a.b()时不会发生动态绑定。</p></li><li><p><strong>派生类中虚函数必须和基类中完全一样（返回值，形参）</strong></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写点什么"><a href="#写点什么" class="headerlink" title="写点什么"></a>写点什么</h1><p>想了很久我的第一篇博客应该写点什么，但是突然发现这好像违背了我创建博客的初心，在我看来博客应该想写什么就写什么，我希望把我的博客当作一个树洞，既可以记录我的生活，又可以倾诉我的情绪，在这里可以看到最真实的自己。</p><p>至于为什么到现在才搭建好我的博客，想到这个问题脑子里突然闪过好多理由，但里有终究是理由，根本还是我自己的原因，因此我想做出改变，我一定可以看到自己的改变。</p><h1 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h1><h3 id="搭博客"><a href="#搭博客" class="headerlink" title="搭博客"></a>搭博客</h3><p>首先奉上我跟的教程</p><p>​<a href="https://nickxu.me/tags/%E5%BB%BA%E7%AB%99%E6%8A%80%E5%B7%A7/">标签: 建站技巧 | NX の 博客 (nickxu.me)</a></p><p>​<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>搭博客的过程可谓曲折，捣鼓了5、6天却一直报出奇怪的错误，不过也让我对流程十分熟悉，以后有机会一定要写一篇搭博客的教程。</p><h3 id="期中考试-0512"><a href="#期中考试-0512" class="headerlink" title="期中考试(0512)"></a>期中考试(0512)</h3><p>上个礼拜都在复习昨天的期中考试，这个学期想努力一下，要拿到奖学金（因为感觉上学期不是很认真都差点成功了），但是昨天的大物让我一言难尽，感觉一拳打在棉花上的感觉，无法读懂出题老师的意图，而且考的知识点像高中物理，甚至出现了万有引力。至于高数感觉还是上学期挖的坑太大了，输在了微积分基础上。但是现在还没出成绩，也许等出了成绩之后会更破防。</p><h3 id="Debug杯-0508"><a href="#Debug杯-0508" class="headerlink" title="Debug杯(0508)"></a>Debug杯(0508)</h3><p>第一次参加大学里的比赛，目标是为了混到德育分，但是没想到大部分的人和我的想法是一样的，以至于我最后甚至混到了一个三等奖，真是抽象。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>忘记还想要写些什么了，下次再来补吧。最后送自己一句话：Think Less,Do More.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/06/hello-world/"/>
      <url>/2024/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
