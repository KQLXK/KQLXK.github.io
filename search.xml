<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[前端]HTML入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-HTML%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-HTML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="html基本概念">HTML基本概念</h1><p>HTML 是用来描述网页的一种语言。</p><p>一个完整的html文件必须包括文档声明，html，head，body标签</p><p>最简单的HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        welcome!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html标签">HTML标签</h2><p>HTML基本元素由 <code>&lt;&gt;</code> 包裹，比如</p><ul><li><code>&lt;html&gt;</code>: 表示一个HTML文档的开始和结束。</li><li><code>&lt;head&gt;</code>: 包含文档的元信息，如标题和链接。</li><li><code>&lt;title&gt;</code>: 定义文档的标题。</li><li><code>&lt;body&gt;</code>: 包含网页的可见内容，如文本、图像、链接等。</li></ul><h2 id="html元素">HTML元素</h2><p>一个开始标签和结束标签包含了内容组成了一个元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="html属性">HTML属性</h2><p>HTML的每个标签都有自己的属性</p><p>常见的属性有：</p><ol><li><p><strong><code>id</code></strong>:</p><p>用于唯一标识一个元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;main-title&quot;</span>&gt;</span>欢迎来到我的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>class</code></strong>:用于指定一个或多个类名，可用于CSS样式和JavaScript操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>这是一个突出显示的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>style</code></strong>:</p><p>用于直接为HTML元素设定内联样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>这是一个红色的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>title</code></strong>:</p><p>提供关于元素的额外信息，当鼠标悬停在元素上时显示该信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一张图片&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>href</code></strong>:</p><p>用于定义超链接的目标网址，常用于<code>&lt;a&gt;</code>（链接）标签中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>src</code></strong>:</p><p>用于指定图像、脚本或框架的源路径，常用于<code>&lt;img&gt;</code>和<code>&lt;script&gt;</code>标签中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;网站logo&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>name</code></strong>:</p><p>在 <code>&lt;input&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;select&gt;</code> 等表单元素中使用，定义元素的名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>type</code></strong>:</p><p>指定表单元素的类型（如 <code>text</code>, <code>password</code>, <code>submit</code>）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="html常用标签">HTML常用标签</h1><h2 id="标题">标题</h2><p><code>h1-h6</code>表示六级标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水平线">水平线</h2><p><code>&lt;hr&gt;</code>表示创建水平线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释">注释</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ....  --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="段落">段落</h2><p><code>&lt;p&gt;</code> 表示段落</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="换行">换行</h2><p><code>&lt;br&gt;</code>  标签表示换行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个<span class="tag">&lt;<span class="name">br</span>&gt;</span>段落<span class="tag">&lt;<span class="name">br</span>&gt;</span>演示了分行的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文本处理">文本处理</h2><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-b.html"><b></a></td><td style="text-align:left">定义粗体文本</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-em.html"><em></a></td><td style="text-align:left">定义着重文字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-i.html"><i></a></td><td style="text-align:left">定义斜体字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-small.html"><small></a></td><td style="text-align:left">定义小号字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-strong.html"><strong></a></td><td style="text-align:left">定义加重语气</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-sub.html"><sub></a></td><td style="text-align:left">定义下标字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/html/m/tags/tag-sup.html"><sup></a></td><td style="text-align:left">定义上标字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-ins.html"><ins></a></td><td style="text-align:left">定义插入字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-del.html"><del></a></td><td style="text-align:left">定义删除字</td></tr></tbody></table><h2 id="头部-head">头部(head)</h2><p><code>&lt;head&gt;</code> 标签里可以包含多个标签，表示不同的含义</p><ol><li><p><code>&lt;meta&gt;</code> 标签</p><p>提供文档的信息比如字符集，作者，关键词等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;base&gt;</code> 标签</p><p>文档里的相对链接的基本URL，接下来文档对此URL的调用可以省略不写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;title&gt;</code> 标签</p><p>网页标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;link&gt;</code> 标签</p><p>链接外部资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span> <span class="comment">&lt;!-- 链接CSS样式表 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span> <span class="comment">&lt;!-- 页面图标 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;style&gt;</code> 标签</p><p>用于包含内联CSS样式。通常不推荐在构建大型项目时使用，但适合小型项目或快速测试。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;  </span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: lightblue;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="图像">图像</h2><p><code>&lt;img&gt;</code> 标签创建图像，<code>src</code> 属性表示图片源地址，<code>alt</code> 属性表示替换图片的文字，在浏览器无法加载出图片时用这些信息代替，<code>width</code>，<code>height</code>用来设置图片大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;boad.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Big Goat&quot;</span> <span class="attr">width</span>=<span class="string">&quot;334&quot;</span> <span class="attr">height</span>=<span class="string">&quot;228&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="链接">链接</h2><p><code>&lt;a&gt;</code> 用于创建链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://kqlxk.github.io&quot;</span>&gt;</span>YC&#x27;s Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这行代码的效果就是 <a href="https://kqlxk.github.io">YC’s Blog</a></p><h2 id="区块">区块</h2><ol><li><p><code>&lt;div&gt;</code> 可以布局和容纳其他元素，适合做大的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;span&gt;</code> 适合对行内其他元素进行样式化，标记和包裹</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的词。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202410051901429.png" alt=""></p></li></ol><h2 id="表单">表单</h2><p><code>&lt;form&gt;</code> 是获取用户输入的地方，<code>action</code> 属性定义了数据提交的目标URL，<code>method</code> 属性定义了提交数据的HTTP方法（GET，POST…）</p><p><code>&lt;label&gt;</code> 可以告诉用户要输入的是什么</p><p><code>&lt;input&gt;</code> 创建文本输入框，密码框，单选按钮，复选框，文件，<code>id</code> 属性用于在HTML文件中标记这个元素，<code>name</code> 和输入值组成键值对，传送到后端</p><p><code>&lt;select&gt;</code> 创建下拉表，<code>&lt;option&gt;</code> 创建选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;country&quot;</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cn&quot;</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;uk&quot;</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--提交文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202410061325612.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前端]JS入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-JS%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-JS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前端]css入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-css%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-css%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[Go]模板与渲染</title>
      <link href="/2024/09/24/Go-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
      <url>/2024/09/24/Go-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><ol><li>导包：<code>text/template</code>，<code>html/template</code>，前面文本模板，后面html模板</li><li>作用：一个html文件中需要使用到会改变的各种后端传送的数据和不会改变的html基本架构，在html文件中用模板语言标记出这些数据要在的地方，渲染就是将数据填入，可以理解为一种文本替换操作</li><li>通常定义为 .tmpl 和 .tpl，必须使用UTF-8编码</li><li>传给模板的数据用包裹起来</li></ol><h2 id="相关方法">相关方法</h2><p><strong>解析</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span></span> Parse(src <span class="type">string</span>) (*Template, <span class="type">error</span>)      <span class="comment">//对已存在的Template对象使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="type">string</span>)</span></span> (*Template, <span class="type">error</span>)      <span class="comment">//解析具体文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseGlob</span><span class="params">(pattern <span class="type">string</span>)</span></span> (*Template, <span class="type">error</span>)            <span class="comment">//解析大量文件</span></span><br></pre></td></tr></table></figure><p><strong>渲染</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t, *Template)</span></span> Execute(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t, *Template)</span></span> ExecuteTemplate(wr io.Writer, name <span class="type">string</span>, data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p>模板文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;.&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//解析模板</span></span><br><span class="line">t, err := template.ParseFiles(<span class="string">&quot;./template_demo/hello.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;template files failed, err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">err = t.Execute(w, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;exceute data failed, err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;HTTP server start failed&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409261028588.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计网]互联网协议入门</title>
      <link href="/2024/09/19/%E8%AE%A1%E7%BD%91-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/19/%E8%AE%A1%E7%BD%91-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>看 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议入门（一） - 阮一峰的网络日志 (ruanyifeng.com)</a> 做的笔记</p><h1 id="概述">概述</h1><p>互联网(internet) 一共分为五层，每层有对应的协议，如表</p><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">/</th><th style="text-align:center">/</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">应用层(Application Layer)</td><td style="text-align:center">HTTP，DHCP…</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层(Transport Layer)</td><td style="text-align:center">UDP，TCP…</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层(Network Layer)</td><td style="text-align:center">ARP，IP…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">链接层(Link Layer)</td><td style="text-align:center">以太网协议(IEEE,IEEE 802.3)…</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">实体层(Physical Layer)</td><td style="text-align:center">网线，光纤的接口类型等</td></tr></tbody></table><p>每一层都是为了完成一个功能，而协议就是为了让所有人都按照一样的格式完成这个功能，从而实现世界的互联</p><h1 id="五层模型">五层模型</h1><h2 id="实体层">实体层</h2><p>把电脑连接起来的一些物理手段比如光纤，电缆，<strong>负责传递0，1的电信号</strong></p><h2 id="链接层">链接层</h2><h3 id="作用">作用</h3><p>将0，1的电信号用某种分组方式格式化成含有信息的数据</p><p>这就会导致不同公司生产的设备使用不同的分组方式，而以太网协议(IEEE,IEEE 802.3)就是对这种格式化方式的统一规定</p><h3 id="以太网协议-ieee-ieee-802-3">以太网协议(IEEE,IEEE 802.3）</h3><p>此协议规定，一组电信号组成一个数据包，叫做“帧”（Frame），由标头（head），数据（data）组成</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409191936549.png" alt=""></p><ul><li><p>以太网数据包：</p><p>标头：源mac和目标mac，固定是18字节</p><p>数据：帧校验序列等具体内容，46-1500字节</p></li></ul><h3 id="mac地址">MAC地址</h3><p><strong>是什么：就是网卡的地址</strong></p><p>以太网规定，连入网络的所有设备，都必须具有网卡接口，数据包必须从一块网卡传送到另一块网卡，网卡的地址就是数据包发送和接受的地址，称为MAC地址</p><p><strong>组成</strong></p><p>每块网卡都有独一无二的MAC地址，由48个二进制位组成，通常用12个十六进制数表示。</p><p>前六个是厂商编号，后六位是网卡流水号</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png" alt="img"></p><h3 id="广播-数据发送方式">广播(数据发送方式)</h3><p><strong>作用</strong>：以太网的一种数据发送方式</p><p>以太网采用一种很原始的方法发送数据包给接受方，本机会向子网络内每一台计算机都发送一份数据包，由计算机自身判断是否为接收方（通过标头内的标识信息判断）。</p><p>至于怎么样获得这些mac地址，后文会提到</p><h2 id="网络层">网络层</h2><h3 id="作用">作用</h3><p>引进一套新的地址，使我们可以区分不同的计算机是否属于同一个子网络，这套地址叫做”网络地址“，也就是网址。</p><blockquote><p>注意：我们所熟知的形如 <code>www.xxxx.com</code> 并不是网址，我们访问这个域名时会向万维网(www)服务器发送一个请求，而服务器会给我们返回这个域名对应的IP地址，我们才可以继续访问这个网站</p></blockquote><p>如果属于一个子网络，就采用广播方式发送，否则就采用路由方式发送</p><h3 id="ip协议">IP协议</h3><p><strong>作用</strong>：规定IP地址的协议，普遍采用IPv4，也就是第四版IP协议</p><p>IP地址由32个二进制组成</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409211921356.png" alt=""></p><p>IP地址由 <strong>网络</strong> 和 <strong>主机</strong> 两部分组成，但是网络和主机各占几个字符是不确定的</p><p>例如，有可能前24位是网络的地址 也就是 172.16.254，那么最后一个1就是主机地址</p><p>也有可能是前28位是网络地址…</p><p>然而，一个IP地址可以使用的地址要去除两种情况，将主机地址全设为0的和全设为1的，在上面的例子中就是</p><p><code>172.16.254.0</code>和<code>172.16.254.255</code>后者是广播地址，用于发送广播消息</p><p><strong>那么如何计算机做区分呢，需要使用另一个参数“子网掩码”</strong></p><h3 id="子网掩码">子网掩码</h3><p>和IP地址长度一样，当前24位表示网络地址时，子网掩码就是 <code>11111111.11111111.11111111.0000000</code>，换算成十进制就是 <code>255.255.255.0</code></p><p>使用子网掩码时，将子网掩码和IP地址二进制AND运算，从而得到网络地址，如果相同就在同一子网络</p><h3 id="ip数据包">IP数据包</h3><p>同样包括标头和数据部分</p><p>标头：版本，长度，IP地址，20-60字节</p><p>数据：最长65515字节，因此要分成多个以太网数据包发送</p><p>IP数据包会放在以太网数据包的数据部分中</p><h3 id="arp协议">ARP协议</h3><p><strong>作用</strong>：从IP地址获取MAC地址(在同一个子网络情况下)</p><p>ARP协议会向子网络中所有计算机发送一个数据包，包括自己的IP地址和查询主机的IP地址，在对方MAC地址上填<code>FF:FF:FF:FF:FF:FF</code>，每台计算机对IP地址进行比较，如果相同就回复自己的MAC地址</p><h2 id="传输层">传输层</h2><h3 id="作用">作用</h3><p>建立端口到端口之间的通信，从而实现程序之间的交流</p><h3 id="端口-port">端口(port)</h3><p><strong>作用</strong>：用来辨别数据包具体是给某个程序使用的</p><p>端口是一个0-65535之间的整数，正好16位二进制，它其实就是每一个网卡使用程序的编号，其中0-1023由系统占用</p><blockquote><p>Unix系统把主机+端口称为”套接字“，也就是socket，我们熟悉的socket编程就是在这一层进行</p></blockquote><h3 id="udp协议">UDP协议</h3><p><strong>作用</strong>： 在数据包中加入端口号</p><p>标头：发出端口和接收端口</p><p>数据：就是数据</p><p>总长不超过65535字节，刚好放入一个IP数据包</p><h3 id="tcp协议">TCP协议</h3><p><strong>作用</strong>：有确认机制的UDP协议，如果有一个数据包遗失了，发出方就收不到确认要求，就会重发数据包</p><p>其他和UDP差不多</p><h2 id="应用层">应用层</h2><h3 id="作用">作用</h3><p>规定应用程序的数据格式</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p><h3 id="dhcp协议">DHCP协议</h3><p><strong>作用</strong>：用于内部网或网络服务供应商自动分配IP地址给用户，用于内部网管理员对所有电脑作中央管理</p><h3 id="dns协议">DNS协议</h3><p><strong>作用</strong>：域名（如 <a href="http://www.example.com">www.example.com</a>）转换为计算机能够理解的IP地址（如 192.0.2.1）</p><h2 id="小结">小结</h2><p>通过以上的学习，我们知道数据在计算机之间传输的大概流程：</p><p>在应用中产生要传输的数据，传输层加入端口号，网络层加入IP地址，链接层加入MAC地址，物理层传送这些数据</p><p>如果我们要访问一个网页，</p><ol><li>首先设置好自己的网络参数，IP地址，子网掩码，网关的IP地址，DNS的IP地址，当然这些参数都应该有网络管理员来分配，而不是我们自己随便写。</li><li>输入域名(<a href="http://www.xxxxxx.com">www.xxxxxx.com</a>)，通过DNS协议把这个域名转换为IP地址</li><li>判断这个IP地址是否在同一子网络，如果在，就直接获得MAC地址，如果不在，通过网关转发，那么网关的MAC地址就是我们要传送的MAC地址</li><li>到这里，我们的主机会向目标主机发送一个访问请求，由于浏览网页使用的是HTTP协议，所以我们要生成一个HTTP数据包，再通过TCP，IP，以太网等协议的包装形成最后的以太网数据包，通过多个网关发送的目标主机，而目标主机则会返回一个HHTTP响应，用TCP协议发回来，这就完成了一次网络通信</li></ol><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409201853411.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]gin框架基本使用</title>
      <link href="/2024/09/16/Go-gin%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/16/Go-gin%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>官方文档：<a href="https://gin-gonic.com/zh-cn/docs/">文档 | Gin Web Framework (gin-gonic.com)</a></p><h1 id="基本的gin示例">基本的gin示例</h1><p><strong>安装</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p><strong>demo</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span>        <span class="comment">//导入gin包</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;  </span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello golang!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()            <span class="comment">//创建一个默认的路由引擎</span></span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, sayHello)     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><pre><code class="language-go">func sayHello(c *gin.Context) &#123;c.JSON(200, gin.H&#123;  &quot;message&quot;: &quot;hello golang!&quot;,&#125;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  1. `sayHello`函数是一个处理HTTP请求的函数，形参`c`是`*gin.Context`类型，其中**封装了客户端发来的请求数据**表示当前请求的上下文，可以从中获得当前请求的信息，响应信息，执行中间件</span><br><span class="line">  2. `c.JSON`将HTTP状态码200和一个JSON响应发送回客户。`gin.H`是gin提供的一个便利类型，**其数据类型是 `map[string]interface&#123;&#125;`** ，它的键必须是字符串，它的值可以存储任意类型的数据</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  r := gin.Default()</span><br></pre></td></tr></table></figure>初始化了一个默认的gin引擎，`gin.Default()` 会创建一个带有默认中间件的路由器，包括日记记录和恢复中间件，这意味着他会在每个请求中记录日志，并处理`panic`</code></pre></li><li><pre><code class="language-go">r.GET(&quot;/hello&quot;, sayHello)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  向`r`路由器注册一个 `GET` 请求的路由，当用户访问时调用`sayHello()`函数处理</span><br><span class="line"></span><br><span class="line">- ````go</span><br><span class="line">  r.Run()</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">  启动了gin 的HTTP服务器，监听本地的8080端口（默认）</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># Gin渲染</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTML渲染</span><br><span class="line"></span><br><span class="line">**方法**：</span><br><span class="line"></span><br><span class="line">`LoadHTMLGlob()` 加载一坨文件</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func (engine *Engine) LoadHTMLGlob(pattern string)</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>LoadHTMLFiles()</code> 加载指定名的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> LoadHTMLFiles(files ...<span class="type">string</span>)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析模板</span></span><br><span class="line">r.LoadHTMLFiles(<span class="string">&quot;./gin_demo1/hello.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">        c.HTML(<span class="number">200</span>, <span class="string">&quot;hello.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span>:   <span class="string">&quot;yc&quot;</span>,</span><br><span class="line"><span class="string">&quot;Gender&quot;</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>:    <span class="number">19</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义模板函数">自定义模板函数</h2><p>方法：</p><p><code>SetFuncMap()</code>：用于定义模板文件中的自定义函数，需要在解析模板前用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> SetFuncMap()(funcMap template.FuncMap)</span><br></pre></td></tr></table></figure><p>例子：</p><p>index.tmpl</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; .| safe&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.SetFuncMap(template.FuncMap&#123;</span><br><span class="line"><span class="string">&quot;safe&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> template.HTML&#123;</span><br><span class="line"><span class="keyword">return</span> template.HTML(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">router.LoadHTMLFiles(<span class="string">&quot;./index.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;index.tmpl&quot;</span>, <span class="string">&quot;&lt;a href=&#x27;https://liwenzhou.com&#x27;&gt;李文周的博客       &lt;/a&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对需要返回html的场景可能发生有风险的内容，比如用户评论了html语言，如果不进行转移就会污染返回的html文件，而如果完全信任输入，就可以用如上的方法阻止转义</p><h2 id="静态文件处理">静态文件处理</h2><p><code>gin.Static()</code>：如果HTML文件中引用了静态文件，调用此方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Static(relativePath, root <span class="type">string</span>) IRoutes</span><br></pre></td></tr></table></figure><h2 id="json渲染">JSON渲染</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> JSON(code <span class="type">int</span>, obj any)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">Age     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.JSON(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xml渲染">xml渲染</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> c.XML(code <span class="type">int</span>, obj any)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">&quot;/someXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.XML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/moreXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">Age     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg MessageRecord</span><br><span class="line">msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.XML(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ymal渲染">YMAL渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someYAML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.YAML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br></pre></td></tr></table></figure><h1 id="获取参数">获取参数</h1><h2 id="获取querytring参数">获取querytring参数</h2><p><code>querystring()</code>：参数指的是URL <code>？</code>后的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> DefaultQuery(key, defaultValue <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/query&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取form参数">获取form参数</h2><p><code>PostForm</code>：接受前端发来的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(<span class="number">200</span>, <span class="string">&quot;login.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取path参数">获取path参数</h2><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数绑定">参数绑定</h2><p><code>ShoudBind()</code>：自动提取请求中的<code>querystring</code>，<code>form</code>，<code>json</code>，<code>xml</code>类型的数据，并绑定到结构体中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShoudBind(obj any) <span class="type">error</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/bind&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u1 User</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;u1); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>: u1.Username,</span><br><span class="line"><span class="string">&quot;pass&quot;</span>: u1.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;err&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只用了表单举例子</p><h1 id="文件上传">文件上传</h1><p><code>c.FormFile</code> ：从HTTP请求中获取通过表单上传的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> FormFile(key <span class="type">string</span>) (multipart.File, *multipart.FileHeader, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>uploadfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/file&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;./gin_demo2/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;file.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, err := c.FormFile(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;get file failed, panic&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">&quot;D:/develop/file/%s&quot;</span>, file.Filename)</span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">c.JSON(http.StatusOK, <span class="string">&quot;submit sucess&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[git]基本使用</title>
      <link href="/2024/09/13/git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/13/git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本的linux命令">基本的linux命令</h1><p><code>cd</code> ：改变目录（直接cd，进入默认目录）</p><p><code>cd ..</code> ：回退到上一级目录</p><p><code>pwd</code> ：显示当前所在目录路径</p><p><code>ls / ll</code>：列出所有文件（ll更加详细）</p><p><code>rm + 文件名</code> ：删除文件</p><p><code>rm -r + 文件夹名</code> ：删除文件夹</p><p><code>mkdir</code> ：新建一个文件夹</p><p><code>reset</code> ：初始化终端</p><p><code>history</code> ：查看历史命令</p><p><code>clear</code> ：清屏</p><p><code>help</code> ：帮助</p><p><code>exit</code> ：退出</p><h1 id="配置">配置</h1><p>使用 <code>git config</code> 命令</p><p>显示当前配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p>编辑配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --e               <span class="comment">#针对当前仓库</span></span><br><span class="line">$ git config --e --global      <span class="comment">#针对系统上所有仓库 </span></span><br></pre></td></tr></table></figure><p>设置用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;...&quot;</span></span><br><span class="line">$ git config --global user.email ...</span><br></pre></td></tr></table></figure><h1 id="创建仓库">创建仓库</h1><p>有两种方法</p><ul><li><p><strong>git init</strong></p><p>进入一个目录，并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init            <span class="comment">#将当前目录作为git仓库</span></span><br><span class="line">$ git init 目录名      <span class="comment">#将指定目录作为git仓库</span></span><br></pre></td></tr></table></figure><p>执行该命令后，对应目录会生成一个 .git 的文件夹（隐藏文件夹）</p></li><li><p><strong>git clone</strong></p><p>从现有的git仓库中拷贝项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt;  <span class="comment">#克隆到当前目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;  <span class="comment">#克隆到指定目录</span></span><br></pre></td></tr></table></figure><p>例子：</p><p>随便克隆一个github上的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/KQLXK/Linkup.git</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本操作">基本操作</h1><h2 id="常见操作">常见操作</h2><ul><li><p>git add:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件名       <span class="comment">#提交到暂存区</span></span><br></pre></td></tr></table></figure></li><li><p>git commit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;...&quot;</span>  <span class="comment">#将暂存区内容添加到仓库</span></span><br></pre></td></tr></table></figure></li><li><p>git status：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status           <span class="comment">#确认哪些文件被修改暂存或未被跟踪</span></span><br></pre></td></tr></table></figure></li><li><p>git log:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>             <span class="comment">#查看提交日志</span></span><br></pre></td></tr></table></figure></li><li><p>git branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch          <span class="comment"># 查看当前分支</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="提交与修改">提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git add</code></td><td style="text-align:left">添加文件到暂存区</td></tr><tr><td style="text-align:left"><code>git status</code></td><td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td style="text-align:left"><code>git diff</code></td><td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td style="text-align:left"><code>git difftool</code></td><td style="text-align:left">使用外部差异工具查看和比较文件的更改。</td></tr><tr><td style="text-align:left"><code>git range-diff</code></td><td style="text-align:left">比较两个提交范围之间的差异。</td></tr><tr><td style="text-align:left"><code>git commit</code></td><td style="text-align:left">提交暂存区到本地仓库。</td></tr><tr><td style="text-align:left"><code>git reset</code></td><td style="text-align:left">回退版本。</td></tr><tr><td style="text-align:left"><code>git rm</code></td><td style="text-align:left">将文件从暂存区和工作区中删除。</td></tr><tr><td style="text-align:left"><code>git mv</code></td><td style="text-align:left">移动或重命名工作区文件。</td></tr><tr><td style="text-align:left"><code>git notes</code></td><td style="text-align:left">添加注释。</td></tr><tr><td style="text-align:left"><code>git checkout</code></td><td style="text-align:left">分支切换。</td></tr><tr><td style="text-align:left"><code>git switch （Git 2.23 版本引入）</code></td><td style="text-align:left">更清晰地切换分支。</td></tr><tr><td style="text-align:left"><code>git restore （Git 2.23 版本引入）</code></td><td style="text-align:left">恢复或撤销文件的更改。</td></tr><tr><td style="text-align:left"><code>git show</code></td><td style="text-align:left">显示 Git 对象的详细信息。</td></tr></tbody></table><h3 id="提交日志">提交日志</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git log</code></td><td style="text-align:left">查看历史提交记录</td></tr><tr><td style="text-align:left"><code>git blame &lt;file&gt;</code></td><td style="text-align:left">以列表形式查看指定文件的历史修改记录</td></tr><tr><td style="text-align:left"><code>git shortlog</code></td><td style="text-align:left">生成简洁的提交日志摘要</td></tr><tr><td style="text-align:left"><code>git describe</code></td><td style="text-align:left">生成一个可读的字符串，该字符串基于 Git 的标签系统来描述当前的提交</td></tr></tbody></table><h3 id="远程操作">远程操作</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git remote</code></td><td style="text-align:left">远程仓库操作</td></tr><tr><td style="text-align:left"><code>git fetch</code></td><td style="text-align:left">从远程获取代码库</td></tr><tr><td style="text-align:left"><code>git pull</code></td><td style="text-align:left">下载远程代码并合并</td></tr><tr><td style="text-align:left"><code>git push</code></td><td style="text-align:left">上传远程代码并合并</td></tr><tr><td style="text-align:left"><code>git submodule</code></td><td style="text-align:left">管理包含其他 Git 仓库的项目</td></tr></tbody></table><blockquote><p>注意：git commit 后会进入vim编辑器界面</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409161405612.png" alt=""></p><p>基本操作：</p><ol><li>按下字母键<code>i</code>或<code>a</code>或<code>o</code>，此时进入到可编辑状态，这时就可以输入你的注释</li><li>当你输入完之后，按下<code>Esc</code>键就可退出编辑状态，回到一般模式。</li><li>最后就是怎么退出vim编辑器并提交commit， 有两种方法：</li></ol><ul><li>输入两字大写字母<code>ZZ</code>（记住是大写）</li><li>输入<code>:wq</code>或<code>:wq!</code>(强行退出)</li></ul></blockquote><h1 id="忽略文件">忽略文件</h1><p>.gitignore文件中可以选择忽略的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt          <span class="comment">#忽略 .txt结尾的文件</span></span><br><span class="line">!lib.txt       <span class="comment">#处理 lib.txt</span></span><br><span class="line">/temp    <span class="comment">#忽略名为 temp 的目录及其所有内容</span></span><br><span class="line">build/         <span class="comment">#忽略 build 目录下所有文件</span></span><br><span class="line">doc/*.txt      <span class="comment">#忽略doc文件夹下的 .txt结尾的所有文件 </span></span><br></pre></td></tr></table></figure><h1 id="github远程仓库">github远程仓库</h1><p>在使用前要先连接github <a href="https://www.runoob.com/git/git-remote-repo.html">Git 远程仓库(Github) | 菜鸟教程 (runoob.com)</a></p><h2 id="添加远程仓库">添加远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;别名&gt; &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:KQLXK/test.git</span><br></pre></td></tr></table></figure><h2 id="查看远程仓库">查看远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h2 id="拉取远程仓库">拉取远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin main</span><br></pre></td></tr></table></figure><h2 id="推送到远程仓库">推送到远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h2 id="删除远程仓库">删除远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> [别名]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]事务</title>
      <link href="/2024/09/10/Mysql-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/09/10/Mysql-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><h2 id="是什么">是什么</h2><p><strong>事务是一组操作的集合</strong>，可以包括查询，删除，修改等具体操作，是作为一个整体出现，可以理解为一个函数，一般包含多个语句</p><p>比如，在一个人员管理系统中，要删除一个人，就要先找到这个人的id，在删除与他相关的各种信息如文章，信箱等，这些数据库操作语句就构成了一个事务</p><h2 id="操作语句">操作语句</h2><p>方法一：用BEGIN, ROLLBACK, COMMIT 来实现</p><ul><li><p>开启事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><p>方法二：直接用 SET 来改变 MySQL 的自动提交模式</p><ul><li><p>禁止自动提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line"></span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">程序抛出异常</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">commit;   --(手动)</span><br><span class="line">rollback; --(手动)</span><br></pre></td></tr></table></figure><h2 id="性质-acid">性质(ACID)</h2><p><strong>原子性</strong>：事务是不可分割的最小单元，要么全部成功，要么全部失败</p><p><strong>一致性</strong>： 事务完成时，必须使所有的数据都保持和数据库的一致状态，也就是写入或修改的数据必须和数据库的预设完全一样</p><p><strong>隔离性</strong>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p><strong>持久性</strong>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h1 id="并发事务引发问题">并发事务引发问题</h1><p>只是指出了问题</p><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">一个事务在查询数据时，没有对应的数据行，但是在插入数据是，又发现这行数据已经存在，好像出现了幻影</td></tr></tbody></table><h1 id="事务隔离级别">事务隔离级别</h1><p>用于解决并发事务所引发的问题</p><p>安全性越来越高，性能越低</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409121056830.png" alt=""></p><p>read uncommited(读未提交)：读取的数据是未提交的数据，自然会导致三个问题</p><p>read commited(读已提交)：读取的数据是已提交的，可以避免脏读，但是如果提交后数据被改变，还是会出现不可重复读和幻读</p><p>repeatable read(重复读)：解决不可重复读问题</p><p>serializable(串行化)：只允许同时有一个事务操作数据表，解决幻读</p><ul><li><p>设置事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level ...</span><br></pre></td></tr></table></figure></li><li><p>查询事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]go语言操作MySQL</title>
      <link href="/2024/08/26/Go-go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMySQL/"/>
      <url>/2024/08/26/Go-go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="连接数据库">连接数据库</h1><h2 id="下载依赖">下载依赖</h2><p>首先在终端用以下代码下载依赖</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><h2 id="建立连接">建立连接</h2><ul><li><p><strong>dsn语句存储连接信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">&quot;username:password@tcp(127.0.0.1:3306)/dbname?charset=utf8&quot;</span></span><br></pre></td></tr></table></figure><p>用户名+密码+主机+数据库名+字符集</p></li><li><p><strong>sql.open()函数建立连接</strong></p><p>函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err = sql.open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br></pre></td></tr></table></figure></li><li><p><strong>错误判断</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="built_in">panic</span>(err) <span class="comment">// 如果连接失败则 panic，通常不推荐使用 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;连接数据库成功&quot;</span>)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p><strong>有效性检查</strong></p><p><code>sql.open()</code>并不能建立起实际的连接，也就是不能验证dsn里所给信息是否正确，所以我们要用<code>ping</code>方法来检查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;检查成功，已正确连接&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭数据库</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></li></ul><h1 id="crud">CRUD</h1><h2 id="查询">查询</h2><p>使用<code>QueryRow()</code>,<code>Query()</code>函数</p><p>函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Row, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>创建结构体</strong></p><p>首先要创建一个符合数据库中数据类型和结构的结构体来储存数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建sqlStr储存查询信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>调用QueryRow</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;u.id, &amp;u.name. &amp;u.age)</span><br></pre></td></tr></table></figure></li><li><p><strong>错误处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查询成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整体代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(id <span class="type">int</span>, db *sql.DB)</span></span> User &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br><span class="line">err := db.QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;user.id, &amp;user.name, &amp;user.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查询成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="插入">插入</h2><p>插入，删除，更新都使用<code>Exec</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, err)</span><br></pre></td></tr></table></figure><p><code>Result</code>是对<code>sql</code>命令的总结</p><p>代码大体和查询相同，不多做赘述</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(user User, db *sql.DB)</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;insert into student(sname,sage,sid,ssex) values(?,?,?,?)&quot;</span></span><br><span class="line">res, err := db.Exec(sqlStr, user.name, user.age, user.id, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(res.LastInsertId())</span><br><span class="line">fmt.Println(<span class="string">&quot;成功添加&quot;</span>, user.name, <span class="string">&quot;到数据库中&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改">修改</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;update user set age=? where id = ?&quot;</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;update failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;update success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;delete from user where id = ?&quot;</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;delete failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;delete success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mysql预处理">MySQL预处理</h1><h2 id="是什么">是什么</h2><p>先传一段带有占位符的语句给Mysql服务端，之后只需要传数据即可</p><p>类似于模板</p><h2 id="实现">实现</h2><p>由 <code>database/sql</code>中的<code>Prepare</code>方法实现</p><p>原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>以查询操作为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareQuery</span><span class="params">(id <span class="type">int</span>, db *sql.DB)</span></span> User &#123;</span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">fmt.Println(<span class="string">&quot;query failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">err = stmt.QueryRow(id).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现mysql事务">实现MySQL事务</h1><h2 id="相关方法">相关方法</h2><ul><li>开始事务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin()(*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>提交</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db* DB)</span></span> Commit() <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li>回滚</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="事务示例">事务示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">dsn := <span class="string">&quot;root:yuchao123@tcp(127.0.0.1:3306)/test&quot;</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">tx, err := db.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;begin a transaction failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlstr := <span class="string">&quot;update account set money = 1000 where name = &#x27;张三&#x27;&quot;</span></span><br><span class="line">res, err := tx.Exec(sqlstr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">fmt.Println(<span class="string">&quot;update1 failed&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">affrow, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">fmt.Println(<span class="string">&quot;get rowsaffected failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affrow == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;transaction commited&quot;</span>)</span><br><span class="line">tx.Commit()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;transaction Rollback&quot;</span>)</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]反射</title>
      <link href="/2024/08/21/Go-%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/08/21/Go-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射是什么">反射是什么</h1><p>反射在 Go 语言中是一个非常强大的工具，它允许程序在运行时检查和操作类型和数据。用通俗的话来解释，就是反射可以让你“看见”或“操控”程序中的值和类型</p><p>具体来说，反射就是一个包，包里有各种函数可以返回对象的 <strong>类型</strong> 和 <strong>值</strong> ，而类型又分为<code>name</code>和<code>kind</code>，而对于结构体，又有<code>NumField()</code>和<code>Field()</code>等方法来获得详细信息</p><h1 id="reflect-typeof">reflect.Typeof()</h1><p><code>type</code> 还分为 <code>name</code>和<code>kind</code>，name可以是一些自定义类型或结构体名，而 Kind 就是它最底层的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《跟小王子学Go语言》&quot;</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reflect-valueof">reflect.Valueof()</h1><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Interface() interface {}</td><td style="text-align:center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td style="text-align:center">Int() int64</td><td style="text-align:center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Uint() uint64</td><td style="text-align:center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Float() float64</td><td style="text-align:center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td style="text-align:center">Bool() bool</td><td style="text-align:center">将值以 bool 类型返回</td></tr><tr><td style="text-align:center">Bytes() []bytes</td><td style="text-align:center">将值以字节数组 []bytes 类型返回</td></tr><tr><td style="text-align:center">String() string</td><td style="text-align:center">将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"><span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>通过反射设置变量的值</strong></p><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>isNil()和isValid()</strong></p><p><strong>isNil()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsNil() <span class="type">bool</span></span><br></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><p><strong>isValid()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsValid() <span class="type">bool</span></span><br></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><h4 id="举个例子">举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// *int类型空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line"><span class="comment">// nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;娜扎&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="结构体反射">结构体反射</h1><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Field(i int) StructField</td><td style="text-align:center">根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">NumField() int</td><td style="text-align:center">返回结构体成员字段数量。</td></tr><tr><td style="text-align:center">FieldByName(name string) (StructField, bool)</td><td style="text-align:center">根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">FieldByIndex(index []int) StructField</td><td style="text-align:center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td style="text-align:center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td style="text-align:center">根据传入的匹配函数匹配需要的字段。</td></tr><tr><td style="text-align:center">NumMethod() int</td><td style="text-align:center">返回该类型的方法集中方法的数目</td></tr><tr><td style="text-align:center">Method(int) Method</td><td style="text-align:center">返回该类型方法集中的第i个方法</td></tr><tr><td style="text-align:center">MethodByName(string)(Method, bool)</td><td style="text-align:center">根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h3 id="structfield类型">StructField类型</h3><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体反射示例">结构体反射示例</h3><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Score: <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line"><span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line"><span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType := v.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]并发</title>
      <link href="/2024/08/19/Go-%E5%B9%B6%E5%8F%91/"/>
      <url>/2024/08/19/Go-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><p>并发：同一时刻执行多个任务</p><p>并行：一个时间段内执行多个任务</p><p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p><p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。</p><p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。</p><p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p><h1 id="goroutine">goroutine</h1><h2 id="如何使用">如何使用</h2><p>只需要在调用的函数或方法前加上<code>go</code>关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>    <span class="comment">//创建一个新的 goroutine 运行函数f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;()          <span class="comment">//匿名函数也支持使用go关键字创建 goroutine 去执行。</span></span><br></pre></td></tr></table></figure><h2 id="启动单个goroutine">启动单个goroutine</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会交替输出这两句话</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408192039040.png" alt=""></p><p>而如果没有加入for循环，重新执行程序后会输出</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuck you apex</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>为什么会先打印 fuck you apex？因为程序创建一个<code>goroutine</code>执行函数是是要花费时间的，而此时main函数会继续执行下去，所以会先打印下面的那句话，而如果当main函数执行完之后<code>goroutine</code>的创建还没有完成，那就会在打印了fuck you apex 后直接退出程序，也就是只有这一句话</p><p>那我们如何做到确保所有的并发结束后才退出程序呢？我们可以使用sync包中的<code>sync.WaitGroup</code>来等待所有并发完成</p><p>下面是示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动多个goroutine">启动多个goroutine</h2><p>启动多个goroutine和单个同理，使用<code>sync.WaitGroup</code>来等待所有并发完成即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>, i)</span><br><span class="line">wg2.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg2.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello2(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg2.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现程序输出时 i 是无序的(注意：每次程序的输出都会不一样)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fuck you apex</span><br><span class="line">hello world <span class="number">2</span></span><br><span class="line">hello world <span class="number">7</span></span><br><span class="line">hello world <span class="number">8</span></span><br><span class="line">hello world <span class="number">5</span></span><br><span class="line">hello world <span class="number">9</span></span><br><span class="line">hello world <span class="number">6</span></span><br><span class="line">hello world <span class="number">1</span></span><br><span class="line">hello world <span class="number">0</span></span><br><span class="line">hello world <span class="number">4</span></span><br><span class="line">hello world <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这是因为10个 goroutine 是并发的，而 goroutine 的调度是随机的</p><h2 id="gomaxprocs">GOMAXPROCS</h2><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过<code>runtime.GOMAXPROCS</code>函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部CPU逻辑核心数）</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只有一个核心，所以只能先完成一个，在完成另一个</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B: 0</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 2</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 3</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 4</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 5</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 6</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 7</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 8</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 9</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 0</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 2</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 3</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 4</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 5</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 6</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 7</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 8</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 9</span></span><br></pre></td></tr></table></figure><h1 id="channel">channel</h1><h2 id="为什么要用channel">为什么要用channel</h2><p>单纯的函数的并发是没有意义的，函数与函数交换数据才能体现并发执行函数的意义，这一般有内存共享和通信共享两种方式。go语言中采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡通过通信共享内存</p><p>而<code>channel</code>就是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>**Go 语言中的通道（channel）是一种特殊的类型 。**通道像一个传送带或者队列，总是遵循先入先出的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h2 id="声明和初始化">声明和初始化</h2><ul><li><strong>声明：</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><ul><li><strong>初始化</strong>：</li></ul><p>声明的chan变量需要用<code>make</code>函数初始化后才能使用，未初始化的chan变量默认为<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)  <span class="comment">// 声明一个缓冲区大小为1的通道</span></span><br></pre></td></tr></table></figure><h2 id="基本操作">基本操作</h2><p>channel有发送，接受，关闭三种操作，发送和接受都使用<code>-&gt;</code>符号</p><ul><li><p><strong>发送</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接收</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></li><li><p><strong>取出所有值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ok判断</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    v, ok := &lt;-ch    <span class="comment">// 从通道接收数据</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;        <span class="comment">// 如果通道已经关闭，退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(v)  <span class="comment">// 打印接收到的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用range</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> <span class="keyword">chan</span>&#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>**注意：**一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p></blockquote><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408201950086.png" alt=""></p><h2 id="无缓冲通道">无缓冲通道</h2><p>如果在初始化时不设置缓冲区，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时 会报错表示 <code>deadlock</code></p><p>这是因为无缓冲区的通道就表示接收值后无法接收其他值而是处于发送状态，只有在发送出之后才能继续接受值。就好比快递员一次只能送一个快递，而快递柜则可以容纳多个快递</p><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h2 id="有缓冲通道">有缓冲通道</h2><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h2 id="多返回值模式">多返回值模式</h2><p>对一个通道执行接收操作时支持如下多返回值模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;- <span class="keyword">chan</span></span><br></pre></td></tr></table></figure><ul><li><p>value: 从通道中取出的值，如果通道被关闭则返回对应类型的零值</p></li><li><p>ok: 通道ch关闭时返回 false，否则返回 true</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch1</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向通道">单向通道</h2><p>通过<code>-&gt;</code>和<code>chan</code> 的相对位置可以使通道成为 <strong>只接收</strong> 和 <strong>只发送</strong> 两种类型</p><p>比如下面代码里的f1函数和f2函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch1</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> f1(ch1)</span><br><span class="line"><span class="keyword">go</span> f2(ch1, ch2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ret := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="worker-pool-goroutine-池">worker pool (goroutine 池)</h2><p>工作中我们通常使用<code>workerpool</code>模式来控制goroutine的数量</p><details class="toggle" ><summary class="toggle-button" style="">例子</summary><div class="toggle-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="string">&quot;sync&quot;</span>  </span><br><span class="line"><span class="string">&quot;time&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 结构体，表示任务  </span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;  </span><br><span class="line">ID <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 函数，处理任务  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(id <span class="type">int</span>, tasks &lt;-<span class="keyword">chan</span> Task, wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line"><span class="keyword">defer</span> wg.Done()  </span><br><span class="line"><span class="keyword">for</span> task := <span class="keyword">range</span> tasks &#123;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d: processing task %d\n&quot;</span>, id, task.ID)  </span><br><span class="line"><span class="comment">// 模拟任务处理时间  </span></span><br><span class="line">time.Sleep(time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">const</span> numWorkers = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">const</span> numTasks = <span class="number">10</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建任务通道  </span></span><br><span class="line">tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, numTasks)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工作 goroutines  </span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= numWorkers; w++ &#123;  </span><br><span class="line">wg.Add(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">go</span> Worker(w, tasks, &amp;wg)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= numTasks; i++ &#123;  </span><br><span class="line">tasks &lt;- Task&#123;ID: i&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">close</span>(tasks) <span class="comment">// 关闭任务通道  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有 worker 完成  </span></span><br><span class="line">wg.Wait()  </span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All tasks completed.&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li><strong>Task 结构体</strong>：表示一个任务，这里使用简单的结构体 <code>Task</code> 来表示任务，你可以根据需要添加其他字段。</li><li><strong>Worker 函数</strong>：<ul><li>每个 worker goroutine 在循环中从 <code>tasks</code> 通道接收任务，并对其进行处理。</li><li>使用 <code>fmt.Printf</code> 打印正在处理的任务的 ID。</li><li>使用 <code>time.Sleep</code> 模拟任务处理时的延迟（可以替换为实际任务逻辑）。</li></ul></li><li><strong>主函数</strong>：<ul><li><code>numWorkers</code> 和 <code>numTasks</code> 常量用于定义工作池的大小和要处理的任务数量。</li><li>创建一个 <code>tasks</code> 通道，用于存储任务。</li><li>启动多个 worker goroutines，每个 worker 都会处理来自 <code>tasks</code> 通道的任务。</li><li>向 <code>tasks</code> 通道发送任务并在发送完所有任务后关闭通道。</li><li>使用 <code>sync.WaitGroup</code> 等待所有的 worker 完成任务。</li></ul></li></ol></div></details><h1 id="select多路复用">select多路复用</h1><p>某些场景下我们需要从多个通道中接收数据，我们可以使用<code>select</code>语句，可以同时响应多个通道的操作</p><p>类似于switch语句，select 语句有一系列case分支和默认分支，每个case分支对应一个通道的通信过程，select会等待到其中一个case的通信操作完成后，执行该case分支对应的语句，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> data := &lt;- ch2:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> ch3 &lt;- <span class="number">10</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，</p><p>第一个for循环，i = 0，ch是空的所以会执行第一个case</p><p>第二个for循环，i = 1，ch满了，所以会执行第二个case</p><p>会依次打出 0 2 4 6 8</p><h1 id="并发安全和锁">并发安全和锁</h1><p>在我们的代码中，可能会出现多个goroutine公用一个资源的情况，这种情况下就会发生 <code>竟态问题</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，两个goroutine都在调用<code>add</code>函数，同时对<code>x</code>进行<code>+1</code>操作，会导致两次<code>add</code>操作被覆盖为一次，从而使最后输出的<code>x</code>不到10000</p><p>这个时候我们就可以使用 <code>sync</code> 包中的 <code>mutex</code> 类型来实现互斥锁，达到我们想要的效果</p><h2 id="互斥锁">互斥锁</h2><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Mutex) Lock()</td><td style="text-align:center">获取互斥锁</td></tr><tr><td style="text-align:center">func (m *Mutex) Unlock()</td><td style="text-align:center">释放互斥锁</td></tr></tbody></table><p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量<code>x</code>，从而修复上面代码中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x    <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改写之后，每次运行都会得到10000</p><blockquote><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p></blockquote><h1 id="sync包">sync包</h1><h2 id="sync-waitgroup">sync.WaitGroup</h2><p>Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (wg * WaitGroup) Add(delta int)</td><td style="text-align:center">计数器+delta</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Done()</td><td style="text-align:center">计数器-1</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Wait()</td><td style="text-align:center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done() 方法吧计数器减1，调用 wait() 等待所有并发任务完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>, i)</span><br><span class="line">wg2.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg2.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello2(i)</span><br><span class="line">    &#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg2.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-once">sync.Once</h2><p>不是很了解，就搬点代码</p><details class="toggle" ><summary class="toggle-button" style="">llll</summary><div class="toggle-content"><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure><p>**注意：**如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p><h4 id="加载配置文件示例">加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line"><span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line">icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发安全的单例模式">并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p></div></details><h2 id="sync-map">sync.Map</h2><p>go语言并发编程中不能使用内置数据类型map，会导致数据竞争问题，所以编译器会报错。sync包中提供了一个并发安全版map，还内置了一下方法</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Map) Store(key, value interface{})</td><td style="text-align:center">存储key-value数据</td></tr><tr><td style="text-align:center">func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td style="text-align:center">查询key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td style="text-align:center">查询或存储key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td style="text-align:center">查询并删除key</td></tr><tr><td style="text-align:center">func (m *Map) Delete(key interface{})</td><td style="text-align:center">删除key</td></tr><tr><td style="text-align:center">func (m *Map) Range(f func(key, value interface{}) bool)</td><td style="text-align:center">对map中的每个key-value依次调用f</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="string">&quot;sync&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">var</span> m sync.Map  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 存储一些值到 sync.Map 中  </span></span><br><span class="line">m.Store(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)  </span><br><span class="line">m.Store(<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>)  </span><br><span class="line">m.Store(<span class="string">&quot;baz&quot;</span>, <span class="number">3</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Range 遍历所有键值对  </span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, key, value)  </span><br><span class="line"><span class="comment">// 返回 true 以继续遍历  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止遍历示例  </span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;bar&quot;</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 停止遍历  </span></span><br><span class="line">&#125;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, key, value)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续遍历  </span></span><br><span class="line">&#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>创建 <code>sync.Map</code></strong>：通过 <code>var m sync.Map</code> 创建一个并发安全的映射。</li><li><strong>存储键值对</strong>：使用 <code>Store</code> 方法将键值对存储到 <code>sync.Map</code> 中。</li><li><strong>遍历映射</strong>：通过 <code>Range</code> 方法遍历映射中的所有项，传入的回调函数会在每个键值对被迭代时被调用。</li><li><strong>停止遍历</strong>：在第二次调用 <code>Range</code> 方法的回调函数中，可以通过返回 <code>false</code> 来提前停止遍历。</li></ol><h1 id="原子操作">原子操作</h1><details class="toggle" ><summary class="toggle-button" style="">以下内容搬运自 [Go语言基础之并发 | 李文周的博客 (liwenzhou.com)](https://www.liwenzhou.com/posts/Go/concurrence/#c-0-6-5)</summary><div class="toggle-content"><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包">atomic包</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">func LoadInt32(addr *int32) (val int32)func LoadInt64(addr *int64) (val int64)func LoadUint32(addr *uint32) (val uint32)func LoadUint64(addr *uint64) (val uint64)func LoadUintptr(addr *uintptr) (val uintptr)func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td style="text-align:center">读取操作</td></tr><tr><td style="text-align:center">func StoreInt32(addr *int32, val int32)func StoreInt64(addr *int64, val int64)func StoreUint32(addr *uint32, val uint32)func StoreUint64(addr *uint64, val uint64)func StoreUintptr(addr *uintptr, val uintptr)func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td style="text-align:center">写入操作</td></tr><tr><td style="text-align:center">func AddInt32(addr *int32, delta int32) (new int32)func AddInt64(addr *int64, delta int64) (new int64)func AddUint32(addr *uint32, delta uint32) (new uint32)func AddUint64(addr *uint64, delta uint64) (new uint64)func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td style="text-align:center">修改操作</td></tr><tr><td style="text-align:center">func SwapInt32(addr *int32, new int32) (old int32)func SwapInt64(addr *int64, new int64) (old int64)func SwapUint32(addr *uint32, new uint32) (old uint32)func SwapUint64(addr *uint64, new uint64) (old uint64)func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td style="text-align:center">交换操作</td></tr><tr><td style="text-align:center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td style="text-align:center">比较并交换操作</td></tr></tbody></table><h3 id="示例">示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Inc() &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Inc() &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Inc() &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">test(c1)</span><br><span class="line">c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">test(&amp;c2)</span><br><span class="line">c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数/类型实现同步更好。</p></div></details><h1 id="练习题">练习题</h1><p>使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。</p><ol><li>开启一个 goroutine 循环生成int64类型的随机数，发送到<code>jobChan</code></li><li>开启24个 goroutine 从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code></li><li>主 goroutine 从<code>resultChan</code>取出结果并打印到终端输出</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(i <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sum += i % <span class="number">10</span></span><br><span class="line">i = i / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addnums</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">randomnum := rand.Int63()</span><br><span class="line">ch &lt;- randomnum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">caul</span><span class="params">(jch &lt;-<span class="keyword">chan</span> <span class="type">int64</span>, rch <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">temp, ok := &lt;-jch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">lock.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lock.Unlock()</span><br><span class="line">rch &lt;- sub(temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">100</span>)</span><br><span class="line">reschan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> addnums(jobchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">24</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> caul(jobchan, reschan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*go func() &#123;</span></span><br><span class="line"><span class="comment">wg.Wait()</span></span><br><span class="line"><span class="comment">close(reschan)</span></span><br><span class="line"><span class="comment">&#125;()*/</span></span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(reschan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp := <span class="keyword">range</span> reschan &#123;</span><br><span class="line">fmt.Println(temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deadlock</strong></p><ol><li>channel阻塞(缓冲区不够)</li><li>channel未关闭</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]常见数据结构</title>
      <link href="/2024/08/15/Go-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/08/15/Go-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组</h2><h3 id="定义：">定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：go语言数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化</p></blockquote><h3 id="初始化：">初始化：</h3><p>三种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明时初始化列表</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ... 省略长度</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引初始化</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125; </span><br></pre></td></tr></table></figure><blockquote><ol><li>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</li><li>数组支持 “==&quot;、”!=&quot; 操作符，因为内存总是被初始化过的。</li></ol></blockquote><h2 id="多维数组">多维数组</h2><h3 id="二维数组的定义："><strong>二维数组的定义</strong>：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说只有第一个参数可以省略</p></blockquote><h2 id="切片-slice">切片(slice)</h2><p>切片的底层就是数组，不同的是切片非常灵活，支持自动扩容</p><h3 id="定义："><strong>定义</strong>：</h3><p><code>var 切片名 []数据类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name[] <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时初始化</span></span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span> = array[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="初始化：">初始化：</h3><ul><li><p><strong>数组得到切片</strong></p><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>切片再次切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    name2 := name[<span class="number">0</span>:<span class="number">1</span>]     <span class="comment">//切片构造切片</span></span><br><span class="line">fmt.Println(name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用make()函数构造切片</strong></p><p>make函数使用格式：<code>make([]T, size, cap)</code></p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用make函数构造切片时会自动加入size个值，默认为0</p></blockquote></li></ul><h3 id="切片增加复制和删除元素">切片增加复制和删除元素</h3><ul><li><p><strong>append()</strong>:</p><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你调用 <code>append</code> 时，Go 会检查切片的容量。如果容量足够容纳新元素，<code>append</code> 将直接在原来的底层数组上添加元素，并返回同一个切片。</li><li>如果当前切片的容量不够，<code>append</code> 将创建一个新的底层数组，复制原有元素并添加新元素，最后返回指向新底层数组的切片。</li></ul></li><li><p><strong>copy()</strong>:</p><p><code>copy(destSlice, srcSlice []T)</code></p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>相当于深拷贝</p></li><li><p><strong>删除元素</strong>：</p><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p></li></ul><h3 id="切片表达式">切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><p>切片表达式就是刚刚初始化切片用到的[]</p><ul><li><p><strong>简单切片表达式</strong>：</p><p><code>a[low : high]</code></p><ul><li><p><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</p></li><li><p><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br></pre></td></tr></table></figure><p>省略部分参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完整切片表达式</strong>：</p><p><code>a[low : high : max]</code></p><ul><li><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</li><li><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</li><li><code>max</code>: 这是切片的最大容量，可以大于 <code>high</code>，但是不能超过原数组的长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表-map">哈希表(map)</h2><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="定义">定义</h3><p><code>map [KeyType]ValueType</code></p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><h3 id="初始化">初始化</h3><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><p><code>make(map[KeyType]ValueType, [cap])</code></p><blockquote><p>注意：map在进行操作前必须用make进行初始化，不然其地址默认为nil</p></blockquote><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本使用">基本使用</h3><ul><li><p>添加数据：</p><p><code>map[key] = value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>          <span class="comment">// 添加键为 &quot;apple&quot;，值为 5  </span></span><br><span class="line">m[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>         <span class="comment">// 添加键为 &quot;banana&quot;，值为 3  </span></span><br><span class="line">m[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span>         <span class="comment">// 添加键为 &quot;orange&quot;，值为 7</span></span><br></pre></td></tr></table></figure></li><li><p>删除数据：</p><p><code>delete(map, key)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断某个键是否存在：</p><p><code>value, ok := map[key]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]基本语法</title>
      <link href="/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="变量">变量</h1><h2 id="常见变量类型">常见变量类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//布尔型</span><br><span class="line">bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//字符型</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//数值型</span><br><span class="line">有符号 int  int8  int16  int32  int64</span><br><span class="line">无符号 uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">         // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">复数 complex64 complex128</span><br></pre></td></tr></table></figure><blockquote><p>go语言里没有char类型，单个字符会用对应的ASCII码以及别的码以int32类型来存储</p></blockquote><h2 id="变量声明">变量声明</h2><ul><li><p><strong>var关键字</strong>：</p><p>语法：<code>var 变量 类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&#x27;yc&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span>         <span class="comment">//同时定义多个变量</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>短变量声明</strong>：</p><p>语法：<code>变量 := 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&#x27;yc&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认值</strong>:</p><table><thead><tr><th style="text-align:center">变量类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">int, float…</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">‘’</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">切片，函数，指针…</td><td style="text-align:center">null</td></tr></tbody></table></li></ul><h2 id="变量交换">变量交换</h2><p>go语言中由独特的变量交换机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><h2 id="匿名变量">匿名变量</h2><p>匿名变量的特点是是一个下划线&quot;_&quot; , 它可以像别的变量一样被赋值，声明，但不能被使用，因为任何被赋给他的值都会被抛弃</p><p>人话：用来处理不需要的数据，比如多余的函数返回值等</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ = test()</span><br><span class="line">    _ ,b = test()</span><br><span class="line">    fmt.Println(a, b)     <span class="comment">//输出结果为100，200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li><p><strong>局部变量</strong></p><p>函数体内定义的变量，只能在函数体内使用</p></li><li><p><strong>全局变量</strong></p><p>函数外定义的变量，可以在整个go文件使用</p></li></ul><blockquote><p>局部变量可以和全局变量同名，调用时优先考虑局部变量</p></blockquote><hr><h1 id="常量">常量</h1><h2 id="const关键字">const关键字</h2><p>语法：<code>const 常量名 (类型) = 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name <span class="type">string</span> = <span class="string">&quot;yc&quot;</span>   <span class="comment">//显示声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;ycc&quot;</span>         <span class="comment">//隐式声明</span></span><br></pre></td></tr></table></figure><h2 id="iota计数器">iota计数器</h2><p>iota计数器在const中定义，每增加一个常量就加一，在下一个const出现时重置为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span>(</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">        b   <span class="comment">//1</span></span><br><span class="line">        c   <span class="comment">//2</span></span><br><span class="line">        d = <span class="string">&quot;yccc&quot;</span></span><br><span class="line">        e   <span class="comment">//yccc</span></span><br><span class="line">        f = <span class="number">100</span></span><br><span class="line">        g   <span class="comment">//100</span></span><br><span class="line">        h = <span class="literal">iota</span>  <span class="comment">//7</span></span><br><span class="line">        i   <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数据类型">数据类型</h1><p>不多做赘述，就写点快忘记的</p><ul><li><p>转义字符</p><p>”\“后的字符是 转义字符</p><p>常见的转义字符</p><ol><li><strong><code>\n</code></strong>: 换行符</li><li><strong><code>\r</code></strong>: 回车符</li><li><strong><code>\t</code></strong>: 制表符（水平Tab）</li><li><strong><code>\\</code></strong>: 反斜杠（<code>\</code>）</li><li><strong><code>\'</code></strong>: 单引号</li><li><strong><code>\&quot;</code></strong>: 双引号</li><li><strong><code>\b</code></strong>: 退格符</li><li><strong><code>\f</code></strong>: 换页符</li><li><strong><code>\v</code></strong>: 垂直制表符</li><li><strong><code>\a</code></strong>: 响铃（警告音）</li></ol></li><li><p>数据类型转换</p><p>同c</p></li></ul><hr><h1 id="运算符">运算符</h1><h2 id="位运算符">位运算符</h2><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符&quot;&amp;&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td style="text-align:left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">按位或运算符&quot;|&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td style="text-align:left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符&quot;^&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td style="text-align:left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移运算符&quot;&lt;&lt;“是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;“左边的运算数的各二进位全部左移若干位，由”&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移运算符&quot;&gt;&gt;“是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数。</td><td style="text-align:left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr><tr><td style="text-align:left">&amp;^</td><td style="text-align:left">位清空，a&amp;^b，对于被上的每一个值，若为0则取a对应位上的数值，若为1，则取0</td><td style="text-align:left">a&amp;^b结果位48</td></tr></tbody></table><h2 id="赋值运算符">赋值运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td style="text-align:left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">相加后再赋值</td><td style="text-align:left">C += A 等于 C = C + A</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">相减后再赋值</td><td style="text-align:left">C -= A 等于 C = C - A</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">相乘后再赋值</td><td style="text-align:left">C *= A 等于 C = C * A</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">相除后再赋值</td><td style="text-align:left">C /= A 等于 C = C / A</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">求余后再赋值</td><td style="text-align:left">C %= A 等于 C = C % A</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">左移后赋值</td><td style="text-align:left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">右移后赋值</td><td style="text-align:left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">按位与后赋值</td><td style="text-align:left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">按位异或后赋值</td><td style="text-align:left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td style="text-align:left">|=</td><td style="text-align:left">按位或后赋值</td><td style="text-align:left">C |= 2 等于 C = C | 2</td></tr></tbody></table><hr><h1 id="流程控制">流程控制</h1><h2 id="选择结构">选择结构</h2><ul><li><strong>if语句</strong>：</li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;  </span><br><span class="line">    <span class="comment">// 条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> anotherCondition &#123;  </span><br><span class="line">    <span class="comment">// 第一个条件为 false 且第二个条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 所有条件均为 false 时执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>switch语句</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> variable &#123;  </span><br><span class="line"><span class="keyword">case</span> value1:  </span><br><span class="line">    <span class="comment">// 当 variable == value1 时执行的代码  </span></span><br><span class="line"><span class="keyword">case</span> value2:  </span><br><span class="line">    <span class="comment">// 当 variable == value2 时执行的代码  </span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">    <span class="comment">// 如果没有匹配的值，执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环结构">循环结构</h2><blockquote><p>go语言只有<code>for</code>关键字，没有<code>while</code></p></blockquote><ul><li><p>基本for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件循环（类似于<code>while</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">        i++  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>死循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    count := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">        count++  </span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 退出循环  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>range关键字：</p><p>在go语言中，我们可以用<code>range</code>关键字来遍历切片，数组等数据结构</p><p>一般会返回两个值，<code>index</code>和<code>value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, number := <span class="keyword">range</span> numbers &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;索引: %d, 数字: %d\n&quot;</span>, index, number)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="函数">函数</h1><h2 id="函数声明">函数声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数">可变参数</h2><ul><li><p><strong>是什么</strong>：一个函数的参数类型确定，但个数不确定，可以使用可变参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(arg ... <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg ... int会告诉go语言这个函数接收不定数量的参数，类型全是int</span></span><br></pre></td></tr></table></figure></li><li><p><strong>例子</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := getSum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">sum = sum + nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数传递">参数传递</h2><table><thead><tr><th style="text-align:left">传递类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-value.html">值传递</a></td><td style="text-align:left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-reference.html">引用传递</a></td><td style="text-align:left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><h2 id="递归函数">递归函数</h2><p>递归，就是在运行的过程中调用自己。</p><p>语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p><p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p><ul><li>实例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">uint64</span>)</span></span>(result <span class="type">uint64</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">15</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(<span class="type">uint64</span>(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例执行输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 的阶乘是 1307674368000</span><br></pre></td></tr></table></figure><h2 id="defer语句">defer语句</h2><p>在 Go 语言中，<code>defer</code> 语句用于在函数返回之前执行某个操作。它常被用于进行清理工作，比如关闭文件、解锁资源、记录日志等。<code>defer</code> 语句会被推迟执行，直到外层函数返回。</p><p>如果有多个defer语句，会按照先进后出的顺序执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Third  </span><br><span class="line">Second  </span><br><span class="line">First</span><br></pre></td></tr></table></figure><blockquote><p>defer语句一般用于关闭文件，在并发编程中解锁资源等</p></blockquote><h2 id="函数的数据类型">函数的数据类型</h2><p>当我们用printf函数打印函数的类型是，我们会发现编译器会输出函数的类型</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408101757129.png" alt=""></p><p>在 Go 语言中，函数本身也是一种数据类型。这使得函数可以像其他变量一样被赋值、传递和返回。</p><ul><li><p><strong>函数作为变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a + b  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> = add  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := myFunc(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> op(a, b)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := operate(<span class="number">3</span>, <span class="number">4</span>, add)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAdder</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    add5 := getAdder(<span class="number">5</span>)  </span><br><span class="line">    fmt.Println(add5(<span class="number">3</span>)) <span class="comment">// 输出: 8  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="匿名函数">匿名函数</h2><p>匿名函数（又称为闭包）是 Go 语言中一种没有名字的函数。它们可以在定义时立即调用，或者赋值给变量以便之后使用。匿名函数在处理回调、并发等场景中非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f1()</span><br><span class="line">    f2 := f1</span><br><span class="line">    f2()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名函数</span></span><br><span class="line">    f3 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接执行匿名函数（自己调用自己）</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;我是自己调用自己&quot;</span>)</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是f1函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：假设<code>func</code>是一个函数名，则<code>func</code>就是一个函数变量，<code>func()</code>就是在调用这个函数，所以<code>c := func</code> 是在把一个匿名函数赋值给变量c，而 <code>c := func()</code> 则是在就收func的返回值</p></blockquote><h2 id="回调函数">回调函数</h2><ul><li><p><strong>定义</strong>：回调函数是一个函数，它作为参数传递给另一个函数，并在某一时刻被调用。</p></li><li><p><strong>用途</strong>：通常用于处理某些事件或条件后的逻辑执行，例如排序、自定义迭代等。</p></li><li><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, add)</span><br><span class="line"></span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a / b &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a, b <span class="type">int</span>, fun <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">r := fun(a, b)</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包">闭包</h2><p>闭包（Closure）指的是一个函数包含了其外部环境的状态。也就是说，闭包可以“记住”创建时的上下文，即使外部函数已经返回。闭包通常用于实现数据的封装、私有变量或状态的管理。</p><p>在 Go 语言中，闭包非常常见，以下是对闭包的详细解释和示例。</p><ul><li><p>概念</p><p>环境：闭包可以访问其外部函数的变量。</p><p>持久性：即使外部函数执行完毕，闭包仍然可以使用这些外部变量。</p></li><li><p>闭包示例</p><p>下面是一个简单的示例，演示如何在 Go 中使用闭包：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个闭包，生成一个计数器  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    count := <span class="number">0</span> <span class="comment">// 外部变量  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个匿名函数（闭包）  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        count++ <span class="comment">// 修改外部变量  </span></span><br><span class="line">        <span class="keyword">return</span> count  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    counter1 := createCounter() <span class="comment">// 创建第一个计数器  </span></span><br><span class="line">    counter2 := createCounter() <span class="comment">// 创建第二个计数器  </span></span><br><span class="line"></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 1  </span></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 2  </span></span><br><span class="line">    fmt.Println(counter2()) <span class="comment">// 输出: 1  </span></span><br><span class="line">    fmt.Println(counter2()) <span class="comment">// 输出: 2  </span></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 3  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong>：</p><ol><li><p>定义外部变量：在 <code>createCounter</code> 函数中，定义了一个外部变量 <code>count</code>，初始值为 0。</p></li><li><p>返回闭包：该函数返回一个匿名函数（闭包），这个闭包会增加并返回 <code>count</code> 的值。</p></li><li><p>保持状态：每次调用 <code>counter1</code> 和 <code>counter2</code> 时，返回的闭包都会记住自己的 <code>count</code> 状态。尽管 <code>createCounter</code> 函数已经返回，但闭包仍然可以操作 <code>count</code> 变量。</p></li><li><p>独立状态：<code>counter1</code> 和 <code>counter2</code> 是两个独立的计数器，不会互相影响。</p></li></ol></li><li><p><strong>输出结果</strong></p><p>运行上述代码会得到以下输出：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br></pre></td></tr></table></figure><ul><li><p><strong>总结</strong></p><p>闭包是一种强大的工具，可以让你在函数内部保留状态，从而实现更灵活和强大的程序设计。在 Go 语言中，闭包被广泛使用，例如在并发编程、事件处理和数据封装等场景中。</p></li></ul><hr><h1 id="指针">指针</h1><h2 id="声明">声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>   <span class="comment">// 声明一个指向 int 的指针 p  </span></span><br></pre></td></tr></table></figure><h2 id="初始化">初始化</h2><p>指针的初始化通常有两种方式：</p><ol><li><p><strong>使用 <code>new</code> 函数</strong>：<br><code>new(T)</code> 会分配零值的类型 <code>T</code> 的空间，并返回一个指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p 是指向 int 的指针  </span></span><br><span class="line">*p = <span class="number">42</span>       <span class="comment">// 设置指针指向的值为 42  </span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过取地址运算符 <code>&amp;</code></strong>：<br>可以通过取已有变量的地址来初始化指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">10</span>  </span><br><span class="line">p := &amp;x       <span class="comment">// p 是指向 x 的指针  </span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：指针作为引用类型，在使用前必须用new来分配内存空间，否则就会默认指向nil</p></blockquote><hr><h1 id="结构体">结构体</h1><h2 id="定义">定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**注意：**结构体中首字母大写字段表示公开，首字母小写表示私有</p></blockquote><h2 id="实例化">实例化</h2><p><code>var 结构体实例 结构体类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化">初始化</h2><blockquote><p>没有初始化的结构体，成员变量都是对应其类型的零值</p></blockquote><ul><li><p>键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>值的列表初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line"><span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol></li></ul><h2 id="构造函数">构造函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名结构体">匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针类型结构体">指针类型结构体</h2><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><h2 id="匿名字段">匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">&quot;小王子&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="结构体嵌套">结构体嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="方法-method">方法(method)</h1><p>（类似于类和类的成员函数）</p><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><h2 id="定义">定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> work() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is working...\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := newPerson(<span class="string">&quot;yuchao&quot;</span>, <span class="number">19</span>)</span><br><span class="line">p1.work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接收者分为指针类型的接收者和值类型的接收者，要改变接收者自身参数时应该使用指针类型的接收者</p></blockquote><h2 id="任意类型添加方法">任意类型添加方法</h2><p>go语言中接收者的类型可以是任意类型，不一定要是结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span></span> SayHello() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法</p></blockquote><h2 id="结构体继承">结构体继承</h2><p>类似于面向对象编程中的继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> move() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is moving\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> bark()&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is barking\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := dog&#123;<span class="number">15</span>, Animal&#123;<span class="string">&quot;yc&quot;</span>&#125;&#125;</span><br><span class="line">d1.move()</span><br><span class="line">d1.bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="接口-interface">接口(interface)</h1><blockquote><p>go语言中的接口是一种<strong>类型</strong>，是一种抽象类型</p><p>类似于面向对象编程的多态</p></blockquote><h2 id="定义">定义</h2><p>接口是一个抽象类型，一个接口由多个方法名组成，当我们声明一个接口的实例后，我们可以直接调用这几个方法，和面向对象编程中动态多态性类似</p><p>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><h2 id="实现一个接口的条件">实现一个接口的条件</h2><p>只要一个类型实现了接口中规定的全部方法，那么他就实现了这个接口</p><p>ex：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dg <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dg)</span></span> say() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dog is barking&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;cat is miao&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">da</span><span class="params">(arg sayer)</span></span> &#123;</span><br><span class="line">arg.say() <span class="comment">//不管传经来的是什么，都要say</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := cat&#123;&#125;</span><br><span class="line">da(c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套">接口嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口">空接口</h2><p>空接口没有定义任何方法，因此可以存储任意类型的值</p><p>ex：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空接口主要有俩个应用</p><ul><li><p>作为函数参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为map里的value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口值">接口值</h2><p>接口值由 <strong>“类型”</strong> 和 <strong>“值”</strong> 组成，我们称之为接口的 <strong>”动态类型“</strong> 和 <strong>”动态值“</strong></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408170052834.png" alt=""></p><p>我们接下来通过一个示例来加深对接口值的理解。</p><p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Move() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;狗在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Brand <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Move() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汽车在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br></pre></td></tr></table></figure><p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface02.png" alt="接口值示例"></p><p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>**注意：**我们不能对一个空接口值调用任何方法，否则会产生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.Move() <span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface03.png" alt="接口值示例"></p><p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c *Car</span><br><span class="line">m = c</span><br></pre></td></tr></table></figure><p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface04.png" alt="接口值示例"></p><p>**注意：**此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x Mover = <span class="built_in">new</span>(Dog)</span><br><span class="line">y Mover = <span class="built_in">new</span>(Car)</span><br><span class="line">)</span><br><span class="line">fmt.Println(x == y) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(z == z) <span class="comment">// panic: runtime error: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure><hr><h1 id="一些用法">一些用法</h1><h2 id="生成随机数">生成随机数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)                <span class="comment">//导入包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 使用当前时间设置随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个范围在[0, 2^63)的随机整数</span></span><br><span class="line">    randomInt := rand.Int63()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个范围在[0, 100)的随机整数</span></span><br><span class="line">    randomInt := rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]作业题</title>
      <link href="/2024/08/03/Mysql-%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2024/08/03/Mysql-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目">题目</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031408188.png" alt=""></p><ol><li>查询姓“朱&quot;&quot;的学生名单</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where sname like &#x27;朱%&#x27;</span><br></pre></td></tr></table></figure></div></details><ol start="2"><li>查询同名同性学生名单，并统计同名人数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname, ssex, count(*) from Student group by sname, ssex having count(*) &gt;= 2</span><br></pre></td></tr></table></figure></div></details><ol start="3"><li>查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cid, avg(score) as score from sc group by cid order by score asc, cid desc;</span><br></pre></td></tr></table></figure></div></details><ol start="4"><li>查询平均成绩大于85的所有学生的学号、姓名和平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sid, s.sname, avg(score) </span><br><span class="line">from sc inner join student s on sc.sid = s.sid </span><br><span class="line">group by s.sid, s.sname having avg(score) &gt;= 85</span><br></pre></td></tr></table></figure></div></details><ol start="5"><li>查询课程名称为“睡觉”&quot;，且分数低于60的学生姓名和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--关联查询</span><br><span class="line">select s.sname, c.cname, sc.score </span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid </span><br><span class="line">where sc.score &lt; 60 and c.cname = &#x27;睡觉&#x27;</span><br><span class="line"></span><br><span class="line">--子查询</span><br><span class="line">select s.sname, sc.score from student s, sc where s.sid = sc.sid and sc.score &lt; 60 and sc.cid in (select cid from course c where c.cname = &#x27;睡觉&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="6"><li>查询所有学生的选课情况</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname</span><br><span class="line">from course c left join sc on c.cid = sc.cid left join student s on s.sid = sc.sid</span><br></pre></td></tr></table></figure></div></details><ol start="7"><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname, sc.score</span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid</span><br><span class="line">where sc.score &gt; 70</span><br></pre></td></tr></table></figure></div></details><ol start="8"><li>查询每门课程被选修的学生数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.cname, count(*)</span><br><span class="line">from sc inner join course c on sc.cid = c.cid</span><br><span class="line">group by c.cname</span><br></pre></td></tr></table></figure></div></details><ol start="9"><li>查询不同老师所教不同课程平均分从高到低显示</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">t.tname as &#x27;老师&#x27;, </span><br><span class="line">c.cname as &#x27;课程名&#x27;, </span><br><span class="line">avg(sc.score) as &#x27;平均分&#x27;</span><br><span class="line">from </span><br><span class="line">course c inner join sc on sc.cid = c.cid </span><br><span class="line">inner join teacher t on t.tid = c.tid</span><br><span class="line">group by </span><br><span class="line">t.tname, </span><br><span class="line">c.cname</span><br><span class="line">order by </span><br><span class="line">avg(sc.score) desc</span><br></pre></td></tr></table></figure></div></details><ol start="10"><li>按各科平均成绩从低到高和及格率的百分数从高到低顺序</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">sc.cid, </span><br><span class="line">avg(sc.score),</span><br><span class="line">(select count(*) from sc sc2 where sc2.cid = sc.cid and </span><br><span class="line">     sc2.score &gt;= 60)/count(*)</span><br><span class="line">from </span><br><span class="line">course c inner join sc on c.cid = sc.cid</span><br><span class="line">group by </span><br><span class="line">sc.cid</span><br><span class="line">order by </span><br><span class="line">avg(sc.score)desc</span><br></pre></td></tr></table></figure></div></details><ol start="11"><li>查询和“2&quot;号的同学学习的课程完全相同的其他同学学号和姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select sc.sid, s.sname </span><br><span class="line">from sc </span><br><span class="line">inner join student s on sc.sid = s.sid </span><br><span class="line">where sc.sid not in(</span><br><span class="line">select sc.sid from sc where sc.cid not in(</span><br><span class="line">    select sc.cid from sc where sc.sid = 2</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">group by sc.sid, s.sname</span><br></pre></td></tr></table></figure></div></details><ol start="12"><li>查询学过“黄观&quot;老师所教的所有课的同学的学号、姓名.</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT sc.sid   </span><br><span class="line">FROM sc   </span><br><span class="line">WHERE sc.cid IN (  </span><br><span class="line">    SELECT c.cid   </span><br><span class="line">    FROM course c   </span><br><span class="line">    INNER JOIN teacher t ON t.tid = c.tid   </span><br><span class="line">    WHERE t.tname = &#x27;黄观&#x27;  </span><br><span class="line">)   </span><br><span class="line">GROUP BY sc.sid   </span><br><span class="line">HAVING COUNT(*) = 2;</span><br></pre></td></tr></table></figure></div></details><ol start="13"><li>把“SC“表中&quot;黄观&quot;老师教的课的成绩都更改为此课程的平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="14"><li>查询课程编号“2&quot;的成绩比课程编号&quot;1&quot;课程低的所有同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select sc1.sid, s.sname</span><br><span class="line">from sc sc2, sc sc1 </span><br><span class="line">inner join student s on s.sid = sc1.sid</span><br><span class="line">where (</span><br><span class="line">sc2.score &lt; sc1.score </span><br><span class="line">and sc2.cid = 2 and sc1.cid = 1 </span><br><span class="line">and sc1.sid = sc2.sid</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><ol start="15"><li>查询没学过“黄观&quot;老师课的同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.sid, s.sname </span><br><span class="line">from student s</span><br><span class="line">where s.sid not in(</span><br><span class="line">select sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    where sc.cid in(</span><br><span class="line">    select c.cid </span><br><span class="line">        from course c</span><br><span class="line">        inner join teacher t on t.tid = c.tid</span><br><span class="line">        where t.tname = &#x27;黄观&#x27;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><blockquote><p>select from 只会往from后面的第一个数据表里做查询，不会对inner join的表里查询，因此如果写了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct s.sid, s.sname </span><br><span class="line">from sc</span><br><span class="line">inner join student s on s.sid = sc.sid</span><br><span class="line">where s.sid not in(</span><br><span class="line"><span class="keyword">select</span> sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    inner join course c on c.cid = sc.cid</span><br><span class="line">    inner join teacher t on t.tid = c.tid</span><br><span class="line">    where t.tname = <span class="string">&#x27;黄观&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样是查不出在student表里但不在sc表里的同学的</p></blockquote><ol><li>查询平均成绩大于60分的同学的学号和平均成绩</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]多表查询</title>
      <link href="/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="创建多表关系">创建多表关系</h1><blockquote><p><strong>外键</strong>：把一张表的主键拿到另一张表中作为一个普通的字段，用来联系起两张表</p><p>语法：constraint 外键名 foreign key 字段 references 表(字段名)</p><p>示例：constraint fk_deptNo foreign key (deptNo) references dept(id)</p><p>其中 fk_deptNo是外键名，deptNo是在这张表里这个外键对应的是字段deptNo，dept(id)是在表dept中，外键对应的是字段id</p></blockquote><h2 id="一对一">一对一</h2><ul><li><p>案例：用户与用户详情的关系</p></li><li><p>关系： 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情</p><p>字段放在另外一张表中，以提升操作效率（呈现的是一些分类的信息）</p></li><li><p>实现： 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique)</p><p>例如每个学员有各种信息，然后每种信息都有ID表示，这个时候就能够用id来建立</p><p>（unique）外键实现两个表的关联（这个外键可以特地设置）</p></li></ul><h2 id="一对多">一对多</h2><ul><li><p>案例： 部门与员工的关系</p></li><li><p>关系： 一个部门对应多个员工，一个员工对应一个部门 （员工是多，部门是一）</p></li><li><p>实现： 在多的一方建立外键，指向一的一方的主键</p></li></ul><p><strong>一对多代码实现</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">------dept------</span><br><span class="line">create table dept(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">deptName varchat(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">deptLeader varchar(<span class="number">10</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------employee------</span><br><span class="line">create table employee(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">salary decimal(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">deptNo varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_deptNo foreign key (deptNo) references dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="多对多">多对多</h2><ul><li><p>案例： 学生与课程的关系</p></li><li><p>关系： 一个学生可以选修多个课程，一门课程也能供多个学生选择</p></li><li><p>实现： 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><strong>多对多代码实现</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------student-------</span><br><span class="line">create table stu(</span><br><span class="line">stu_id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">age int(<span class="number">4</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------course-------</span><br><span class="line">create table course(</span><br><span class="line">course_id varchar(<span class="number">10</span>) primary key,</span><br><span class="line">course_name varchar(<span class="number">255</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------student_course------</span><br><span class="line">create table stu_course(</span><br><span class="line">id varchar(<span class="number">100</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">courseID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">stuID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_courseID foreign key (courseID) references </span><br><span class="line">course(course_id),</span><br><span class="line">constraint fk_stuID foreign key (stuID) references stu(stu_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="多表查询">多表查询</h1><h2 id="子查询">子查询</h2><h2 id="关联查询">关联查询</h2><p><strong>语法规则</strong>：<code>A xxx join B on A.字段 = B.字段</code>，当a字段的值和b字段的值相等时就join</p><ol><li><p><strong>inner join</strong></p><p><code>select 字段列表 from 表1 [inner] join 表2 on 连接条件；</code></p><p>相当于查询两表交集</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011937904.png" alt=""></p></li><li><p><strong>left join</strong></p><p><code>select 字段列表 from 表1 left [outer] join 表2 on 条件….；</code></p><p>相当于查询表1的所有数据 包含表1与表2交集部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011938059.png" alt=""></p></li><li><p><strong>right join</strong></p><p><code>select 字段列表 from 表1 right [outer] join 表2 on 条件… ；</code></p><p>相当于查询表2的所有数据，包含表1与表2交集的部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408041326679.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]排序</title>
      <link href="/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="order-by">order by</h1><p>select * from 表名 order by 字段名 asc(升序)/desc(降序)；</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301502381.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DQL基本查询语句</title>
      <link href="/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="查询所有内容："><strong>查询所有内容</strong>：</h1><p><code>select * from 表名</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291824531.png" alt=""></p><h1 id="查询部分信息："><strong>查询部分信息</strong>：</h1><p><code>select 字段名1，字段名2 from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291825490.png" alt=""></p><h1 id="指定列名："><strong>指定列名</strong>：</h1><p><code>select 字段1 as 名称1，字段2 as 名称2.... from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291829760.png" alt=""></p><h1 id="根据指定字段查询："><strong>根据指定字段查询</strong>：</h1><p><strong>where</strong>：</p><ul><li><p><strong>单条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292039972.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291834601.png" alt=""></p></li><li><p><strong>模糊查询</strong>：</p><p><code>select * from 表名 where 字段名 like '%值%'；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001897.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001206.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292003232.png" alt=""></p></li><li><p><strong>in</strong>：</p><p><code>select * from 表名 where 字段名 in &#123;....&#125;；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292005949.png" alt=""></p></li><li><p><strong>判空查询</strong>：</p><p><code>select * from 表名 where 字段名 is null / is not null;</code></p><p>懒得举例子了</p></li></ul><h1 id="聚合函数查询">聚合函数查询</h1><ul><li><strong>语法</strong>: <code>select function(字段名) from 表名;</code><ol><li><strong>max()</strong></li><li><strong>min()</strong></li><li><strong>avg()</strong></li><li><strong>count()</strong></li><li><strong>sum()</strong></li></ol></li></ul><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301345917.png" alt=""></p><ul><li><p><strong>聚合函数配合group by</strong>:</p><p>作用：按照需要字段分组查询</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301431926.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301432410.png" alt=""></p></li><li><p><strong>having</strong>：</p><p>作用：<strong>对于分组后的数据</strong>按照指定字段进行筛选</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2    having 约束;</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301437352.png" alt=""></p></li></ul><h1 id="综合使用">综合使用</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031428620.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DML增删改操作</title>
      <link href="/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="增加">增加</h1><ol><li><p><strong>单条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values(值1，值2，值3....)</code></p><blockquote><p>注意：传字符串时要手动加上单引号</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291655861.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values</code></p><p>(值1，值2，值3…),</p><p>(值1，值2，值3…);</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291659546.png" alt=""></p></li></ol><h1 id="修改">修改</h1><ul><li><p><code>update 表名 set 字段名1 = 值1，字段名2 = 值2，..... where(限定条件)；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291707563.png" alt=""></p></li></ul><h1 id="删除">删除</h1><ul><li><p><code>delete from 表名 条件限制</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291709519.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]基本DDL操作</title>
      <link href="/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ddl是什么">DDL是什么</h1><p>数据定义语言，用来创建删除修改数据结构</p><h1 id="数据库操作">数据库操作</h1><ol><li><p><strong>创建</strong>：</p><p><code>create database 数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281956271.png" alt=""></p></li><li><p><strong>删除</strong>：</p><p><code>drop database 数据库名；</code></p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958803.png" style="zoom:150%;" /></li><li><p><strong>查询所有数据库</strong>：</p><p><code>show databases;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958717.png" alt=""></p></li><li><p><strong>查询当前数据库</strong>：</p><p><code>select database();</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281959343.png" alt=""></p></li><li><p><strong>使用数据库</strong>：</p><p><code>use  数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282000951.png" alt=""></p></li></ol><h1 id="表的操作">表的操作</h1><h2 id="创建">创建</h2><p>要先指定使用一个数据库</p><p>create table 表的名字{</p><p>​字段名 类型(长度) 约束，</p><p>​字段…</p><p>};</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282007932.png" alt=""></p><p><strong>约束</strong>：</p><ol><li><p>主键约束：唯一地表示一条数据，使其不可以重复，主键不可以为空。</p><p>primary key auto_increment</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282024574.png" alt=""></p></li><li><p>非空约束：这一列数据不允许为空</p><p>not null</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282027885.png" alt=""></p></li><li><p>默认值约束：设置默认值</p><p>default 默认值</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282028665.png" alt=""></p></li><li><p>唯一性约束：数据不允许重复</p><p>unique</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282030689.png" alt=""></p></li></ol><h2 id="删除">删除</h2><p><code>drop table 表名;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291403019.png" alt=""></p><h2 id="修改表结构">修改表结构</h2><ol><li><p><strong>添加字段</strong>：</p><p><code>alter table 表名 add 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291407182.png" alt=""></p></li><li><p><strong>删除字段</strong>：</p><p><code>alter table 表名 drop column 字段名</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291409972.png" alt=""></p></li><li><p><strong>修改字段</strong>：</p><p><code>alter table 表明 modify 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291412790.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]STL标准库</title>
      <link href="/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>C++ STL（标准模板库）提供了多种容器，每种容器都有其特定的功能和一组基本函数。以下是一些常用容器及其基本函数的概览：</p><h3 id="1-序列容器-sequential-containers">1. 序列容器（Sequential Containers）</h3><ul><li><strong>vector</strong><ul><li><code>push_back()</code>: 在容器末尾添加一个元素。</li><li><code>pop_back()</code>: 删除容器末尾的元素。</li><li><code>size()</code>: 返回容器中元素的数量。</li><li><code>capacity()</code>: 返回容器分配的内存足以容纳的元素数量。</li><li><code>reserve()</code>: 改变当前容器的容量。</li><li><code>clear()</code>: 移除容器中的所有元素。</li><li><code>begin()</code>/<code>end()</code>: 返回指向容器开始和结束的迭代器。</li></ul></li><li><strong>deque</strong>（双端队列）<ul><li><code>push_front()</code>: 在容器开头添加一个元素。</li><li><code>pop_front()</code>: 删除容器开头的元素。</li><li>其他函数与 <code>vector</code> 类似。</li></ul></li><li><strong>list</strong><ul><li><code>push_front()</code>: 在列表开头添加一个元素。</li><li><code>pop_front()</code>: 删除列表开头的元素。</li><li><code>sort()</code>: 排序列表中的元素。</li><li>其他函数与 <code>vector</code> 类似，但不支持随机访问迭代器。</li></ul></li><li><strong>forward_list</strong><ul><li>功能类似于 <code>list</code>，但只支持单向迭代。</li></ul></li><li><strong>array</strong><ul><li><code>at()</code>: 安全访问元素，带边界检查。</li><li><code>operator[]</code>: 访问元素。</li><li><code>fill()</code>: 用给定值填充所有元素。</li></ul></li><li><strong>string</strong><ul><li><code>push_back()</code>: 在字符串末尾添加一个字符。</li><li><code>pop_back()</code>: 删除字符串末尾的字符。</li><li><code>size()</code>/<code>length()</code>: 返回字符串长度。</li><li><code>clear()</code>: 清空字符串。</li><li><code>substr()</code>: 返回子字符串。</li><li><code>find()</code>: 查找子字符串的位置。</li></ul></li></ul><h3 id="2-容器适配器-container-adapters">2. 容器适配器（Container Adapters）</h3><ul><li><strong>stack</strong>（栈）<ul><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 删除栈顶元素。</li><li><code>top()</code>: 获取栈顶元素的引用。</li></ul></li><li><strong>queue</strong>（队列）<ul><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 删除队首元素。</li><li><code>front()</code>: 获取队首元素的引用。</li></ul></li><li><strong>priority_queue</strong>（优先队列）<ul><li><code>push()</code>: 在优先队列中添加一个元素。</li><li><code>pop()</code>: 删除具有最高优先级的元素。</li><li><code>top()</code>: 获取最高优先级元素的引用。</li></ul></li></ul><h3 id="3-关联容器-associative-containers">3. 关联容器（Associative Containers）</h3><ul><li><strong>set</strong>（集合）<ul><li><code>insert()</code>: 插入一个元素。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找元素。</li></ul></li><li><strong>multiset</strong><ul><li>与 <code>set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>map</strong>（映射）<ul><li><code>insert()</code>: 插入一个键值对。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找具有特定键的元素。</li></ul></li><li><strong>multimap</strong><ul><li>与 <code>map</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_set</strong>（无序集合）<ul><li>功能类似于 <code>set</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multiset</strong><ul><li>与 <code>unordered_set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_map</strong>（无序映射）<ul><li>功能类似于 <code>map</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multimap</strong><ul><li>与 <code>unordered_map</code> 类似，但允许多个具有相同键的元素。</li></ul></li></ul><h3 id="4-其他容器">4. 其他容器</h3><ul><li><p>bitset</p><p>（位集）</p><ul><li><code>set()</code>: 设置指定位数为1。</li><li><code>reset()</code>: 设置指定位数为0。</li><li><code>flip()</code>: 翻转指定位数的值。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[代码随想录]字符串</title>
      <link href="/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="实现strstr"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">实现strStr()</a></h1><h2 id="题目">题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p>我们把 <code>haystack</code> 称为<strong>主串</strong>，把 <code>needle</code>称为<strong>模式串</strong> 。</p><h2 id="kmp算法">KMP算法</h2><h3 id="基本思想"><strong>基本思想</strong></h3><p>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p><h3 id="前缀和后缀"><strong>前缀和后缀</strong></h3><p>前缀：包含第一个字母但不包含最后一个字母</p><p>后缀：包含最后一个字母但不包含第一个字母</p><p>**注意：**前后缀都是连续抽取的子串</p><p><strong>例子</strong>：</p><p>有字符串&quot;aabaaf&quot;</p><p>前缀是：a,aa,aab…,aabaa</p><p>后缀是：abaaf,baaf,…,f</p><h3 id="前缀表-关键"><strong>前缀表（关键）</strong></h3><p>一般用一个next数组来储存</p><ul><li><p><strong>最长相等前后缀</strong></p><p>指一个字符串里相同前后缀的最长字符串（<strong>注意是要存的一个数值，一个字符串只有一个最长相等前后缀</strong>）</p><p><strong>例子</strong>：</p><p>字符串”aabaa“， 前缀有a, aa, aab, aaba, 后缀有abaa, baa, aa, a. 相同的前后缀有a, aa.所以最长相等前后缀就是2</p></li><li><p><strong>前缀表是什么</strong></p><p>前缀表是一个存储<strong>最长相等前后缀长度</strong>的数组</p><p>换句话说，它告知如果在 <code>needle</code> 中发生了不匹配，我们可以跳过多少个字符继续比较。</p><p><strong>其中第 i 个元素表示的是模式串前 i 个元素所组成的字串的最长相等前后缀</strong>，因此可以直接用next[a]来回退。</p><p><strong>例子</strong>：</p><p>模式串aabaaf，</p><p>前缀表的前 1 个元素构成的字符串为 ：”a“，最大相等前后缀为 0，所以next[0] = 0</p><p>前缀表的前 2 个元素构成的字符串为 ：”aa“，最大相等前后缀为 1，所以next[1] = 1</p><p>前缀表的前 3 个元素构成的字符串为 ：”aab“，最大相等前后缀为 0 ，所以next[2] = 0，以此类推…</p><p>所以字符串 aabaaf 的前缀表就是 {0，1，0，1，2，0}</p></li><li><p><strong>前缀表的作用（关键）</strong></p><p>当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。<strong>而不是一个字符一个字符遍历</strong></p></li><li><p><strong>前缀表的代码实现</strong></p><ol><li><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure><p><strong>变量 j 表示的是最长相等前后缀长度，而s[j] 则表示相等前后缀最后一个字符的再后面一个字符</strong>，而将next数组的第一个元素赋值为-1和KMP理论层面无关，是实现时加入的一个设定，可以更改</p></li><li><p><strong>建立for循环构建next数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br></pre></td></tr></table></figure><p><strong>变量 i 表示的是后缀的最后一个字符</strong>，等于0时是不存在最长相等前后缀的，所以从1开始</p><p>在进入循环介绍前，我们要先知道，在整个构造前缀表的过程中，<strong>变量 j 是一直在来回移动的</strong>，因为每个 i 对应最长相等前后缀是不同的，而<strong>变量 i 则是一个一个遍历下去</strong>，每个 i 对应一个前缀表的数值</p></li><li><p><strong>处理前后缀不相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; </span><br><span class="line">    j = next[j]; <span class="comment">// 前后缀不相同了就向前回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用while循环的原因：i 增加1之后，有可能会导致最长相等前后缀长度直接减少2或更多，</p><p>为什么next[j]是回退：首先明确next数组的作用就是存储最长相等前后缀长度,再明确回退要保证next[i]之前的字符与回退后next[j]之前的是相同的，所以可以利用next数组来进行回退，而因为next数组第一个元素是-1所以可以直接用j作为索引。</p><blockquote><p><strong>注意</strong>：next[j]中直接访问 j 下标的元素是因为next的第一个元素默认为-1，这之后才是有效数值，这便是实现层面上的设定。</p></blockquote></li><li><p><strong>处理前后缀相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure><p><code>j++</code>使得 j 表示最长相等前后缀长度 而不是最后一个字符的索引位置</p><p>这样一来在下一个循环中s[ j ]就会再往后指向一个新的字符来和新的s[ i ]来比较，如果s[ i ]等于s[ j ]，那么就可以直接加上，因为这之前的字符已经在之前的循环中判断过了，如果不等于，就要往前回退到next[ j ]的位置。</p></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="kmp解题主要思路">KMP解题主要思路</h3><ol><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br></pre></td></tr></table></figure></li><li><p>建立for循环遍历haystack</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)</span><br></pre></td></tr></table></figure><p>注意：本题中通过next数组使得 j 不断回退，这样确保了haystack[i]和needle[j + 1]之前的字符已经是相等的，所以从头到尾只需要比较 haystack[i] 和 needle[j + 1] 这两个字符</p></li><li><p>处理不匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到了结束循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line"><span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">            j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">            j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="题目答案">题目答案</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]类模板中的友元函数</title>
      <link href="/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
      <url>/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引入">问题引入</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::<span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::~<span class="built_in">Dvector</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt; Dvector&lt;T&gt;::<span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="function">Dvector&lt;T&gt; <span class="title">result</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        result.data.<span class="built_in">push_back</span>(<span class="keyword">this</span>-&gt;data[i] + d1.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Dvector&lt;T&gt;::<span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        sum += <span class="keyword">this</span>-&gt;data[i] * d1.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">        os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="function">Dvector&lt;<span class="type">int</span>&gt; <span class="title">vecA</span><span class="params">(<span class="number">6</span>, a)</span>,<span class="title">vecB</span><span class="params">(<span class="number">6</span>, b)</span>,<span class="title">vecC</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    vecC = vecA + vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;vecC&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> iResult = vecA * vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;iResult&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在vscode上报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">warning: <span class="title">friend</span> <span class="title">declaration</span> &#x27;<span class="title">std</span>::<span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt;(<span class="title">std</span>::<span class="title">ostream</span>&amp;, <span class="title">linkStack</span>&lt;<span class="title">T</span>&gt;&amp;)&#x27; <span class="title">declares</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">template</span> <span class="title">function</span> [-<span class="title">Wnon</span>-<span class="title">template</span>-<span class="title">friend</span>]|</span></span><br></pre></td></tr></table></figure><h1 id="问题解读">问题解读</h1><h2 id="原因">原因</h2><p><strong>这段报错的意思是这里声明了一个非模板友元函数，编译器识别出来后警告(注意不是报错)</strong></p><p>为了解决这个警告，我们来补充模板类中的三种友元函数：</p><h2 id="非模板友元函数">非模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种友元函数仅仅只对应于一个特定类，<strong>不具有模板化的特性</strong>，因此不应该在模板类中这样定义一个友元函数。</p><h2 id="约束模板友元函数">约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//声明模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//声明类的友元函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Arrat&lt;T&gt; A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Array&lt;T&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>何为约束</strong>：<code>friend ostream&amp; operator &lt;&lt; &lt;&gt;(ostream&amp; os, const Array&lt;T&gt; A)&#123;</code>这行代码中的<code>&lt;&gt;</code>起到了提醒编译器这是一个模板实例化，参数类型与类模板中<strong>相同</strong>，不能接受不同类型的对象，所以是约束模板友元函数。</p><h2 id="非约束模板友元函数">非约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">//另外声明了一个模板</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="type">const</span> Array&lt;U&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过该模板友元函数定义的友元函数可以接受不同的类型，所以是非约束的。</p><hr><h1 id="解决方案">解决方案</h1><ol><li><p><strong>直接再模板类内部定义友元函数体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">       os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为约束模板友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为非约束友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]模板</title>
      <link href="/2024/05/27/c-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/05/27/c-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板">函数模板</h1><h2 id="函数模板与模板函数">函数模板与模板函数</h2><ul><li><p><strong>适用场景</strong>：对处理逻辑相同，只是参数类型不同的函数</p></li><li><p><strong>声明</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表);</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表);</p></li><li><p><strong>定义</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p></li><li><p><strong>示例</strong>：</p><p>定义一个返回数组最小值的函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">MinInArray</span><span class="params">(T* array, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    T min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优先级</strong>：</p><p>当函数模板和重载函数同时存在时，编译器会优先使用重载函数。</p></li></ul><h1 id="类模板">类模板</h1><ul><li><p><strong>声明和定义</strong>：</p><ul><li><p><strong>类的声明定义</strong>：</p><p>template &lt;typename 类型参数名1，…&gt;</p><p>class 类模板名</p><p>{</p><p>​… //类模板体</p><p>}；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyTemplateClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>类的成员函数</strong>：</p><p>template&lt;typename 类型参数名1，…&gt;</p><p>返回值类型  类模板名&lt;类型参数名&gt;::成员函数名（形参表）{</p><p>​…   //函数体</p><p>}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyTemplateClass&lt;T&gt;::<span class="built_in">display</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>用类模板产生模板类</strong>：</p><p>类模板名 &lt;类型1，…&gt;</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p><strong>类模板建立对象</strong>：</p><p>类模板名 &lt;类型参数名&gt; 对象1，对象2…</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTemplateClass&lt;<span class="type">int</span>&gt; obj1,obj2........</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]运算符重载</title>
      <link href="/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="第一操作数">第一操作数</h1><ul><li><strong>第一操作数</strong>：运算符左侧的操作数</li></ul><h1 id="成员运算符重载">成员运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数是当前类对象时</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (const  第二操作数的引用){</p><p>​//所进行的操作</p><p>​return …</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex <span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">        complex result;</span><br><span class="line">        result.real = real + c.real;</span><br><span class="line">        result.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> real;</span><br><span class="line">    <span class="type">int</span> imag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ul><h1 id="友元运算符重载">友元运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数不是当前类对象，但是要访问到类中的私有成员时</p></li><li><p><strong>实现方式</strong>：</p><p>friend  返回值类型  operator  运算符  (第一操作数的引用，第二操作数的引用){</p><p>​//操作</p><p>​return…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">    os&lt;&lt;c.real&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么返回值要设为ostream&amp; ：允许连续输出，例如cout&lt;&lt;c1&lt;&lt;c2&lt;&lt;c3&lt;&lt;endl</p></blockquote></li></ul><h1 id="非成员函数重载">非成员函数重载</h1><ul><li><p><strong>适用场景</strong>：既不需要访问类的私有成员，也不需要直接修改类的对象</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (常引用)  {</p><p>​…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-num.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]继承与多态</title>
      <link href="/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="公有继承和is-a关系">公有继承和is-a关系</h1><h2 id="继承和派生">继承和派生</h2><p><code>派生</code>：同一个类可以派生出多个子类，将这个类称为<strong>基类</strong>，派生出的子类称为<strong>派生类</strong>，同时把子类简介派生出的所有类统称为它的<strong>子孙类</strong>，把一个子类之前的所有类都统称为它的<strong>祖先类</strong></p><p><code>继承</code>：每个派生出的子类继承了基类的<strong>公有(public)属性</strong>和<strong>公有函数</strong>描述的功能</p><p><code>is-a关系</code>（公有继承）：指一个类是另一个类的一种特殊形式，通常用于描述继承关系。比如，狗是一种动物，所以狗类可以继承自动物类。在代码中通常体现为类的继承关系。</p><p>再复习一下<strong>has-a</strong>关系</p><p><code>has-a</code>（私有继承）：指一个类包含另一个类的对象作为其成员变量，通常用于描述组合关系。比如，汽车有一个引擎，所以汽车类可以包含一个引擎对象作为其成员变量。在代码中通常体现为类的成员变量。</p><hr><h1 id="派生类">派生类</h1><h2 id="派生类定义">派生类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类公有函数成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//派生类私有数据成员</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="派生类访问控制">派生类访问控制</h2><p><strong>可以访问</strong>：<strong>public</strong> ,<strong>protected</strong></p><p><strong>不可以访问</strong>：<strong>private</strong></p><p><strong>如何访问</strong>：</p><p>有基类<code>person</code> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有派生类<code>student</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问<code>student</code>的<code>name</code>和<code>age</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; student.name;</span><br><span class="line">cout &lt;&lt; student.age;</span><br></pre></td></tr></table></figure><h2 id="派生类定义样例">派生类定义样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is sleeping&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed) : <span class="built_in">Animal</span>(name), <span class="built_in">m_breed</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_breed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造与析构">派生类构造与析构</h2><blockquote><p><strong>注意</strong>：在调用派生类构造函数时如果不显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。如果基类没有默认构造函数，且派生类构造函数没有显式调用基类构造函数，则会导致编译错误。</p><blockquote><details class="toggle" ><summary class="toggle-button" style="">具体示例</summary><div class="toggle-content"><blockquote><p>在下面的示例中，基类Person没有默认构造函数，而派生类Student的构造函数没有显式调用基类构造函数，将会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> grade) : <span class="built_in">m_grade</span>(grade) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">myStudent</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，派生类Student的构造函数没有显式调用基类Person的构造函数，因为基类Person没有默认构造函数，编译器无法自动调用基类的构造函数，导致编译错误。为了避免这种情况，应该在派生类的构造函数中显式调用基类的构造函数，以确保正确地初始化基类的成员变量。</p><blockquote></blockquote></blockquote></div></details></blockquote></blockquote><p><strong>派生类构造函数示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPerson</span>(string name,<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)</span><br><span class="line">&#123;&#125;<span class="comment">//基类构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CStudent</span>(string name,<span class="type">int</span> age,<span class="type">int</span> number)</span><br><span class="line">:<span class="built_in">CPerson</span>(name,age),<span class="built_in">number</span>(number)</span><br><span class="line">&#123;&#125;<span class="comment">//派生类构造函数</span></span><br></pre></td></tr></table></figure><p><strong>构造函数和析构函数调用顺序</strong>：</p><p>基类 -&gt; 成员对象 -&gt; 派生类</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：ABC</p><hr><h1 id="同名覆盖原则">同名覆盖原则</h1><p>**定义：**如果派生类新增的数据成员或函数成员与基类同名，则基类中的同名成员会被覆盖，如果要访问基类中的同名函数，则需要添加基类名<code>::</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studZhang.Person::<span class="built_in">show</span>();  <span class="comment">//studZhang是一个CStudent类的对象，Person是它的基类</span></span><br></pre></td></tr></table></figure><h1 id="赋值兼容原则">赋值兼容原则</h1><p><strong>定义：</strong></p><ol><li><p><strong>基类指针</strong>可以指向<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p><strong>基类引用对象</strong>可以引用<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p>普通变量，函数传参，函数返回对象时将子孙类对象赋值给基类对象时，会存在切片现象。（变成基类对象）</p></li></ol><hr><h1 id="多态性与虚函数">多态性与虚函数</h1><h2 id="多态性">多态性</h2><p><code>静态多态性</code>：通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现（根据传参类型即可确定要调用的函数，<strong>在编译时完成（静态绑定）</strong>，所以是静态）</p><p><code>动态多态性</code>：通过<strong>虚函数</strong>实现（根据基类指针实际指向的对象类型来确定调用的函数，<strong>在运行时完成（动态绑定）</strong>） ，<strong>在基类指针/对象指向派生类指针/对象时最能体现</strong>。</p><h2 id="虚函数">虚函数</h2><ol><li><p>声明语法：</p><p>在基类中声明：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​在派生类中重写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>到底是干嘛的</p><p>比如同样是动物的叫，狗是bark，猫是meow，这个时候就有动态多态性的感觉了，就会使用虚函数。</p><p>动物是基类，狗和猫是派生类，叫就是一个虚函数。</p></li><li><p>使用时和普通函数的区别</p><p>前文提到了在基类指针/对象指向派生类指针/对象时最能体现动态多样性，这是因为在通过基类指针/对象访问派生类指针/对象的函数时，如果这个函数是虚函数，那么编译器就会在这个类的虚函数表中找到对应的虚函数来调用（这就是动态多样性），而如果是普通函数，那就会直接调用基类的这个函数。</p><p>例如：有一个基类指针<code>Person</code>指向派生类对象<code>Student</code>,基类和派生类中都有一个函数是<code>show()</code></p><ul><li>如果<code>show()</code>是虚函数：</li></ul><p><code>Person-&gt;show()</code>调用的是派生类<code>Student</code>的<code>show()</code></p><ul><li>如果不是：</li></ul><p><code>Person-&gt;show()</code>调用的就是基类<code>person</code>的<code>show()</code>函数</p><ul><li>如果基类没有这个函数：</li></ul><p>编译器会直接报错</p></li><li><p>底层逻辑</p></li></ol><p>对于使用虚函数的类，编译器会在其内部生成一个虚函数表，用来存储该类所有的虚函数，用基类指针或引用调用虚函数时，会从这个表中找到对应的虚函数并返回指针，从而实现动态绑定。</p><h2 id="纯虚函数和抽象类">纯虚函数和抽象类</h2><ol><li>声明语法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Funtion</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><code>抽象类</code>：包含纯虚函数的类</p><h2 id="派生类对象的克隆">派生类对象的克隆</h2><blockquote><p>用虚函数来克隆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* clonedBase = base-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* clonedDerived = derived-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedDerived-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">delete</span> clonedBase;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> clonedDerived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚基类">虚基类</h1><h2 id="菱形继承问题">菱形继承问题</h2><p><strong>在类的继承关系如下时发生</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure><p>在上面的继承结构中，类 <code>A</code> 是基类，类 <code>B</code> 和 <code>C</code> 都直接继承自 <code>A</code>，而类 <code>D</code> 继承自 <code>B</code> 和 <code>C</code>。由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在 <code>D</code> 中将会包含两份来自 <code>A</code> 的数据。这就是有菱形继承问题的原因。</p><p><strong>导致以下问题</strong>：</p><ol><li><p>内存浪费</p></li><li><p>二义性：</p><p>如果 <code>A</code> 类定义了一个成员函数 <code>foo()</code>，<code>B</code> 类和 <code>C</code> 类分别重写了这个函数，在 <code>D</code> 类中调用 <code>foo()</code> 函数，编译器就无法确定应该调用哪个版本的 <code>foo()</code> 函数，从而产生二义性。</p></li></ol><h2 id="用虚基类解决菱形继承问题">用虚基类解决菱形继承问题</h2><ul><li><p><strong>如何解决</strong>：</p><p>声明虚基类后，编译器会自动调用最终重写的版本。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling A&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling B&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling C&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        B::<span class="built_in">foo</span>(); <span class="comment">// 明确调用 B 类的 foo()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();  <span class="comment">// 在 D 类中调用 foo() 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">callFoo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling B<span class="number">&#x27;</span><span class="function">s <span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>如果没有声明虚基类，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference to &#x27;foo&#x27; is ambiguous</span><br></pre></td></tr></table></figure><p>如果没有最终的重写函数，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no unique final overrider <span class="keyword">for</span> &#x27;virtual void A::foo()&#x27; <span class="keyword">in</span> &#x27;D&#x27;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="补充">补充</h1><ul><li><p><strong>将构造函数定义为纯虚函数是没有意义的</strong></p><p>构造函数是用来创造对象的，而含有纯虚函数的类不能创造对象，所以无意义</p></li><li><p><strong>动态绑定只发生在，用基类指针或基类引用调用虚函数时，用派生类指针或引用调用虚函数时会直接确定要调用的虚函数，这是静态绑定</strong></p><p>例：有一个派生类对象a，a类中有虚函数b()，使用a.b()时不会发生动态绑定。</p></li><li><p><strong>派生类中虚函数必须和基类中完全一样（返回值，形参）</strong></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写点什么">写点什么</h1><p>想了很久我的第一篇博客应该写点什么，但是突然发现这好像违背了我创建博客的初心，在我看来博客应该想写什么就写什么，我希望把我的博客当作一个树洞，既可以记录我的生活，又可以倾诉我的情绪，在这里可以看到最真实的自己。</p><p>至于为什么到现在才搭建好我的博客，想到这个问题脑子里突然闪过好多理由，但里有终究是理由，根本还是我自己的原因，因此我想做出改变，我一定可以看到自己的改变。</p><h1 id="最近">最近</h1><h3 id="搭博客">搭博客</h3><p>首先奉上我跟的教程</p><p>​<a href="https://nickxu.me/tags/%E5%BB%BA%E7%AB%99%E6%8A%80%E5%B7%A7/">标签: 建站技巧 | NX の 博客 (nickxu.me)</a></p><p>​<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>搭博客的过程可谓曲折，捣鼓了5、6天却一直报出奇怪的错误，不过也让我对流程十分熟悉，以后有机会一定要写一篇搭博客的教程。</p><h3 id="期中考试-0512">期中考试(0512)</h3><p>上个礼拜都在复习昨天的期中考试，这个学期想努力一下，要拿到奖学金（因为感觉上学期不是很认真都差点成功了），但是昨天的大物让我一言难尽，感觉一拳打在棉花上的感觉，无法读懂出题老师的意图，而且考的知识点像高中物理，甚至出现了万有引力。至于高数感觉还是上学期挖的坑太大了，输在了微积分基础上。但是现在还没出成绩，也许等出了成绩之后会更破防。</p><h3 id="debug杯-0508">Debug杯(0508)</h3><p>第一次参加大学里的比赛，目标是为了混到德育分，但是没想到大部分的人和我的想法是一样的，以至于我最后甚至混到了一个三等奖，真是抽象。</p><h1 id="结语">结语</h1><p>忘记还想要写些什么了，下次再来补吧。最后送自己一句话：Think Less,Do More.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/06/hello-world/"/>
      <url>/2024/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
