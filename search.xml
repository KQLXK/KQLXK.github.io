<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[期末复习]数据库系统原理</title>
      <link href="/2024/12/29/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
      <url>/2024/12/29/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><h2 id="dbs-数据库系统">DBS（数据库系统）</h2><h3 id="组成要素">组成要素</h3><p>首先看一下总体构成</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412291655933.png" alt="image-20241229165515894"></p><ul><li><p><strong>硬件</strong>：大内存，大容量、直接存取的外存设备，作数据备份的磁带</p></li><li><p><strong>软件</strong>：OS，<strong>DBMS</strong>，高级语言编译系统及其与数据库的接口，应用开发工具，应用系统</p></li><li><p><strong>数据</strong>：目标数据（数据本身），描述数据（元数据，数据字典）；示例：数据：图书馆中的书，元数据：标题，作者，关键字</p></li><li><p><strong>用户</strong>：最终用户，应用程序员，系统分析员，<strong>数据库管理员(DBA)</strong></p></li></ul><h3 id="特点">特点</h3><ol><li>整体数据结构化：数据不属于任何应用，是公共的</li><li>数据共享性高：合法用户都可以使用数据</li><li>数据独立性高：数据与程序相互独立</li><li>高度的数据控制力：DBMS的管理</li></ol><h2 id="dbms-数据库管理系统">DBMS（数据库管理系统）</h2><h3 id="基本功能">基本功能</h3><ol><li>数据定义（DDL）：CREATE，ALTER，DROP</li><li>数据操纵（DML）：SELECT，INSERT，UPDATE，DELETE</li><li>完整性约束检查：NOT NULL，CHECK，CONSTRAINT</li><li>访问控制（DCL）：GRANT，REVOKE</li><li>并发控制</li><li>恢复功能</li></ol><h3 id="主要组成模块">主要组成模块</h3><ol><li>查询处理器</li><li>存储管理器</li><li>事务管理器</li></ol><h2 id="dba-数据库管理员">DBA（数据库管理员）</h2><p>职责：</p><ol><li>用户在数据库开发人员之间沟通</li><li>参与数据库设计工作</li><li>决定数据库完整性约束条件和不同用户权限</li><li>保证数据库正常运行</li><li>提出数据库的重构计划</li></ol><h2 id="db-数据库">DB（数据库）</h2><p><strong>定义</strong>：一个结构化的数据集合</p><h3 id="三级模式">三级模式</h3><p>数据库的三级模式包括模式，内模式，外模式，其目的是将用户应用和物理数据库分离，</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412291712257.png" alt="image-20241229171251899"></p><ol><li><p><strong>外模式（用户模式/子模式）</strong></p><p><strong>是模式的子集，直接与应用或用户交互的地方</strong>，比如，在一个在线购物网站上，用户看到的产品列表、购物车等就是外模式的表现，用户无需关心数据如何在后台存储和管理。</p><blockquote><p>一个数据库有多个外模式，反映了不同用户的不同需求</p></blockquote></li><li><p><strong>模式（概念模式/逻辑模式）</strong></p><p><strong>数据库中全体数据的逻辑结构和特征的描述</strong>，比如数据的类型、关系和约束等</p><p>回到前面的例子，关于产品、订单和客户等信息的分类、属性及他们之间的关系，都是在模式中定义的。</p><blockquote><p>外模式是模式的子集，一个数据库只有一个模式</p></blockquote></li><li><p><strong>内模式（存储模式）</strong></p><p><strong>数据物理结构和存储方式的描述</strong>，比如，数据如何在硬盘上分布（顺序存储，堆存储…）、索引方式（hash索引…）、数据压缩等都属于内模式的范畴</p><blockquote><p>一个数据库只有一个内模式</p></blockquote></li></ol><h3 id="两级独立性">两级独立性</h3><p>两级独立性指的是<strong>逻辑独立性</strong>和<strong>物理独立性</strong></p><p>三个模式间通过两级映射进行相互转换</p><ul><li><p><strong>外模式/模式映像</strong>：保证逻辑独立性</p><p>当模式改变时，数据库管理员修改有关的外模式/模式映象，使外模式保持不变</p></li><li><p><strong>模式/内模式映像</strong>：保证物理独立性</p><p>当数据库的存储结构改变了(例如选用了另一种存储结构)，数据库管理员修改模式/内模式映象，使模式保持不变</p></li></ul><h2 id="c-s和b-s">C/S和B/S</h2><ol><li><p><strong>C/S（客户端/服务器架构）</strong></p><p>C/S架构将应用程序分为两个主要部分：客户端和服务器。客户端是用户直接交互的部分，服务器则负责处理数据和业务逻辑。</p></li><li><p><strong>B/S（浏览器/服务器架构）</strong></p><p>由C/S发展而来，本质是三层结构的C/S模式，即在客户端和服务器之间增加了web服务中间层</p></li></ol><h2 id="数据模型">数据模型</h2><p><strong>三要素</strong>：1. 数据的数据结构；2. 数据操作集合；3. 数据的完整性集合</p><h2 id="关系模型">关系模型</h2><p>关系模型是一种数据模型，因此我们可以从数据模型三要素来理解关系模型</p><h3 id="三要素">三要素</h3><ul><li><p>数据结构</p><p>关系是关系模型中最基本的数据结构，而关系可以用二维表来形象地表示出来，所以可以把关系理解为表，关系模型就是有一张张表建立的</p></li><li><p>数据操作</p><p>结构化查询语言（SQL）可以为我们提供操作数据的功能</p></li><li><p>完整性约束</p><p>完整性约束再分为实体完整性，参照完整性，用户定义完整性</p><ul><li>实体完整性：任意候选码的值不能为空</li><li>参照完整性：外码在对应关系中存在或者取空值</li><li>用户定义完整性：用户自己根据实际需求定义的完整性约束</li></ul></li></ul><h3 id="主要术语">主要术语</h3><ul><li>关系(Relation)：一个关系可用一个二维表来表示，也被称为表</li><li>属性(Attribute)：关系中的每一列即为一个属性。</li><li>域(Domain)：一个属性的取值范围就是该属性的域。例如：姓名属性的域为10个字节字符串，出生日期属性域为日期型数据等。</li><li>元组(Tuple)：关系中的一行数据总称为一个元组。</li><li>分量(Component）：一个元组在一个属性上的值称为该元组在此属性上的分量。</li><li>候选码(Candidate Key)：一个关系中的某个属性（或属性组）的值能唯一标识关系中的各个元组，且又不含有多余的属性，则该属性(组)称为该关系的一个候选码，简称为码(Key)。</li><li>主码(Primary Key)：若一个关系中有多个候选码，则选取其中一个为主码。每个关系都有并且只有一个主码。</li><li>主属性（(Prime Atribute)：包含在任何一个候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性(Nonprime Attribute)或非码属性(on-key Attribute）。</li><li>外部码(Foreign Key)：若 A 是基本关系R的属性（组），但不是R1的码，且A与基本关系R的主码K相对应，则称A是R1的外部码，简称外码。R1和R2不一定是不同的关系。当然，A和K一定在同一组域上。</li><li>关系模式：一个关系的关系名及其全部属性名的集合简称为该关系的关系模式。一般表示为：<br>关系名（属性名1，属性名2，…，属性名n)如职工关系的关系模式为：职工（职工号，姓名，性别，出生日期，婚否，职称，部门)</li></ul><h1 id="关系数据库的操作">关系数据库的操作</h1><h2 id="sql语言">SQL语言</h2><h3 id="数据类型">数据类型</h3><p><code>INT</code>/<code>INTEGER</code>：全字长整型</p><p><code>SMALLINT</code>：半字长整型</p><p><code>DEMICAL(p,q)</code>/<code>DEM(p,q)</code>：精确数值型，共p位，小数点后有q位，0&lt;=q&lt;=p&lt;=15;q=0可省略</p><p><code>FLOAT</code>：双字长浮点数</p><p><code>CHAR(n)</code>/<code>CAHRATER(n)</code>：长度位n的定长字符串</p><p><code>VARCHAR(n)</code>：最大长度位n的变长字符串</p><p><code>DATETIME</code>：日期时间型，格式可设置</p><h3 id="ddl">DDL</h3><ul><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(</span><br><span class="line">[列表]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关键字：</p><p><code>NOT NULL</code>：不能为空</p><p><code>DEFAULT</code>：设置默认值</p><p><code>UNIQUE</code>：该列值不能相同</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">username <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    password VARVHAR(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>修改表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span><span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列的完整性约束]][<span class="keyword">ADD</span><span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span><span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>新的数据类型<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">COLUMN</span><span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]视图，触发器，存储过程</title>
      <link href="/2024/12/28/Mysql-%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/12/28/Mysql-%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">注意：本文中使用的数据表及结构如下</summary><div class="toggle-content"><p>Employee (Eno, Ename, Sex, Age, Is_Marry, Title, Dno)</p><p>Item (Ino, Iname, Start_Date, End_Date, Outlay, Check_Date)</p><p>Item_Emp (Ino, Eno, IENo)</p><p>Salary (Eno,  Basepay, Service, Price, Rest, Insure, Fund)</p><p>Department (Dno, Name, Phone, Manager)</p></div></details><h1 id="视图-views">视图(Views)</h1><h2 id="基本介绍">基本介绍</h2><p><strong>是什么</strong>：视图是一个虚表（有表的外形但是其中的数据是由SQL语句查询所得），用于更直观地把多张表中的相关数据合并到一起，方便查看</p><p>视图只需要保存查询的SQL逻辑，在每次使用试图时调用这个逻辑并将数据展现出来，不保存查询结果，所以在我们创建视图时，重点就在于这个查询语句</p><h2 id="基本语法">基本语法</h2><h3 id="创建">创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>列名清单<span class="operator">&gt;</span>] </span><br><span class="line"><span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>若有&lt;列名清单&gt;，则此清单给出了视图的所有属性的属性名，否则此时图的所有属性名就是子查询中SELECT语句的全部目标列</li><li>若有<WITH OPTION CHECK>，则对此时图进行INSERT，UPDATE，和DELETE操作时，系统会自动检查是否符合原定义视图子查询中的条件表达式</li><li>定义视图后，相应的子查询语句并未被执行，只有在调用时才会被执行</li></ul><p><strong>示例</strong>：</p><ul><li><p><strong>普通视图创建</strong>：建立二号部门的职工视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Employee_02</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Dno <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>WITH CHECK OPTION 子句</strong>：建立二号部门的职工视图，并要求在进行修改和插入操作时仍保证该视图只有“02”号部门的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Employee_02_2</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Employee </span><br><span class="line"> <span class="keyword">WHERE</span> Dno <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line"> <span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>因为带有WITH CHECK OPTION语句，则之后对视图进行插入修改删除操作时DBMS会自动加上Dno = '02’的条件</p></li><li><p><strong>视图中有派生属性</strong>：在工资表上定义某个员工的实发工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_salary(Eno, Ename, Act_Salary)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Eno, Ename, Basepay<span class="operator">+</span>Service<span class="operator">+</span>Price<span class="operator">+</span>Rest<span class="operator">-</span>Insure<span class="operator">-</span>Fund</span><br><span class="line"><span class="keyword">FROM</span> Salary, Employee</span><br><span class="line"><span class="keyword">WHERE</span> Employee.Eno <span class="operator">=</span> Salary.Eno;</span><br></pre></td></tr></table></figure><p>由于没有实发工资这一属性，所以必须设置别名</p></li><li><p><strong>视图上建立视图</strong>：建立职工实发工资大于2000的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_salary2</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> V_salary</span><br><span class="line">    <span class="keyword">WHERE</span> Act_Salary <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用了集函数和 GROUP BY</strong>：建立部门及部门员工平均工资的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Avg_Salary</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Dno, <span class="built_in">AVG</span>(Act_Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee, V_Salary</span><br><span class="line"><span class="keyword">WHERE</span> Employee.Eno <span class="operator">=</span> V_Salary.Eno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Dno;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除">删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>一个关系（基本表或视图）删除后，所有又该关系导出的视图并不会自动删除，他们仍在数据字典中但已无法使用</p><p><strong>示例</strong>：</p><ul><li><p>将Employee_02视图的定义删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> Employee_02</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询">查询</h3><ol><li>用户使用时：</li></ol><p>​用户使用时的查询和对基本表的查询没有区别</p><ol start="2"><li><p>DBMS对查询的处理：</p><p>（1）从数据字典中取出视图的定义</p><p>（2）将视图定义的子查询和SELECT查询结合，生成等价的对基本表的查询</p><p>（3）执行查询</p></li></ol><h3 id="更新">更新</h3><p>由于视图是一个虚表，在数据库中不存在真正的数据，所以视图的更新本质上是由DBMS自动转化成对基本表的更新。而语法也和基本的DDL相同</p><p><strong>示例</strong>：</p><ul><li><p>向“02”号部门职工视图Employee_02中插入一个新的职工“俞超”的相关记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee_02</span><br><span class="line"><span class="keyword">VALUES</span>(&quot;1036&quot;,&quot;俞超&quot;,&quot;男&quot;,<span class="number">25</span>,<span class="number">1</span>,&quot;工程师&quot;,&quot;02&quot;)</span><br></pre></td></tr></table></figure><p>会被DBMS转化为对基本表Employee的插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee</span><br><span class="line"><span class="keyword">VALUES</span>(&quot;1036&quot;,&quot;俞超&quot;,&quot;男&quot;,<span class="number">25</span>,<span class="number">1</span>,&quot;工程师&quot;,&quot;02&quot;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他">其他</h3><ul><li><p>定义视图时，<code>WITH OPTION CHECK </code>的作用</p><p>建立视图时其中的数据是由SELECT子句中的条件查询而来，但是INSERT，UPDATE，DELETE却不能保证符合这样的条件，所以需要<code>WITH OPTION CHECK</code></p><p><strong>示例</strong>：</p><p>向Employee_02_2中插入一个03部门的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee</span><br><span class="line"><span class="keyword">VALUES</span>(&quot;1036&quot;,&quot;俞超&quot;,&quot;男&quot;,<span class="number">25</span>,<span class="number">1</span>,&quot;工程师&quot;,&quot;03&quot;)</span><br></pre></td></tr></table></figure><p>其输出结果为对视图进行的插入或更新操作失败，原因是目标视图制定了<code>WITH OPTION CHECK</code></p></li></ul><h1 id="触发器">触发器</h1><h2 id="基本介绍">基本介绍</h2><p><strong>是什么</strong>：检测到触发事件后的一系列触发动作，这里的触发事件和触发动作都是对数据库的操作</p><p><strong>触发事件</strong>包括表中行的插入，删除和更新，即执行INSERT，DELETE，UPDATE语句。在定义触发器时，必须指定一个触发条件，也可以同时指定多个，在UPDATE中，还可以将特定属性或属性组的修改设置为触发条件</p><p>事件的触发还有三个相关的时间：BEFORE，AFTER，INSTEAD OF。分别表示事件发生前触发，事件发生后触发，替换事件的发生</p><p><strong>触发动作</strong>是一系列SQL语句，可以有以下两种方式：1.对被事件影响的每一行（元组）执行一次触发过程，称为行级触发器（FOR EACH ROW）。2.对整个事件只触发一次触发过程的语句级触发器（FOR EACH STATEMENT，默认方式）</p><h2 id="基本语法">基本语法</h2><h3 id="创建">创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--SQL server实现</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Del_Emp</span><br><span class="line"><span class="keyword">ON</span> Employee</span><br><span class="line">AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Emp_His</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INSERTED</span><br><span class="line"></span><br><span class="line"><span class="comment">--Mysql实现</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> &#123;BEFORE<span class="operator">|</span>AFTER<span class="operator">|</span>INSTEAD <span class="keyword">OF</span>&#125;</span><br><span class="line">&#123;[<span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span> <span class="keyword">OF</span> [列名清单]]&#125;</span><br><span class="line"><span class="keyword">ON</span> 表名</span><br><span class="line">[<span class="keyword">REFERENCING</span> <span class="operator">&lt;</span>临时视图名<span class="operator">&gt;=</span></span><br><span class="line">        [<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;=</span></span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="type">ROW</span><span class="operator">|</span>STATEMENT&#125;]</span><br><span class="line">        <span class="operator">&lt;</span>触发动作<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><p>REFERNCING &lt;临时视图名&gt;：指定临时视图的别名</p><p>在触发器运行过程中，系统会生成两个临时视图，分别存放被更新值(旧值)和更新后的值(新值)，一般情况下默认临时视图名是OLD和NEW，触发器运行结束后就不再存在</p></li></ul><p><strong>示例</strong>：</p><ul><li><p><strong>DELETE类型</strong>：设数据库中有一个 Emp_His数据表，其表结构与Employee相同，为Employee创建一套触发器，当删除职工时，将被删除职工的信息保存到Emp_His上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--SQL server实现</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_ins_Employee</span><br><span class="line"><span class="keyword">ON</span> Employee</span><br><span class="line">AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">DECALRE <span class="variable">@eno</span> <span class="type">CHAR</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@eno</span><span class="operator">=</span>Eno <span class="keyword">FROM</span> INSERTED</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Salary(Eno,  Basepay, Service, Price, Rest, Insure, Fund)</span><br><span class="line"><span class="keyword">VALUES</span>(eno,<span class="number">500</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--Mysql实现</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Del_Emp  </span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> Employee  </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Emp_His (column1, column2, ..., columnN) <span class="keyword">VALUES</span>  </span><br><span class="line">    (OLD.column1, OLD.column2, ..., OLD.columnN);  </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>INSERT类型</strong>：为Employee表创建一个触发器，要求当插入一个职工信息时，应该在工资表中生成该职工的工资记录，设置其基本工资为500，其他工资项为0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_ins_Employee  </span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Employee  </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Salary (Eno, Basepay, Service, Price, Rest, Insure, Fund)  </span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.Eno, <span class="number">500</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>UPDATE类型</strong>：为Employee创建一个触发器，当修改某个职工的职称时，同时修改Salary的基本工资，工程师增加150，高工增加300</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--SQL server实现</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_updatetitle_Employee</span><br><span class="line"><span class="keyword">ON</span> Employee</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line">IF <span class="keyword">UPDATE</span>(Title)</span><br><span class="line">IF(<span class="keyword">SELECT</span> Title <span class="keyword">FROM</span> INSERTED)<span class="operator">=</span>&quot;工程师&quot;</span><br><span class="line"><span class="keyword">UPDATE</span> Salary</span><br><span class="line"><span class="keyword">SET</span> Basepay<span class="operator">=</span>Basepay<span class="operator">+</span><span class="number">150</span></span><br><span class="line"><span class="keyword">WHERE</span> Eno <span class="operator">=</span> (<span class="keyword">SELECT</span> Eno <span class="keyword">FROM</span> INSERTED)</span><br><span class="line"><span class="keyword">ELSE</span> IF (<span class="keyword">SELECT</span> Title <span class="keyword">FROM</span> INSERTED)<span class="operator">=</span>&quot;高工&quot;</span><br><span class="line"><span class="keyword">UPDATE</span> Salary</span><br><span class="line"><span class="keyword">SET</span> BasePay<span class="operator">=</span>Basepay<span class="operator">+</span><span class="number">300</span></span><br><span class="line"><span class="keyword">WHERE</span> Eno <span class="operator">=</span> (<span class="keyword">SELECT</span> Eno <span class="keyword">FROM</span> INSERTED)</span><br><span class="line"></span><br><span class="line"><span class="comment">--Mysql实现</span></span><br><span class="line">DELIMITER </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_updatetitle_Employee  </span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Employee  </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    IF NEW.Title <span class="operator">=</span> <span class="string">&#x27;工程师&#x27;</span> <span class="keyword">THEN</span>  </span><br><span class="line">        <span class="keyword">UPDATE</span> Salary  </span><br><span class="line">        <span class="keyword">SET</span> Basepay <span class="operator">=</span> Basepay <span class="operator">+</span> <span class="number">150</span>  </span><br><span class="line">        <span class="keyword">WHERE</span> Eno <span class="operator">=</span> NEW.Eno;  </span><br><span class="line">    ELSEIF NEW.Title <span class="operator">=</span> <span class="string">&#x27;高工&#x27;</span> <span class="keyword">THEN</span>  </span><br><span class="line">        <span class="keyword">UPDATE</span> Salary  </span><br><span class="line">        <span class="keyword">SET</span> Basepay <span class="operator">=</span> Basepay <span class="operator">+</span> <span class="number">300</span>  </span><br><span class="line">        <span class="keyword">WHERE</span> Eno <span class="operator">=</span> NEW.Eno;  </span><br><span class="line">    <span class="keyword">END</span> IF;  </span><br><span class="line"><span class="keyword">END</span>;  </span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><code>DELIMITER</code>：在 MySQL 中，使用 DELIMITER 命令定义触发器的结束符，以便让 MySQL 识别触发器的结束位置。</p></li><li><p><strong>INSTEAD OF触发器（仅在SQL server中）</strong>：假设有一个用于查询每个部门的部门号和该部门职工人数的视图，则创建一个触发器，使得删除该视图中数据时也删除了该部门信息以及该部门的所有职工信息，并将删除的职工信息存入职工历史表Emp_His中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--以下是SQLserver的语法</span></span><br><span class="line"><span class="comment">--先创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_dnumber(Dno,Dnum)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Dno, <span class="built_in">COUNT</span>(Eno)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Dno</span><br><span class="line"><span class="comment">--创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Del_V_dnumber</span><br><span class="line"><span class="keyword">ON</span> V_dbumber</span><br><span class="line">INSTEAD <span class="keyword">OF</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Emp_His</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Dno<span class="operator">=</span>(<span class="keyword">SELECT</span> Dno <span class="keyword">FROM</span> DELETED)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Dno<span class="operator">=</span>(<span class="keyword">SELECT</span> Dno <span class="keyword">FROM</span> DELETED)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Department</span><br><span class="line"><span class="keyword">WHERE</span> Dno<span class="operator">=</span>(<span class="keyword">SELECT</span> Dno <span class="keyword">FROM</span> DELETED)</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--MySQL中的实现</span></span><br><span class="line"><span class="comment">-- 创建视图  </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_dnumber <span class="keyword">AS</span>  </span><br><span class="line">    <span class="keyword">SELECT</span> Dno, <span class="built_in">COUNT</span>(Eno) <span class="keyword">AS</span> Dnum  </span><br><span class="line">    <span class="keyword">FROM</span> Employee  </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Dno;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建触发器  </span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Tri_Del_V_dnumber  </span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> V_dnumber  </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="comment">-- 将即将删除的 Employee 数据插入到 Emp_His 表中  </span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Emp_His (Eno, Dno, <span class="comment">-- 其他字段根据需要)  </span></span><br><span class="line">    <span class="keyword">SELECT</span> Eno, Dno  <span class="comment">-- 请确保这里的字段与 Emp_His 表匹配  </span></span><br><span class="line">    <span class="keyword">FROM</span> Employee  </span><br><span class="line">    <span class="keyword">WHERE</span> Dno <span class="operator">=</span> OLD.Dno;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 删除相关的 Employee 数据  </span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Employee  </span><br><span class="line">    <span class="keyword">WHERE</span> Dno <span class="operator">=</span> OLD.Dno;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 删除相关的 Department 数据  </span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> Department  </span><br><span class="line">    <span class="keyword">WHERE</span> Dno <span class="operator">=</span> OLD.Dno;  </span><br><span class="line"><span class="keyword">END</span>;  </span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li></ul><h1 id="存储过程">存储过程</h1><h2 id="基本介绍">基本介绍</h2><p><strong>是什么</strong>：存储过程是事先编译好并存储在数据库中的一段SQL语句的集合</p><p><strong>特点</strong>：1.封装，复用。2.可以接受返回参数。3.减少服务器访问</p><p><strong>存储过程的执行步骤</strong>：1.接受输入参数并以输出参数的形式将多个值返回至调用过程或批处理；2.包含执行数据库操作；3.向调用过程或批处理返回状态，以表明成功或失败</p><h2 id="基本语法">基本语法</h2><h3 id="创建">创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="operator">&lt;</span>存储过程名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>参数列表<span class="operator">&gt;=</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="operator">&lt;</span>过程体<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>&lt;参数列表&gt;由一个或多个参数组成，也可以没有参数，每个参数的说明包括参数名和参数类型（例如：@example varchar(20)），在后面加上 <code>OUTPUT</code> 关键字表示为输出参数</li><li>&lt;过程体&gt; 是一系列SQL语句</li></ul><p><strong>示例</strong>：</p><ul><li><p><strong>无参存储过程</strong>：设计一个存储过程，能查询所有职工参加项目的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_EmpJoinItems_1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> e.Eno,Ename,Iname</span><br><span class="line"><span class="keyword">FROM</span> Employee e </span><br><span class="line"><span class="keyword">JOIN</span> Item_Emp ie <span class="keyword">ON</span> e.Eno <span class="operator">=</span> ie.Eno</span><br><span class="line"><span class="keyword">JOIN</span> Item i <span class="keyword">on</span> ie.Ino <span class="operator">=</span> i.ino</span><br></pre></td></tr></table></figure></li><li><p><strong>带输入参数存储过程</strong>：要求存储过程根据输入的职工姓名查询出参加过的所有项目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> prce_EmpJoinItem2 </span><br><span class="line"><span class="variable">@emp_name</span> <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> i.Ino, i.Iname </span><br><span class="line"><span class="keyword">FROM</span> Item i </span><br><span class="line"><span class="keyword">JOIN</span> Item_Emp ie <span class="keyword">ON</span> e.Eno <span class="operator">=</span> ie.Eno</span><br><span class="line"><span class="keyword">JOIN</span> Employee e <span class="keyword">ON</span> i.Eno <span class="operator">=</span> e.Eno</span><br><span class="line">    <span class="keyword">WHERE</span> e.Ename <span class="operator">=</span> <span class="variable">@emp_name</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>带输出参数的存储过程</strong>：根据职工姓名查询出该职工所参加的全部项目的总经费</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> prce_EmpJoinItemFee</span><br><span class="line"><span class="variable">@emp_name</span> <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable">@sum_outlay</span> DEMICAL(<span class="number">6</span>,<span class="number">2</span>)OUTPUT</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@sun_outlay</span><span class="operator">=</span><span class="built_in">SUM</span>(outlay)</span><br><span class="line"><span class="keyword">FROM</span> Item i </span><br><span class="line"><span class="keyword">JOIN</span> Item_Emp ie <span class="keyword">ON</span> e.Eno <span class="operator">=</span> ie.Eno</span><br><span class="line"><span class="keyword">JOIN</span> Employee e <span class="keyword">ON</span> i.Eno <span class="operator">=</span> e.Eno</span><br><span class="line"><span class="keyword">WHERE</span> e.Ename<span class="operator">=</span><span class="variable">@emp_name</span></span><br></pre></td></tr></table></figure></li><li><p><strong>带返回值的存储过程</strong>：首先判断该职工是否存在，若存在返回参加了几个项目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> prce_EmpExist</span><br><span class="line"><span class="variable">@emp_name</span> <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="comment">--定义变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@count</span> <span class="type">INT</span>, <span class="variable">@msg</span> <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@count</span><span class="operator">=</span><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Employee e</span><br><span class="line"><span class="keyword">WHERE</span> e.Ename<span class="operator">=</span><span class="variable">@emp_name</span></span><br><span class="line">IF(<span class="variable">@count</span><span class="operator">=</span><span class="number">0</span>)</span><br><span class="line"><span class="keyword">RETURN</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@count</span><span class="operator">=</span><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Employee e, Item_Emp ie</span><br><span class="line"><span class="keyword">WHERE</span> ie.Eno<span class="operator">=</span>e.Eno <span class="keyword">AND</span> e.Ename<span class="operator">=</span><span class="variable">@emp_name</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="variable">@count</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="执行">执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="operator">&lt;</span>存储过程名<span class="operator">&gt;</span> [参数列表]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>参数传递有两种方式，可以按”参数=值“传递，也可以按顺序传递</li></ul><p><strong>示例</strong>：</p><ul><li><p><strong>带有输入参数</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> prce_EmpJoinItem2 <span class="variable">@emp_name</span><span class="operator">=</span><span class="string">&#x27;张小华&#x27;</span></span><br><span class="line"><span class="keyword">EXECUTE</span> prce_EmpJoinItem2 <span class="string">&#x27;张小华&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>有输出参数</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@outlay</span> <span class="type">DECIMAL</span>(<span class="number">6</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">EXECUTE</span> prce_EmpJoinItemFee <span class="variable">@emp_name</span><span class="operator">=</span><span class="string">&#x27;张小华,@outlay OUTPUT</span></span><br></pre></td></tr></table></figure></li><li><p><strong>返回值</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@revlaue</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="variable">@revlaue</span><span class="operator">=</span>prce_EmpExist <span class="variable">@emp_name</span><span class="operator">=</span><span class="string">&#x27;张小华</span></span><br><span class="line"><span class="string">IF @revlaue=0</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">ELSE</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[git]常见问题</title>
      <link href="/2024/12/04/git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/04/git-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="unable-to-access">unable to access …</h1><h2 id="问题">问题</h2><p>当我们使用git命令时，出现如图的报错</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412041427501.png" alt="image-20241204142732470"></p><p>报错显示：连接github的443端口超时</p><h2 id="错误原因">错误原因</h2><p>系统端口号与git端口号不一致</p><h2 id="解决方案">解决方案</h2><ul><li><p>未使用vpn时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></li><li><p>使用了vpn</p><p>第一步：现在 系统设置-网络和internet-代理 中找到vpn使用的端口，如图</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412041430960.png" alt="image-20241204143055901"></p><p>第二步：在git中设置本地代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:&lt;你的端口号&gt;</span><br><span class="line">git config --global https.proxy 127.0.0.1:&lt;你的端口号&gt;</span><br></pre></td></tr></table></figure><p>我的端口号是15715，则应输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:15715</span><br><span class="line">git config --global https.proxy 127.0.0.1:15715</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L12-走进消息队列</title>
      <link href="/2024/11/30/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L12-%E8%B5%B0%E8%BF%9B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2024/11/30/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L12-%E8%B5%B0%E8%BF%9B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="引子">引子</h1><h2 id="四个案例">四个案例</h2><p><a href="https://image.nickxu.me/202205312057193.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559665.png" alt="image-20220531205709120"></a></p><p><a href="https://image.nickxu.me/202205312057399.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559219.png" alt="image-20220531205729335"></a></p><p><a href="https://image.nickxu.me/202205312058600.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559532.png" alt="image-20220531205805499"></a></p><p><a href="https://image.nickxu.me/202205312058270.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559411.png" alt="image-20220531205819201"></a></p><p><a href="https://image.nickxu.me/202205312058129.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559806.png" alt="image-20220531205849066"></a></p><p><a href="https://image.nickxu.me/202205312058013.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559110.png" alt="image-20220531205857947"></a></p><p><a href="https://image.nickxu.me/202205312059668.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559266.png" alt="image-20220531205931609"></a></p><p><a href="https://image.nickxu.me/202205312059902.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559311.png" alt="image-20220531205937836"></a></p><p>本地日志丢掉了，怎么办？</p><p><a href="https://image.nickxu.me/202205312100131.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559598.png" alt="image-20220531210004058"></a></p><h2 id="解决方案">解决方案</h2><p><a href="https://image.nickxu.me/202205312100562.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559661.png" alt="image-20220531210054490"></a></p><p><a href="https://image.nickxu.me/202205312101607.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559703.png" alt="image-20220531210126547"></a></p><p><a href="https://image.nickxu.me/202205312101526.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559232.png" alt="image-20220531210156465"></a></p><p><a href="https://image.nickxu.me/202205312103088.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559370.png" alt="image-20220531210303031"></a></p><p><a href="https://image.nickxu.me/202205312103796.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559591.png" alt="image-20220531210335730"></a></p><h1 id="前世今生">前世今生</h1><h2 id="发展历程">发展历程</h2><p><a href="https://image.nickxu.me/202205312104382.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559693.png" alt="image-20220531210434316"></a></p><h2 id="业界对比">业界对比</h2><p><a href="https://image.nickxu.me/202205312111940.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559816.png" alt="image-20220531211121850"></a></p><h1 id="消息队列-kafka">消息队列-Kafka</h1><h2 id="使用场景">使用场景</h2><p><a href="https://image.nickxu.me/202205311915918.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559308.png" alt="image-20220531191521763"></a></p><h2 id="如何使用-kafka">如何使用 Kafka</h2><p><a href="https://image.nickxu.me/202205311916021.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559121.png" alt="image-20220531191607884"></a></p><h2 id="基本概念">基本概念</h2><p><a href="https://image.nickxu.me/202205311916553.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559583.png" alt="image-20220531191643396"></a></p><h3 id="offset">Offset</h3><p><a href="https://image.nickxu.me/202205311917542.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559422.png" alt="image-20220531191740421"></a></p><p>每个消息都有编号</p><h3 id="replica">Replica</h3><p><a href="https://image.nickxu.me/202205311918154.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559600.png" alt="image-20220531191804042"></a></p><p>复制多份副本，如果 Leader 所在的机器挂了，就在 ISR 中的副本重新选一个 Leader</p><h2 id="数据复制">数据复制</h2><p><a href="https://image.nickxu.me/202205311919733.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559853.png" alt="image-20220531191919615"></a></p><p>由 Controller 分配复制</p><h2 id="kafka-架构">Kafka 架构</h2><p><a href="https://image.nickxu.me/202205311920337.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559037.png" alt="image-20220531192008229"></a></p><h2 id="一条消息的自述">一条消息的自述</h2><p><a href="https://image.nickxu.me/202205311920165.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559316.png" alt="image-20220531192027072"></a></p><h2 id="思考">思考</h2><p><a href="https://image.nickxu.me/202205311920544.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559454.png" alt="image-20220531192046420"></a></p><p>不能一个一个发，应该要一起发送</p><h2 id="producer">Producer</h2><h3 id="批量发送">批量发送</h3><p><a href="https://image.nickxu.me/202205311921540.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559896.png" alt="image-20220531192119423"></a></p><h3 id="数据压缩">数据压缩</h3><p><a href="https://image.nickxu.me/202205311921359.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559662.png" alt="image-20220531192144266"></a></p><p>最好的是 ZSTD</p><h2 id="broker">Broker</h2><h3 id="数据的存储">数据的存储</h3><p><a href="https://image.nickxu.me/202205311923189.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559840.png" alt="image-20220531192302105"></a></p><h3 id="消息文件结构">消息文件结构</h3><p><a href="https://image.nickxu.me/202205311923640.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559159.png" alt="image-20220531192315548"></a></p><h3 id="磁盘结构">磁盘结构</h3><p><a href="https://image.nickxu.me/202205311924170.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559636.png" alt="image-20220531192438022"></a></p><h3 id="顺序写">顺序写</h3><p><a href="https://image.nickxu.me/202205311925375.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559378.png" alt="image-20220531192520280"></a></p><h3 id="如何找到消息">如何找到消息</h3><p><a href="https://image.nickxu.me/202205311925891.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559541.png" alt="image-20220531192557784"></a></p><h3 id="偏移量索引文件">偏移量索引文件</h3><p><a href="https://image.nickxu.me/202205311926340.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559865.png" alt="image-20220531192627242"></a></p><p><a href="https://image.nickxu.me/202205311926423.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559925.png" alt="image-20220531192642328"></a></p><h3 id="时间戳索引文件">时间戳索引文件</h3><p><a href="https://image.nickxu.me/202205311927645.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559564.png" alt="image-20220531192735513"></a></p><h3 id="传统数据拷贝">传统数据拷贝</h3><p><a href="https://image.nickxu.me/202205311927473.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559325.png" alt="image-20220531192757345"></a></p><h3 id="零拷贝">零拷贝</h3><p><a href="https://image.nickxu.me/202205311928163.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559576.png" alt="image-20220531192838069"></a></p><h2 id="consumer">Consumer</h2><h3 id="消息的接收端">消息的接收端</h3><p><a href="https://image.nickxu.me/202205311930593.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559947.png" alt="image-20220531193034477"></a></p><h3 id="low-level-手动分配">Low Level 手动分配</h3><p><a href="https://image.nickxu.me/202205311931704.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559803.png" alt="image-20220531193112562"></a></p><p>优点：方便快捷</p><p>问题：</p><ol><li>如果某个 Consumer 挂掉了，那它负责的那些 Partition 直接阻塞</li><li>如果某个 Consumer 能力不够，想其他 Consumer 来接替，必会出现机器的启停</li></ol><h3 id="high-level-自动分配">High Level 自动分配</h3><p><a href="https://image.nickxu.me/202205311932621.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559813.png" alt="image-20220531193210526"></a></p><h2 id="consumer-rebalance">Consumer Rebalance</h2><p><a href="https://image.nickxu.me/202205311933066.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559478.png" alt="image-20220531193342965"></a></p><p>（这个流程有点复杂，可以去查找更多资料学习）</p><p><a href="https://image.nickxu.me/202205311939127.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559564.png" alt="image-20220531193958034"></a></p><hr><p>下面是一些缺点</p><h2 id="数据复制问题">数据复制问题</h2><p><a href="https://image.nickxu.me/202205311941215.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559623.png" alt="image-20220531194102108"></a></p><h2 id="重启操作">重启操作</h2><p><a href="https://image.nickxu.me/202205311941163.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559058.png" alt="image-20220531194124057"></a></p><p>（重启一个节点要很久，重启所有节点要数天甚是数周）</p><p>不能并发重启，可能一个片放在两个机器上</p><h2 id="替换-扩容-缩容">替换、扩容、缩容</h2><p><a href="https://image.nickxu.me/202205311943483.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559976.png" alt="image-20220531194313382"></a></p><p>（只要有节点的变动，就有复制的成本）</p><h2 id="负载不均衡">负载不均衡</h2><p><a href="https://image.nickxu.me/202205311943436.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559941.png" alt="image-20220531194352353"></a></p><p><a href="https://image.nickxu.me/202205311944899.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559392.png" alt="image-20220531194401807"></a></p><p>（想解决 IO 问题，引入了新的 IO 问题）</p><h2 id="问题总结">问题总结</h2><p><a href="https://image.nickxu.me/202205311944230.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559422.png" alt="image-20220531194442112"></a></p><h1 id="消息队列-bmq">消息队列-BMQ</h1><h3 id="bmq-简介">BMQ 简介</h3><p><a href="https://image.nickxu.me/202205312051280.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559502.png" alt="image-20220531205159212"></a></p><p><a href="https://image.nickxu.me/202205312052562.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559962.png" alt="image-20220531205206499"></a></p><p>读写分离</p><h2 id="运维操作对比">运维操作对比</h2><p><a href="https://image.nickxu.me/202205312054447.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559246.png" alt="image-20220531205428375"></a></p><h2 id="hdfs-写文件流程">HDFS 写文件流程</h2><p><a href="https://image.nickxu.me/202205312055642.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559170.png" alt="image-20220531205503584"></a></p><h2 id="bmq-文件结构">BMQ 文件结构</h2><p><a href="https://image.nickxu.me/202205312056517.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559474.png" alt="image-20220531205621450"></a></p><p>同一个节点会打散到很多机器当中</p><h2 id="broker">Broker</h2><h3 id="partition-状态机">Partition 状态机</h3><p><a href="https://image.nickxu.me/202205312220785.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559698.png" alt="image-20220531222013714"></a></p><p>（听得有点迷）</p><h3 id="写文件流程">写文件流程</h3><p><a href="https://image.nickxu.me/202205312223252.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559426.png" alt="image-20220531222344184"></a></p><p>（有点迷）</p><h3 id="写文件-failover">写文件 Failover</h3><p><a href="https://image.nickxu.me/202205312229448.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559967.png" alt="image-20220531222922382"></a></p><h2 id="proxy">Proxy</h2><p><a href="https://image.nickxu.me/202205312230572.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559184.png" alt="image-20220531223012504"></a></p><h2 id="多机房部署">多机房部署</h2><p><a href="https://image.nickxu.me/202205312233186.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559360.png" alt="image-20220531223305121"></a></p><h2 id="bmq-的高级特性">BMQ 的高级特性</h2><p><a href="https://image.nickxu.me/202205312250600.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559348.png" alt="image-20220531224959648"></a></p><h3 id="泳道消息">泳道消息</h3><p><a href="https://image.nickxu.me/202205312251914.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559546.png" alt="image-20220531225108853"></a></p><p><a href="https://image.nickxu.me/202205312251434.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559676.png" alt="image-20220531225150367"></a></p><p><a href="https://image.nickxu.me/202205312252701.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559020.png" alt="image-20220531225221626"></a></p><p><a href="https://image.nickxu.me/202205312253815.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559198.png" alt="image-20220531225308731"></a></p><p><a href="https://image.nickxu.me/202205312254561.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559261.png" alt="image-20220531225418485"></a></p><h3 id="databus">Databus</h3><p><a href="https://image.nickxu.me/202205312256709.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559107.png" alt="image-20220531225604630"></a></p><p><a href="https://image.nickxu.me/202205312257996.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559578.png" alt="image-20220531225710931"></a></p><h3 id="mirror">Mirror</h3><p><a href="https://image.nickxu.me/202205312258253.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559757.png" alt="image-20220531225803184"></a></p><p><a href="https://image.nickxu.me/202205312258478.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559155.png" alt="image-20220531225857412"></a></p><h3 id="index">Index</h3><p><a href="https://image.nickxu.me/202205312259891.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559172.png" alt="image-20220531225945829"></a></p><p><a href="https://image.nickxu.me/202205312300852.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559488.png" alt="image-20220531230010786"></a></p><h3 id="parquet">Parquet</h3><p><a href="https://image.nickxu.me/202205312301268.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559640.png" alt="image-20220531230108198"></a></p><p><a href="https://image.nickxu.me/202205312301809.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559904.png" alt="image-20220531230146740"></a></p><p><a href="https://image.nickxu.me/202205312302985.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559172.png" alt="image-20220531230240919"></a></p><p><a href="https://image.nickxu.me/202205312302120.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559474.png" alt="image-20220531230248046"></a></p><h1 id="消息队列-rocketmq">消息队列- RocketMQ</h1><p><a href="https://image.nickxu.me/202205312303257.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559067.png" alt="image-20220531230318188"></a></p><h2 id="rocketmq-基本概念">RocketMQ 基本概念</h2><p><a href="https://image.nickxu.me/202205312303559.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559796.png" alt="image-20220531230342484"></a></p><p><a href="https://image.nickxu.me/202205312304850.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559531.png" alt="image-20220531230453785"></a></p><h2 id="rocketmq-架构">RocketMQ 架构</h2><p><a href="https://image.nickxu.me/202205312305001.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559046.png" alt="image-20220531230510936"></a></p><h2 id="存储模型">存储模型</h2><p><a href="https://image.nickxu.me/202205312305634.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559071.png" alt="image-20220531230555571"></a></p><h2 id="高级特性">高级特性</h2><h3 id="事务场景">事务场景</h3><p><a href="https://image.nickxu.me/202205312306265.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559225.png" alt="image-20220531230647201"></a></p><p><a href="https://image.nickxu.me/202205312307420.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559452.png" alt="image-20220531230731353"></a></p><h3 id="延迟发送">延迟发送</h3><p><a href="https://image.nickxu.me/202205312308148.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559503.png" alt="image-20220531230843088"></a></p><p><a href="https://image.nickxu.me/202205312309476.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559796.png" alt="image-20220531230926414"></a></p><h3 id="重试和死信队列">重试和死信队列</h3><p><a href="https://image.nickxu.me/202205312310428.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559954.png" alt="image-20220531231016360"></a></p><p>（右下角的内容错了，应该是死信队列）</p><p><a href="https://image.nickxu.me/202205312311464.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559354.png" alt="image-20220531231113397"></a></p><p><a href="https://image.nickxu.me/202205312311344.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301559202.png" alt="image-20220531231125281"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[docker]入门</title>
      <link href="/2024/11/26/docker-%E5%85%A5%E9%97%A8/"/>
      <url>/2024/11/26/docker-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker概述">docker概述</h1><h2 id="docker是什么">docker是什么</h2><p>docker是一个工具，用来帮助开发者打包，分发，运行应用程序</p><h2 id="镜像和容器">镜像和容器</h2><p>当我们利用Docker安装应用时，docker会自动搜索并下载应用 <strong>镜像（image）</strong>。镜像不仅包含应用本身，还包含应用运行所需要的环境，配置，系统函数库。docker会在运行镜像时创建一个隔离环境，称为 <strong>容器(container)</strong></p><p><strong>镜像仓库</strong>：存储和管理镜像的平台，docker就是从这里下载的镜像，docker官方维护了一个公共仓库：<a href="https://hub.docker.com/">Docker Hub</a></p><h1 id="安装docker">安装docker</h1><ol><li>对于windows家庭版，安装docker前需要先安装<a href="https://learn.microsoft.com/zh-cn/windows/wsl/">wsl</a></li><li>下载<a href="https://docs.docker.com/docker-for-windows/wsl/#download">Docker Desktop</a>，并安装</li><li>打开 docker-settings-general，在“use the wsl2 based engine”处打勾</li><li>打开 docker-settings-resources，选择在wsl中安装的linux发行版</li><li>通过使用 <code>docker run hello-world</code> 运行简单的内置Docker映像，测试安装是否正常工作</li></ol><h1 id="docker底层原理">docker底层原理</h1><h2 id="docker是怎么工作的">docker是怎么工作的</h2><p>Docker 是一个 Client·Server 结构的系统，Docker的守护进程运行在主机上。 通过Socket从客户端访问!</p><p>DockerServer接收到 Docker-Client的指令，就会执行这个命令!</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411261611990.png" alt="image-20241126161127888"></p><h1 id="快速入门">快速入门</h1><h2 id="helloworld流程">helloworld流程</h2><p>这部分内容旨在了解理清运行 <code>docker run hello-world</code> 后发生了什么</p><p>运行后的结果如图</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411261554326.png" alt="image-20241126155409213"></p><p>这是发生的流程</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411261603258.png" alt="image-20241126160314132"></p><h2 id="部署mysql">部署MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">    mysql</span><br></pre></td></tr></table></figure><p>运行以上命令后，就可以用数据库连接工具连接上了</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411261910578.png" alt="image-20241126191055455" style="zoom:67%;" /><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411261909464.png" alt="image-20241126190958239" style="zoom: 67%;" /><p><strong>命令解读</strong>：</p><ul><li>docker run：创建并运行一个容器，-d是让容器后台运行</li><li>–name mysql：为容器起一个名字</li><li>-p 3307:3306：端口映射，宿主机端口/容器内端口</li><li>-e KEY=VALUE：设置环境变量</li><li>mysql：指定运行的镜像名，一般由两部分，[repository]:[tag]，tag是镜像的版本，不写默认为latest</li></ul><h1 id="docker命令">docker命令</h1><h2 id="常见命令">常见命令</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412111849328.png" alt=""></p><ol><li><p><strong>查看 Docker 版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version  </span><br></pre></td></tr></table></figure></li><li><p><strong>拉取镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;image_name&gt;  </span><br></pre></td></tr></table></figure><p>例如：<code>docker pull ubuntu</code></p></li><li><p><strong>列出所有镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images  </span><br></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;image_name_or_id&gt;  </span><br></pre></td></tr></table></figure></li><li><p><strong>创建并运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;options&gt; &lt;image_name&gt;  </span><br></pre></td></tr></table></figure><p>例如：<code>docker run -d -p 80:80 nginx</code></p></li><li><p><strong>停止容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container_id_or_name&gt;  </span><br></pre></td></tr></table></figure></li><li><p><strong>启动已停止的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;container_id_or_name&gt;  </span><br></pre></td></tr></table></figure></li><li><p><strong>重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;container_id_or_name&gt;  </span><br></pre></td></tr></table></figure></li><li><p><strong>列出正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps  </span><br></pre></td></tr></table></figure></li><li><p><strong>列出所有容器（包括停止的）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a  </span><br></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;container_id_or_name&gt;  </span><br></pre></td></tr></table></figure></li></ol><h2 id="镜像命令">镜像命令</h2><ol><li><p><strong>列出所有镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@YC0417:~# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   19 months ago   13.3kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID镜像的id</span><br><span class="line">CREATED镜像的创建时间</span><br><span class="line">SIZE镜像的大小</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">-a, --all# 列出所有镜像</span><br><span class="line">-q, --quiet# 只显示镜像的id</span><br></pre></td></tr></table></figure></li><li><p><strong>搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@YC0417:~# docker search mysql</span><br><span class="line">NAME                   DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">mysql                  MySQL is a widely used, open-source relation…   15516     [OK]</span><br><span class="line">bitnami/mysql          Bitnami container image for MySQL               120</span><br><span class="line">circleci/mysql         MySQL is a widely used, open-source relation…   30</span><br><span class="line">cimg/mysql                                                             3</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他命令">其他命令</h2><ol><li><p><strong>查看容器运行日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名&gt;</span><br></pre></td></tr></table></figure><p><strong>可选项：</strong></p><p><code>-f</code>：持续查看日志</p></li><li><p><strong>进入容器内部</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名&gt; bash</span><br></pre></td></tr></table></figure><p><code>bash</code>：使用bash命令行，也可使用其他</p></li><li><p><strong>查看容器详情</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器名&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="容器数据卷">容器数据卷</h1><h2 id="什么是数据卷">什么是数据卷</h2><p>数据卷是一个虚拟的目录，最终起到的作用就是把容器内的目录和宿主机的目录映射起来，方便我们操作容器内文件，以及获得容器活动所产生的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202412112125142.png" alt="image-20241211212525037"></p><h2 id="为什么需要数据卷">为什么需要数据卷</h2><p>使用容器时，数据会存储在容器内部，如果容器删除，数据就会丢失，同时使用者编辑查询相应的文件操作也会繁琐，为了使数据持久化，同时便于操作和共享，所以需要数据卷</p><ul><li><strong>数据卷的特点及用途</strong>：<ol><li><strong>持久化存储</strong>：在容器被删除后持续存在，不会丢失</li><li><strong>荣期间共享数据</strong>：多个容器共用一个数据卷</li><li><strong>便于备份和恢复</strong>：更方便的备份和回复</li><li><strong>提高性能</strong>：相比于容器内部的文件操作，数据卷可以提高性能</li></ol></li></ul><h2 id="数据卷命令">数据卷命令</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">docker volumn create</td><td style="text-align:center">创建数据卷</td></tr><tr><td style="text-align:center">docker volumn ls</td><td style="text-align:center">查看所有数据卷</td></tr><tr><td style="text-align:center">docker volumn rm</td><td style="text-align:center">删除指定数据卷</td></tr><tr><td style="text-align:center">docker volumn inspect</td><td style="text-align:center">查看某个数据卷的详情</td></tr><tr><td style="text-align:center">docker volumn prune</td><td style="text-align:center">清除数据卷</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L11-TOS对象存储实战</title>
      <link href="/2024/11/25/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L11-TOS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2024/11/25/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L11-TOS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="抖音背后的存储">抖音背后的存储</h1><h2 id="存储需求">存储需求</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411252148766.png" alt="image-20241125214805560"></p><p>经计算，小明发现需要的存储量很大</p><p>因此需要寻找合适存储</p><p>要求：易用，海量，便宜</p><h1 id="为什么需要对象存储呢">为什么需要对象存储呢?</h1><h2 id="存储系统的分类">存储系统的分类</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411252156904.png" alt="image-20241125215614835"></p><h2 id="对比各类存储">对比各类存储</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411252157814.png" alt="image-20241125215740737"></p><h2 id="分布式存储选型">分布式存储选型</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411252200140.png" alt="image-20241125220023065"></p><h2 id="易用性：接口对比">易用性：接口对比</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301538519.png" alt="image-20241130153814337"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301540315.png" alt="image-20241130154030203"></p><h2 id="适用场景">适用场景</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301541213.png" alt="image-20220605101915455"></p><h1 id="对象存储怎么用">对象存储怎么用</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301542811.png" alt="image-20220605101947519"></p><h2 id="申请bucket">申请bucket</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301542712.png" alt="image-20220605102146263"></p><h2 id="restful接口">Restful接口</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301542486.png" alt="image-20220605102302103"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301542244.png" alt="image-20220605102444063"></p><h2 id="multiupload">MultiUpload</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301543391.png" alt="image-20220605102631210"></p><h2 id="listprefix接口">Listprefix接口</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301543386.png" alt="image-20220605102759746"></p><h1 id="tos字节内部实践">TOS字节内部实践</h1><p>（这是讲师18年来到字节后积累的经验）</p><h2 id="开发一个对象存储">开发一个对象存储</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544772.png" alt="image-20220605103001784"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544191.png" alt="image-20220605103132211"></p><h2 id="可扩展性之-partition">可扩展性之 Partition</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544264.png" alt="image-20220605103348032"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544231.png" alt="image-20220605103417975"></p><h2 id="持久度之-replication">持久度之 Replication</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544289.png" alt="image-20220605103621456"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544207.png" alt="image-20220605103727202"></p><h2 id="成本之-ec">成本之 EC</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544578.png" alt="image-20220605103852598"></p><p>（任何一块坏了，可以从其他块推导出这一块的内容）</p><h2 id="成本之温热转换">成本之温热转换</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544418.png" alt="image-20220605104031936"></p><h2 id="架构细化">架构细化</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544017.png" alt="image-20220605104058824"></p><h2 id="存储需求量细化">存储需求量细化</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544455.png" alt="image-20220605104222802"></p><h2 id="高可用之拆分">高可用之拆分</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544592.png" alt="image-20220605104329597"></p><h2 id="高可用之粤核酸的启发">高可用之粤核酸的启发</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544036.png" alt="image-20220605104416125"></p><h2 id="高可用之镜像灾备">高可用之镜像灾备</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544510.png" alt="image-20220605104455961"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544669.png" alt="image-20220605104515372">](<a href="https://image.nickxu.me/202206051045460.png">https://image.nickxu.me/202206051045460.png</a>)</p><h2 id="未来展望">未来展望</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544680.png" alt="image-20220605104535427"></p><h1 id="课后总结">课后总结</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301544820.png" alt="image-20220605104704842"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411301557409.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[redis]入门</title>
      <link href="/2024/11/25/redis-%E5%85%A5%E9%97%A8/"/>
      <url>/2024/11/25/redis-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="redis简介">Redis简介</h1><p>Redis是一个高性能的非关系型数据库，将数据存在内存中，实现了高性能的读写</p><h2 id="特点">特点</h2><ol><li>支持数据持久化</li><li>提供多种数据结构的存储，如list，set，zset，hash</li><li>支持数据备份</li></ol><h2 id="优势">优势</h2><ol><li>性能极高（主要）</li><li>丰富的数据类型</li><li>原子性</li><li>丰富的特性</li></ol><h2 id="与其他key-value存储的不同">与其他key-value存储的不同</h2><ol><li><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作</p></li><li><p>Redis是一个内存数据库，将数据存储在内存中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L10-Redis</title>
      <link href="/2024/11/23/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L10-Redis/"/>
      <url>/2024/11/23/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L10-Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是redis">什么是Redis</h1><h2 id="为什么需要redis">为什么需要Redis</h2><p>随着数据量的增加，从一台mysql演化到了集群，但是在一些很复杂的技术场景里，mysql还是无法支持，由于mysql要从磁盘中读取数据，为了让数据查询更快，可以把数据存到内存里，redis应运而生</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231558597.png" alt="image-20241123155842419" style="zoom:80%;" /><p>读取时先从redis中读，如果没有再去mysql读，然后再回写到redis中</p><p>回写时mysql产生binlog记录数据变更，使用架构解析binlog在写到redis中</p><h2 id="redis基本原理">redis基本原理</h2><ul><li>redis将数据存在内存中，但是也可以做到持久化</li></ul><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231603784.png" alt="image-20241123160343688"></p><ul><li><p>增量数据保存到AOF文件，全量数据RDB文件，实现持久化</p></li><li><p>redis单线程处理所有操作命令</p></li></ul><h1 id="redis应用案例">Redis应用案例</h1><h2 id="连续签到">连续签到</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231611534.png" alt="image-20241123161127471"></p><h3 id="string数据结构"><strong>string数据结构</strong></h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231616813.png" alt="image-20241123161644730"></p><p><code>alloc</code>：内存大小</p><p><code>len</code> ：实际使用的内存</p><h2 id="消息通知">消息通知</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231618183.png" alt="image-20241123161806086"></p><h3 id="list数据结构quicklist">List数据结构Quicklist</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231622720.png" alt="image-20241123162223616"></p><p>一个节点中会存储很多数据</p><h2 id="计数">计数</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231626770.png" alt="image-20241123162633678"></p><h3 id="hash数据结构-dict">Hash数据结构 - dict</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231633126.png" alt="image-20241123163315026"></p><h2 id="排行榜">排行榜</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231637179.png" alt="image-20241123163709094"></p><h3 id="zset数据结构-zskiplist">zset数据结构 - zskiplist</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231639932.png" alt="image-20241123163928846"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231652906.png" alt="image-20241123165255795"></p><ul><li>redis里跳表不超过4层</li></ul><h2 id="限流">限流</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231654554.png" alt="image-20241123165432470"></p><h2 id="分布式锁">分布式锁</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231658456.png" alt="image-20241123165835367"></p><h1 id="redis使用注意事项">Redis使用注意事项</h1><h2 id="大key-热key">大Key，热Key</h2><h3 id="定义">定义</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231705090.png" alt="image-20241123170545001"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231715587.png" alt="image-20241123171504497"></p><h3 id="危害">危害</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231705635.png" alt="image-20241123170559538"></p><h3 id="解决方法">解决方法</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231708542.png" alt="image-20241123170856451"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231709644.png" alt="image-20241123170928595"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231716787.png" alt="image-20241123171605696"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231718273.png" alt="image-20241123171831182"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231720931.png" alt="image-20241123172015841"></p><h2 id="慢查询场景">慢查询场景</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231723110.png" alt="image-20241123172317025"></p><h2 id="缓存穿透-缓存雪崩">缓存穿透，缓存雪崩</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411231725373.png" alt="image-20241123172525281"></p>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L9-Go 框架三件套详解(Web/RPC/ORM)</title>
      <link href="/2024/11/18/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L9-Go-%E6%A1%86%E6%9E%B6%E4%B8%89%E4%BB%B6%E5%A5%97%E8%AF%A6%E8%A7%A3-Web-RPC-ORM/"/>
      <url>/2024/11/18/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L9-Go-%E6%A1%86%E6%9E%B6%E4%B8%89%E4%BB%B6%E5%A5%97%E8%AF%A6%E8%A7%A3-Web-RPC-ORM/</url>
      
        <content type="html"><![CDATA[<h1 id="gorm的基本使用">GORM的基本使用</h1><h2 id="定义-gorm-model">定义 gorm model</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span>&#123;</span><br><span class="line">    Code <span class="type">string</span></span><br><span class="line">    Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为model定义表名">为model定义表名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product)</span></span> TableName() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有定义表名，默认用结构体名的蛇形负数作为表名</p><h2 id="数据库连接">数据库连接</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dsn := <span class="string">&quot;username/password@tcp(127.0.0.1:3306)/dbname?cahrset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.config&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建数据">创建数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := db.Create(&amp;Product&#123;Price:<span class="number">200</span>, Code:<span class="string">&quot;F42&quot;</span>&#125;).Error</span><br></pre></td></tr></table></figure><h2 id="查询数据">查询数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := db.First(&amp;Product, <span class="number">1</span>).Error <span class="comment">//默认使用整形主键查找</span></span><br><span class="line">err := db.First(&amp;Product, <span class="string">&quot;code = ?&quot;</span>, <span class="string">&quot;F42&quot;</span>)  <span class="comment">//根据code字段查找</span></span><br></pre></td></tr></table></figure><h2 id="更新数据">更新数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Update - 更新一个字段</span></span><br><span class="line">db.Model(&amp;Product).Update(<span class="string">&quot;Price&quot;</span>, <span class="number">250</span>)</span><br><span class="line"><span class="comment">//Updates - 用结构体更新多个字段</span></span><br><span class="line">db.Model(&amp;Product).Update(Product&#123;Price:<span class="number">200</span>, Code:<span class="string">&quot;F42&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//Updates - 用字典更新多个地段</span></span><br><span class="line">db.Model(&amp;Product).Update(<span class="keyword">map</span>[stringinterface&#123;&#125;&#123;<span class="string">&quot;Price&quot;</span>:<span class="number">200</span>, <span class="string">&quot;Code&quot;</span>:<span class="string">&quot;F42&quot;</span>&#125;])</span><br></pre></td></tr></table></figure><blockquote><p>使用结构体更新数据时，gorm只会更新非零字段，对于想要更新成0值的字段，则不会有所改动，要想要改成0值，则需要使用map进行更新</p></blockquote><h2 id="删除数据">删除数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据整型主键删除</span></span><br><span class="line">db.Delete(&amp;Product, <span class="number">1</span>)  </span><br><span class="line"><span class="comment">//根据切片批量删除</span></span><br><span class="line">db.Delete(&amp;Product, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="事务">事务</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm<span class="number">.0</span>pen(mysql<span class="number">.0</span>pen( dsn: <span class="string">&quot;username:password@tcp(localhost:9910)/database?charset=utf8&quot;</span>),</span><br><span class="line">&amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(v:<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">tx:= db.Beqin()开始事务</span><br><span class="line"><span class="comment">//在事务中执行一些 db 操作(从这里开始，您应该使用&#x27;tx’而不是&#x27;db&#x27;)</span></span><br><span class="line"><span class="keyword">if</span> err =tx.Create(&amp;UseriName:<span class="string">&quot;name&quot;</span>&#125;).Error;err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="comment">// 遇到错误时回滚事务</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err =tx.Create(&amp;User&#123;Name:<span class="string">&quot;name1&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback(</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure><h2 id="hook">Hook</h2><p>hook：创建，查询，更新，删除前后自动调用的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="type">int64</span></span><br><span class="line">Name <span class="type">string</span> gorm:<span class="string">&quot;default:galeone&quot;</span></span><br><span class="line">Age <span class="type">int64</span> gorm:<span class="string">&quot;default:18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="type">int64</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span>BeforeCreate(tx *gorm.DB)(err <span class="type">error</span>)&#123;  <span class="comment">//hook</span></span><br><span class="line"><span class="keyword">if</span> u.Age &lt;<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(text:<span class="string">&quot;can&#x27;t save invalid data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(u *User)</span></span>AfterCreate(tx *gorm.DB)(err <span class="type">error</span>)&#123;  <span class="comment">//hook</span></span><br><span class="line"><span class="keyword">return</span> tx,Create(&amp;Email&#123;ID:u.ID,Email: u.Name +<span class="string">&quot;@***.com&quot;</span>&#125;).Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook发生错误会回滚</p><h2 id="提高性能">提高性能</h2><ul><li>对于写操作(创建、更新、删除)，为了确保数据的完整性，GORM 会将它们封装在事务内运行。但这会降低性能，你可以使用SkipDefaultTransaction 关闭默认事务。</li><li>使用 PrepareStmt 缓存预编译语句可以提高后续调用的速度，本机测试提高大约 35 %左右。</li></ul><h1 id="kitex基本使用">Kitex基本使用</h1><h2 id="安装工具">安装工具</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411302102847.png" alt="image-20241130210218761"></p><p><a href="https://www.cloudwego.io/zh/docs/kitex/">kitex文档</a></p><h2 id="定义idl">定义IDL</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411302101812.png" alt="image-20241130210149631"></p>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L8-带你认识存储&amp;数据库</title>
      <link href="/2024/11/18/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L8-%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8&amp;%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/11/18/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L8-%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8&amp;%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="经典案例">经典案例</h1><h2 id="数据的产生">数据的产生</h2><p><a href="https://image.nickxu.me/202206031600504.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220575.png" alt="image-20220603160032422"></a></p><h2 id="数据的流动">数据的流动</h2><p><a href="https://image.nickxu.me/202206031602755.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220182.png" alt="image-20220603160231674"></a></p><h2 id="数据的持久化">数据的持久化</h2><p><a href="https://image.nickxu.me/202206031604733.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220401.png" alt="image-20220603160416665"></a></p><h2 id="潜在的问题">潜在的问题</h2><p><a href="https://image.nickxu.me/202206031605581.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220696.png" alt="image-20220603160509513"></a></p><h1 id="存储-数据库简介">存储 &amp; 数据库简介</h1><h2 id="存储系统">存储系统</h2><h3 id="系统概览">系统概览</h3><p><a href="https://image.nickxu.me/202206031608150.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220176.png" alt="image-20220603160831080"></a></p><h3 id="系统特点">系统特点</h3><p><a href="https://image.nickxu.me/202206031609990.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220668.png" alt="image-20220603160942927"></a></p><ul><li>简单：业务逻辑</li><li>复杂：错误处理</li></ul><h3 id="存储器层级结构">存储器层级结构</h3><p><a href="https://image.nickxu.me/202206031613962.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220046.png" alt="image-20220603161316888"></a></p><p>越往上，容量越小，性能越好，越贵</p><h3 id="数据怎么从应用到存储介质">数据怎么从应用到存储介质</h3><p><a href="https://image.nickxu.me/202206031613484.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220960.png" alt="image-20220603161352410"></a></p><h3 id="raid-技术">RAID 技术</h3><p><a href="https://image.nickxu.me/202206031619053.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220948.png" alt="image-20220603161934973"></a></p><h2 id="数据库">数据库</h2><p><a href="https://image.nickxu.me/202206031620221.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220688.png" alt="image-20220603162053150"></a></p><h3 id="概览">概览</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220369.png" alt="image-20220603162245107"></p><ul><li>关系：实体与实体之间的联系</li><li>DSL：领域专用语言（人说人话，狗说狗话）</li></ul><h3 id="关系型数据库特点">关系型数据库特点</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220263.png" alt="image-20220603162402135"></p><h3 id="非关系型数据库特点">非关系型数据库特点</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220522.png" alt="image-20220603162451483"></p><h2 id="数据库-vs-经典存储">数据库 VS 经典存储</h2><h3 id="结构化数据管理">结构化数据管理</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220962.png" alt="image-20220603162700919"></p><h3 id="事务能力">事务能力</h3><p><a href="https://image.nickxu.me/202206031627475.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220120.png" alt="image-20220603162714397"></a></p><h3 id="复杂查询能力">复杂查询能力</h3><p><a href="https://image.nickxu.me/202206031630654.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220545.png" alt="image-20220603163054567"></a></p><h2 id="数据库的使用方式">数据库的使用方式</h2><p><a href="https://image.nickxu.me/202206031631053.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220308.png" alt="image-20220603163137985"></a></p><h1 id="主流产品刨析">主流产品刨析</h1><p><a href="https://image.nickxu.me/202206031638377.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220407.png" alt="image-20220603163807301"></a></p><h2 id="单机存储">单机存储</h2><h3 id="概览">概览</h3><p><a href="https://image.nickxu.me/202206031639054.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220350.png" alt="image-20220603163917984"></a></p><h4 id="本地文件系统">本地文件系统</h4><p><a href="https://image.nickxu.me/202206031639167.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220875.png" alt="image-20220603163930081"></a></p><h4 id="key-value-存储">key-value 存储</h4><p><a href="https://image.nickxu.me/202206031642626.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220052.png" alt="image-20220603164232540"></a></p><h2 id="分布式存储">分布式存储</h2><p><a href="https://image.nickxu.me/202206031709816.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220181.png" alt="image-20220603170913748"></a></p><h3 id="hdfs">HDFS</h3><p><a href="https://image.nickxu.me/202206031712998.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220113.png" alt="image-20220603171212917"></a></p><h3 id="ceph">Ceph</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220686.png" alt="image-20220603171400978"></p><h2 id="单机数据库">单机数据库</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220615.png" alt="image-20220603171421609"></p><h3 id="关系型数据库">关系型数据库</h3><p><a href="https://image.nickxu.me/202206031714595.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220850.png" alt="image-20220603171456511"></a></p><p><a href="https://image.nickxu.me/202206031717577.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220296.png" alt="image-20220603171741484"></a></p><h3 id="非关系型数据库">非关系型数据库</h3><p><a href="https://image.nickxu.me/202206031718186.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220191.png" alt="image-20220603171841095"></a></p><p><a href="https://image.nickxu.me/202206031722017.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220572.png" alt="image-20220603172255935"></a></p><p><a href="https://image.nickxu.me/202206031724154.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220423.png" alt="image-20220603172447067"></a></p><h2 id="分布式数据库">分布式数据库</h2><p><a href="https://image.nickxu.me/202206031726906.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220880.png" alt="image-20220603172627835"></a></p><h3 id="解决容量问题">解决容量问题</h3><p><a href="https://image.nickxu.me/202206031728489.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220704.png" alt="image-20220603172806399"></a></p><h3 id="解决弹性问题">解决弹性问题</h3><p><a href="https://image.nickxu.me/202206031729398.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220290.png" alt="image-20220603172938290"></a></p><h3 id="解决性价比问题">解决性价比问题</h3><p><a href="https://image.nickxu.me/202206031731064.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220685.png" alt="image-20220603173118945"></a></p><h3 id="more-to-do">More to Do</h3><p><a href="https://image.nickxu.me/202206031732843.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220788.png" alt="image-20220603173252780"></a></p><h1 id="新技术演进">新技术演进</h1><h2 id="概览">概览</h2><p><a href="https://image.nickxu.me/202206031733282.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220714.png" alt="image-20220603173336210"></a></p><h2 id="spdk">SPDK</h2><p><a href="https://image.nickxu.me/202206031735894.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220334.png" alt="image-20220603173533815"></a></p><h2 id="ai-storage">AI &amp; Storage</h2><p><a href="https://image.nickxu.me/202206031738947.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220508.png" alt="image-20220603173802860"></a></p><h2 id="高性能硬件">高性能硬件</h2><p><a href="https://image.nickxu.me/202206031738002.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220561.png" alt="image-20220603173858910"></a></p><h1 id="总结">总结</h1><p><a href="https://image.nickxu.me/202206031740364.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220682.png" alt="image-20220603174028277"></a></p><p><a href="https://image.nickxu.me/202206031741653.png"><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411181220945.png" alt="image-20220603174105549"></a></p>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L7-深入浅出RPC框架</title>
      <link href="/2024/11/17/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L7-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/11/17/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L7-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><h2 id="本地函数调用">本地函数调用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line">result := calculate(a,b)</span><br><span class="line">fmt.Println(result)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">Z := X*y</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将a和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x和 y</li><li>计算 x*y，并将结果存在 z</li><li>将z的值压栈，然后从 calculate 返回</li><li>从栈中取出 z返回值，并赋值给 result</li></ol><h2 id="远程函数调用-rpc">远程函数调用（RPC）</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171549663.png" alt=""></p><p>函数映射：确定要用哪个函数</p><p>数据转换成字节流：传输参数的方式</p><p>网络传输：如何保证网络高效稳定的传输</p><h2 id="rpc概念模型">RPC概念模型</h2><p>理论模型：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171604975.webp" alt=""></p><h2 id="一次rpc的完整过程">一次RPC的完整过程</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171606860.png" alt=""></p><h2 id="rpc的好处">RPC的好处</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171609995.png" alt=""></p><h2 id="rpc的弊端">RPC的弊端</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171611213.png" alt=""></p><h2 id="小结">小结</h2><ol><li>本地函数调用和 RPC 调用的区别:函数映射、数据转成字节流、网络传输</li><li>RPC 的概念模型:User、User-Stub、RPC-Runtime、Server-Stub、Server</li><li>一次 PRC 的完整过程，并讲解了 RPC 的基本概念定义</li><li>RPC 带来好处的同时也带来了不少新的问题，将由 RPC 框架来解决</li></ol><h1 id="分层设计">分层设计</h1><h2 id="以apache-thrift为例">以Apache Thrift为例</h2><p><img src="C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241117161447479.png" alt="image-20241117161447479"></p><h2 id="编解码层">编解码层</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171616597.png" alt=""></p><h3 id="生成代码">生成代码</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171617982.png" alt=""></p><p>客户端和服务器都依赖于相同的IDL文件，通过他来生成适用于各种语言的代码</p><h3 id="数据格式">数据格式</h3><ul><li><p><strong>语言特定的格式</strong></p><p>许多编程语言都内建了将内存对象编码为字节序列的支持，例如 Java 有 iava.io.Serializable</p></li><li><p><strong>文本格式</strong></p><p>JSON、XML、CSV 等文本格式，具有人类可读性</p></li><li><p><strong>二进制编码</strong></p><p>具备跨语言和高性能等优点，常见有 Thrift 的 BinaryProtocol，Protobuf 等</p><p>二进制编码就是把数据转换成二进制流，实现方式有多种，例如 TLV 编码 和 Varint 编码，Thrift 的 BinaryProtocol实现方式就是TLV编码，接下来对TLV编码进行介绍</p><p><strong>TLV结构</strong>：</p><ul><li>Tag：标签，可以理解为类型</li><li>Lenght：长度</li><li>Value：值，Value也可以是个TLV结构（嵌套）</li></ul><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person(</span><br><span class="line">1: required stringuserName,</span><br><span class="line">2: optional i64favoriteNumber,</span><br><span class="line">3: optional list&lt;string&gt; interests,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体就是IDL文件中定义的结构体，在经过编码后会变成：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171633439.png" alt=""></p><p>TLV的问题：tag和lenght字段会造成数据冗余</p></li></ul><h3 id="选型">选型</h3><ul><li><p><strong>兼容性</strong></p><p>支持自动增加新的字段，而不影响老的服务，这将提高系统的灵活度</p></li><li><p><strong>通用性</strong></p><p>支持跨平台、跨语言</p></li><li><p><strong>性能</strong></p><p>从空间和时间两个维度来考虑，也就是编码后数据大小和编码耗费时长</p></li></ul><h2 id="协议层">协议层</h2><h3 id="概念">概念</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171639896.png" alt=""></p><h2 id="协议构造">协议构造</h2><p>以 Thrift 的 THeader 协议为例</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171643573.webp" alt="img"></p><ul><li><code>LENGTH</code>: 数据包大小，不包含自身</li><li><code>HEADER MAGIC</code>: 标识版本信息，协议解析时候快速校验</li><li><code>SEQUENCE NUMBER</code>: 表示数据包的 seqlD,可用于多路复用，单连接内递增</li><li><code>HEADER SIZE</code>: 头部长度，从第14个字节开始计算一直到 PAYLOAD前</li><li><code>PROTOCOL ID</code>: 编解码方式，有 Binary 和 Compact 两种</li><li><code>TRANSFORM ID</code>: 压缩方式，如 zlib 和 snappy</li><li><code>INFO ID</code>: 传递一些定制的 meta 信息</li><li><code>PAYLOAD</code>: 消息体</li></ul><h3 id="协议解析">协议解析</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171650998.png" alt="image-20241117165050953"></p><p>协议类型 -&gt; 编解码方式 -&gt; 解析payload</p><h2 id="网络通信层">网络通信层</h2><h3 id="sockets-api">Sockets API</h3><p><strong>是什么</strong>：是一种方便的编程接口，用于与 TCP、UDP 等协议进行交互，开发者只要使用Sockets API封装的函数，就可以使用TCP，UDP，无需直接与协议细节打交道就可以实现网络通信的功能。</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171701500.png" alt="image-20241117170125461"></p><p>socket编程过程：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171701904.png" alt="image-20241117170157853"></p><h2 id="网络库">网络库</h2><ul><li><p>提供易用 API</p><p>封装底层 Socket API连接管理和事件分发</p></li><li><p>功能</p><p>协议支持:tcp、udp 和 uds 等</p><p>优雅退出、异常处理等</p></li><li><p>性能</p><p>应用层 buffer 减少 copy</p><p>高性能定时器、对象池等</p></li></ul><h2 id="小结">小结</h2><ol><li><p>RPC 框架主要核心有三层:编解码层、协议层和网络通信层</p></li><li><p>二进制编解码的实现原理和选型要点</p></li><li><p>协议的一般构造，以及框架协议解析的基本流程</p></li><li><p>网络库的基本架构，以及选型时要考察的核心指标</p></li></ol><h1 id="关键指标">关键指标</h1><h2 id="稳定性">稳定性</h2><h3 id="保障策略">保障策略</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171708233.png" alt="image-20241117170849153"></p><h3 id="请求成功率">请求成功率</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171710167.png" alt="image-20241117171021099"></p><h3 id="长尾请求">长尾请求</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171718039.png" alt="image-20241117171800967"></p><p>t4 &lt; t1 + t2，减少长尾请求的延时</p><h3 id="注册中间件">注册中间件</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171738168.png" alt="image-20241117173848077"></p><h2 id="易用性">易用性</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171739657.png" alt="image-20241117173956572"></p><h2 id="扩展性">扩展性</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171741603.png" alt="image-20241117174148522"></p><h2 id="观测性">观测性</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171743066.png" alt="image-20241117174331007"></p><h2 id="高性能">高性能</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171745204.png" alt="image-20241117174520135"></p><h1 id="企业实践">企业实践</h1><p>框架文档 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fkitex%2F">Kitex</a></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171752019.png" alt="image-20241117175237947"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171753962.png" alt="image-20241117175302897"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171754418.png" alt="image-20241117175446334"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171754927.png" alt="image-20241117175455860"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171756175.png" alt="image-20241117175638112"></p><p><img src="https://image.nickxu.me/202206011957321.png" alt="image-20220601195736225"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171756247.png" alt="image-20220601200231030"></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411171757806.png" alt="image-20220601200715858"></p>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L6-将我的服务开放给用户</title>
      <link href="/2024/11/12/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L6-%E5%B0%86%E6%88%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%94%BE%E7%BB%99%E7%94%A8%E6%88%B7/"/>
      <url>/2024/11/12/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L6-%E5%B0%86%E6%88%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%94%BE%E7%BB%99%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="接入问题引入">接入问题引入</h1><p>一个报文的生命周期</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121618562.png" alt=""></p><h1 id="企业接入升级打怪之路">企业接入升级打怪之路</h1><h2 id="域名系统">域名系统</h2><h3 id="host管理">Host管理</h3><p>通过<code>hosts</code>文件将主机名映射到IP地址</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121629745.png" style="zoom:80%;" /><p>随着 example 公司业务规模和员工数量的增长，使用该方式面临诸多问题:</p><ul><li>流量和负载:用户规模指数级增长，文件大小越来越大，统一分发引起较大的网络流量和cpu负载</li><li>名称冲突:无法保证主机名称的唯一性，同名主机添加导致服务故障</li><li>时效性:分发靠人工上传，时效性太差</li></ul><h3 id="使用域名系统">使用域名系统</h3><p>由于Host管理的劣势，可以用域名系统替换hosts文件</p><p>具体有以下规则：</p><ul><li>域名空间被组织成树形结构</li><li>域名空间通过划分zone的方式进行分层授权管理</li><li>全球公共域名空间仅对应一棵树</li><li>根域名服务器:查询起点</li><li>域名组成格式:[a-zA-Z0-9-]，以点划分label</li></ul><p>如图所示</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121839012.png" style="zoom:80%;" /><p>通用顶级域名（gTLD）：gov政府 .edu教育.com商业.mil军事.org非盈利组织</p><p>域名报文格式：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121842270.png" alt=""></p><h3 id="域名购买与配置迁移">域名购买与配置迁移</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121847598.png" alt=""></p><h3 id="如何开放外部用户访问">如何开放外部用户访问</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121848971.png" alt=""></p><h2 id="自建dns服务器">自建DNS服务器</h2><h3 id="问题背景">问题背景</h3><p>域名系统依然存在问题：</p><ol><li>内网域名的解析也得出公网去获取，效率低下</li><li>外部用户看到内网 ip 地址，容易被 hacker 攻击</li><li>云厂商权威DNS容易出故障，影响用户体验</li><li>持续扩大公司品牌技术影响力，使用自己的DNS系统</li></ol><p>为了解决这些问题，要从公有云托管转变为自己构建的DNS系统</p><h3 id="dns查询过程">DNS查询过程</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121900895.png" alt=""></p><h3 id="dns记录类型">DNS记录类型</h3><p><strong>A/AAAA</strong>：IP指向记录，用于指向IP，前者为IPv4记录，后者为IPv6记录</p><p><strong>CNAME</strong>：别名记录，配置值为别名或主机名，客户端根据别名继续解析以提取IP地址</p><p><strong>TXT</strong>：文本记录，购买证书时需要</p><p><strong>MX</strong>：邮件交换记录，用于指向邮件交换服务器</p><p><strong>NS</strong>：解析服务器记录，用于指定哪台服务器对于该域名解析</p><p><strong>SOA 记录</strong>：起始授权机构记录，每个zone有且仅有唯一的一条SOA记录，SOA是描述zone属性以及主要权威服务器的记录</p><p>例子：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121911206.png" alt=""></p><p>SOA记录举例：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121912701.png" alt=""></p><p>每个字段的说明如下：</p><ul><li><strong><a href="http://example.com">example.com</a>.</strong>：域名。</li><li><strong>IN</strong>：表示互联网（Internet）类。</li><li><strong>SOA</strong>：表示这是一个起始权威记录。</li><li><strong><a href="http://ns1.domain.com">ns1.domain.com</a>.</strong>：主DNS服务器的域名。</li><li><strong><a href="http://admin.example.com">admin.example.com</a>.</strong>：负责该域的管理员的电子邮件地址（“@”符号替换为“.”）。</li></ul><p>以下是一些关键参数：</p><ul><li><strong>120</strong>：序列号，通常是版本号，用于跟踪DNS记录的更改。</li><li><strong>3h</strong>：刷新间隔（refresh interval），指从主DNS服务器刷新记录的时间间隔。</li><li><strong>30m</strong>：重试间隔（retry interval），指从主DNS服务器无法刷新时，次要服务器需要重试的时间间隔。</li><li><strong>3w</strong>：过期时间（expiry period），指次要服务器在无法联系主服务器时，记录过期的时间。</li><li><strong>1h</strong>：负 TTL（negative TTL），指DNS查询失败时（例如，未找到记录）的信息在DNS缓存中的存留时间。</li></ul><h3 id="权威dns系统架构">权威DNS系统架构</h3><p>常见的开源DNS：bind，nsd，knot，coredns</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411121924050.png" alt=""></p><h2 id="https协议">HTTPS协议</h2><h3 id="问题背景">问题背景</h3><p>页面出现白页/出现某些奇怪的东西</p><p>返回了403的页面</p><p>搜索不了东西</p><p>搜索问题带了小尾巴,页面总要闪几次</p><p>页面弹窗广告</p><p>搜索个汽车就有人给我打电话推销4s店和保险什么的</p><p><strong>如何解决</strong>：HTTP -&gt; HTTPS</p><h3 id="对称加密和非对称加密">对称加密和非对称加密</h3><p>对称加密：一份密钥，同时用于加密和解密</p><p>非对称加密：公钥和私钥，公钥加密，私钥解密/私钥加密，公钥解密</p><p><img src="https://image.nickxu.me/202205211652658.jpg" alt=""></p><h3 id="ssl的通信过程">SSL的通信过程</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411122003006.png" alt=""></p><h3 id="证书链">证书链</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411122003063.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411122004033.jpeg" alt=""></p><h3 id="使用-https">使用 https</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131113409.png" alt=""></p><h2 id="接入全站加速">接入全站加速</h2><h3 id="问题背景">问题背景</h3><p>外网用户访问站点，可能会出现一些问题：</p><ul><li>源站容量低，可承载的并发请求数低，容易被打垮</li><li>报文经过的网络设备越多，出问题的概率越大，丢包、劫持、mtu问题</li><li>自主选路网络链路长，时延高</li></ul><p>总的来说就是 响应慢，卡顿</p><h3 id="解决方案">解决方案</h3><p>源站容量问题：增加后端机器扩容;静态内容，使用静态加速缓存</p><p>网络传输问题：动态加速DCDN</p><p>全站加速就是静态加速和动态加速</p><h3 id="静态加速-cdn">静态加速 CDN</h3><p>CDN的使用：在这部分，CDN边缘节点被引入。用户的请求会被引导到离用户更近的CDN节点。</p><p>缓存机制：CDN节点缓存静态内容（如图片、视频、脚本等），可以快速响应用户请求。</p><p>数据传输：用户从CDN边缘节点获取内容，而不是直接从主服务器，这样可以减少延迟，提高加载速度。</p><h3 id="动态加速-dcdn">动态加速 DCDN</h3><p>智能选择最优路径</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131122783.png" alt=""></p><p>DCDN原理：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131132084.png" alt=""></p><h3 id="使用全站加速">使用全站加速</h3><p>请区分下列场景使用的加速类型</p><p>1、用户首次登录抖音，注册用户名手机号等用户信息 —— 动态加速DCDN</p><p>2、抖音用户点开某个特定的短视频加载后观看 —— 静态加速CDN</p><p>3、用户打开头条官网进行网页浏览 —— 静态加速CDN+动态加速DCDN</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131135230.png" alt=""></p><p>在介绍四层负载均衡和七层负载均衡之前，先看一个简化的后端服务拓扑图</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131650385.png" alt=""></p><p>可以看到，4层和7层负载均衡是面对不同对象的，但是做的事都是对流量的分配。</p><p>再复习一下计算机网络结构图</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131820163.jpeg" alt=""></p><h2 id="四层负载均衡">四层负载均衡</h2><h3 id="问题背景">问题背景</h3><p>提问:在运营商处租用的100.1.2.3的公网IP，如何在企业内部使用最合理?</p><p>现状:直接找一个物理机，ifconfig将网卡配上这个IP，起server监听即可</p><p>应用多，起多个server监听不同的端口即可</p><p>租多个公网 ip(数量有限)</p><p>怎样尽可能充分的利用和管理有限的公网I资源?</p><h3 id="什么是四层负载均衡">什么是四层负载均衡</h3><p>基于IP+端口，利用某种算法将报文更平均地转发给某个后端服务器，实现负载均衡地落到后端服务器上</p><p>三个主要功能：</p><ol><li>解耦 vip 和 rs</li><li>NAT</li><li>防攻击:syn proxy</li></ol><p>常见的调度算法原理：</p><ul><li><p>RR轮询:Round Robin，将所有的请求平均分配给每个真实服务器RS</p></li><li><p>加权RR轮询:给每个后端服务器一个权值比例，将请求按照比例分配</p></li><li><p>最小连接:把新的连接请求分配到当前连接数最小的服务器</p></li><li><p>五元组hash:根据sip、sport、proto、dip、dport对静态分配的服务器做散列取模</p><p>缺点:当后端某个服务器故障后，所有连接都重新计算，影响整个 hash 环</p></li><li><p>-致性hash:只影响故障服务器上的连接session，其余服务器上的连接不受影响</p></li></ul><h3 id="常见的实现方式-fullnat">常见的实现方式 FULLNAT</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131621977.png" alt=""></p><h3 id="4层负载均衡特点">4层负载均衡特点</h3><ul><li>大部分都是通过 dpdk 技术实现，技术成熟，大厂都在用</li><li>纯用户态协议栈，kernelbypass，消除协议栈瓶颈</li><li>无缓存，零拷贝，大页内存(减少 cache miss)</li><li>仅针对4层数据包转发，小包转发可达到限速，可承受高 cps</li></ul><h3 id="使用4层负载均衡">使用4层负载均衡</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131637805.png" alt=""></p><h2 id="七层负载均衡">七层负载均衡</h2><h3 id="问题背景">问题背景</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131844542.png" alt=""></p><h3 id="nginx简介">Nginx简介</h3><p>最灵活的高性能WEB SERVER，应用最广的7层反向代理，</p><ul><li>模块化设计，较好的扩展性和可靠性</li><li>基于 master/worker 架构设计</li><li>支持热部署;可在线升级</li><li>不停机更新配置文件、更换日志文件、更新服务器二进制</li><li>较低的内存消耗:1万个 keep-alive 连接模式下的非活动连接仅消耗2.5M内存</li></ul><p>Nginx反向代理示意图：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131903405.png" alt=""></p><p>内部架构</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131904650.png" alt=""></p><h3 id="事件驱动模型">事件驱动模型</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131907938.png" alt=""></p><h3 id="异步非阻塞">异步非阻塞</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131908645.png" alt=""></p><h3 id="nginx-简单调优">Nginx 简单调优</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131908683.png" alt=""></p><h3 id="别让-os-限制了-nginx-的性能">别让 OS 限制了 Nginx 的性能</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131909573.png" alt=""></p><h3 id="提升-cpu-使用效率">提升 CPU 使用效率</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131909411.png" alt=""></p><h3 id="提升网络效率">提升网络效率</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131909959.png" alt=""></p><h3 id="使用七层负载均衡">使用七层负载均衡</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411131909863.png" alt=""></p><h1 id="动手实践">动手实践</h1><h1 id="复习总结">复习总结</h1>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L5-打开抖音会发生什么</title>
      <link href="/2024/11/10/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L5-%E6%89%93%E5%BC%80%E6%8A%96%E9%9F%B3%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
      <url>/2024/11/10/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L5-%E6%89%93%E5%BC%80%E6%8A%96%E9%9F%B3%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="刷抖音是怎么交互的">刷抖音是怎么交互的</h1><p>为了方便理解满分为网络接入和网络传输</p><h2 id="网络接入">网络接入</h2><h3 id="互联网">互联网</h3><p>物理联通：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102027993.webp" alt=""></p><h3 id="路由">路由</h3><p>路由发包原理：</p><ul><li><p>同网段：配置网段即可默认添加静态路由。获取对端MAC直接发包。(这里的同网段个人理解为一个子网络内)</p></li><li><p>跨网段：配置网关路由。获取网关MAC地址发包给网关(gateway)</p></li><li><p>动态路由：BGP/OSPF等，路由表在动态变化</p></li><li><p>路由是网状的，不一定是对称的</p></li></ul><h3 id="arp协议">ARP协议</h3><p><strong>作用</strong>：查找下一个发送目标的MAC地址(同网段情况下)</p><p>ARP协议会向子网络中所有计算机发送一个数据包，包括自己的IP地址和查询主机的IP地址，在对方MAC地址上填<code>FF:FF:FF:FF:FF:FF</code>，每台计算机对IP地址进行比较，如果相同就回复自己的MAC地址</p><p>有几点要注意：</p><ul><li><p>逻辑同网段才能发送ARP</p></li><li><p>ARP请求广播，ARP响应单播</p></li><li><p>免费ARP：主动广播告知MAC地址</p><p>场景：新增加了一台服务器，这台服务器通过广播告诉其他服务器他的MAC地址</p></li><li><p>代理ARP：劫持ARP请求，发往另一个虚拟网络/伪造MAC地址</p><p>场景：A发送ARP请求来请求B的MAC地址，代理ARP在交换机上劫持了这个请求，让另一台服务器C返回他的MAC地址</p></li></ul><h3 id="ip协议">IP协议</h3><ul><li>为什么不能用MAC地址替代IP地址：</li><li>IPv4不够用，一般怎么解决</li></ul><h3 id="nat">NAT</h3><p><strong>是什么</strong>：是一种网络技术，用于将私有IP地址转换为公共IP地址，以便在Internet上进行通信</p><p><strong>作用</strong>：</p><ol><li>节省IP地址：NAT可以让多个内部设备共享一个公共IP地址</li><li>网络安全：通过使用私有IP地址，内部网络的设备不会直接暴露在公共互联网中，这增加了安全性。</li></ol><p><strong>应用</strong>：</p><p>在家庭和企业网络的路由器中非常常见</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102127055.webp" alt=""></p><h2 id="网络传输">网络传输</h2><h3 id="数据包">数据包</h3><p><strong>是什么</strong>：本质上是一段内存，里面存储的内存是有序的，一般是按照TCP/IP的多层协议去封装。拆包/封包都是按照协议去写内存/读内存。</p><p>如下图所示：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102208472.png" alt=""></p><h3 id="数据包发送">数据包发送</h3><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102212943.webp" alt=""></p><h3 id="先请求dns">先请求DNS</h3><ol><li>客户端向DNS服务器发送 <code>www.douyin.com</code> 的解析请求</li><li>解析过程是一个递归过程，先从.com开始解析，<a href="http://xn--douyin-200k179hrt8d.com">在解析douyin.com</a></li><li>最后返回IP地址</li></ol> <img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102223350.webp" style="zoom:80%;" /><h3 id="dns的传输协议udp">DNS的传输协议UDP</h3><p>UDP协议就是在数据包中加入了端口号，较为简单，所以是不可靠的</p><p>用好UDP很难，所以一般使用TCP</p><h3 id="tcp三次握手">TCP三次握手</h3><p>三次握手：确认传输的序列号/MSS/Option字段，建立连接</p><p>TCP连接：是一个虚拟的概念，本质上两倍维持一段内存，记录连接状态，就是session</p><p>TCP传输：理解sequence number/acknowledge number</p><p>丢包重传：理解丢包怎么感知并重传，理解快速重传发生在什么时候</p><h3 id="tcp传输">TCP传输</h3><p>在介绍TCP传输之前，我们先来看看TCP协议包的结构</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411120002032.png" style="zoom:80%;" /><p><strong>两个概念</strong>：</p><p><code>sequence number</code>：表示的是我方(发送方)这边，这个packet的数据部分的第一位应该在整个data stream中所在的位置。</p><p><code>acknowledge number</code>：表示的是期望的对方(接收方)的下一次sequence number是多少注意，SYN/FIN的传输虽然没有data，但是会让下一次传输的packet seq增加一，但是ACK的传输，不会让下一次的传输packet加1</p><p>接下来演示 <code>seq</code> 和 <code>ack</code> 在数据传输过程中的变化</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411102301221.png" alt=""></p><p><strong>第一个红框框内是TCP三次握手建立连接的过程</strong>：</p><ol><li>客户端发送SYN（Seq = 0），这是建立TCP连接的第一步，告知接收方要建立连接。</li><li>服务端回应SYN, ACK（Seq = 0, Ack = 1）：服务器确认接收到SYN，并同步自己的序列号。</li><li>客户端发送ACK（Seq = 1, Ack = 1）：本地确认收到服务器的SYN, ACK，连接建立完成。</li></ol><p><strong>第二个红框框中是数据传输过程</strong>：</p><ol><li><p>客户端发送PSH, ACK（Seq = 1, Ack = 726）：此时本地已经发送数据，<code>SEQ</code>为1表示发送了1个数据，<code>ACK</code>为726表示确认接收到726字节的数据。</p></li><li><p>服务端回传ACK（Seq = 1, Ack = 726）：确认收到本地的消息。</p></li></ol><ul><li><p>Timewait：数据传输结束后仍然保持连接一段时间</p></li><li><p>丢包：<code>ack</code>机制判段</p></li><li><p>滑动窗口机制：</p><p>目的：确保发送方不会发送超过接收方缓冲区处理能力的数据量，防止接收方的缓冲区溢出。</p><p>发送窗口：发送方可发送的数据字节的数量，但这些字节还未得到接收方的确认</p><p>接收窗口：接收方告知发送方它可以接收的字节数量，防止发送过多数据超出接收方的能力</p><p>工作原理：</p><ul><li>接收方在TCP报文段中会告诉发送方自己当前的接收窗口大小，吉它还能接受多少字节的数据</li><li>发送方根据接收方通告的窗口大小决定发送的数据量</li><li>当接收方接收数据并处理后，会更新其接收窗口的大小，通过 <code>ACK</code> (确认)报文告知发送方接收窗口的更新情况</li></ul></li><li><p>流量控制和拥塞控制：</p><p>流量控制：让发送端根据接收端的实际接受能力控制发送的数据量，主要关注点在于单个连接</p><p>拥塞控制：管理整个网络中数据流的速率，防止数据包在网络中丢失，作用于整个网络，考虑多个连接之间的交互影响。</p></li></ul><h3 id="http-http1-1">HTTP/HTTP1.1</h3><p>HTTP就是基于TCP实现的，只是多加了一层规矩，这个规矩让用户更加清晰</p><p>HTTP1.1做了一些优化，长连接，部分传输，HOST，缓存</p><h3 id="https">HTTPS</h3><p>对HTTP增加 SSL/TLS 层加密</p><p>HTTPS解密出来仍然是HTTP</p><h3 id="ssl-tls握手">SSL/TLS握手</h3><p>非对称加密/对称加密</p><h1 id="刷抖音为什么又快又稳">刷抖音为什么又快又稳</h1><h2 id="网络提速">网络提速</h2><h3 id="http2-0">HTTP2.0</h3><ul><li><p>多路复用</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411111827985.webp" style="zoom:80%;" /></li></ul><h3 id="理解多路复用-stream">理解多路复用/stream</h3><p>TCP协议通过端口号实现多路复用。每个TCP连接由IP地址和端口号唯一标识，这样同一台主机上的不同应用程序可以通过不同的端口来发送和接收数据。</p><p><strong>对头阻塞</strong>：TCP一旦发生丢包，就会一直传送这个包，知道传送成功，而同时后面的包就会在数据流中等待，发生对头阻塞</p><p>为了解决对头阻塞，我们可以使用 QUIC，HTTP/3.0</p><h3 id="quic-http3-0">QUIC/HTTP3.0</h3><ul><li>使用UDP和userspace实现</li><li>0RTT：0-RTT允许客户端在第一次与服务器建立连接时，可以在连接建立过程中就开始发送数据，而不必等待数据包的确认和完成握手的过程。</li><li>弱网优势：由于QUIC协议解决了TCP的对头阻塞的问题，所以在弱网条件下存在优势</li></ul><p>以上都是协议层面的加速，还可以从网络路径进行优化</p><h3 id="数据中心建设">数据中心建设</h3><ul><li>多运营商接入：同运营商内部访问，避免跨运营商的流量</li><li>有边缘机房/汇聚机房/中心机房</li></ul><h3 id="cdn静态缓存系统">CDN静态缓存系统</h3><p>边缘机房的建设，优先访问边缘机房，缓存命中视频/图片等静态内容</p><h3 id="dsa动态加速系统">DSA动态加速系统</h3><p>分四层/七层动态加速。核心在于利用可控节点做路径探测和规划。</p><h2 id="网络稳定">网络稳定</h2><h3 id="容灾概念">容灾概念</h3><p>故障发生，故障感知，自动切换，服务回复</p><h3 id="容灾案例">容灾案例</h3><ul><li>机房专线故障：环路容灾，避免某条专线故障导致机房孤岛问题（专线是连接各个机房的网络物理路径）</li><li>单机房接入节点故障：DNS容灾，摘除故障的节点-字节GTM系统</li><li>云控容灾：云端交互，服务器/云上下发命令到终端-字节TNC系统</li><li>cache容灾：源站不可用，降级到之前的缓存内容-字节TLB/ByteCDN等系统的容灾建设</li></ul>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六届字节青训营]L4-HTTP框架修炼之路</title>
      <link href="/2024/11/09/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L4-HTTP%E6%A1%86%E6%9E%B6%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/"/>
      <url>/2024/11/09/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L4-HTTP%E6%A1%86%E6%9E%B6%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="再谈http协议">再谈HTTP协议</h1><p>本部分回顾http协议</p><h2 id="什么是http协议">什么是HTTP协议</h2><p><strong>HTTP</strong>：超文本传输协议(Hypertext Transfer Protocol)，（超文本：不只有文本，还有图片，视频，音频）</p><p><strong>为什么需要协议</strong>：</p><ol><li>明确信息的边界（开始，结束）</li><li>能够携带什么信息（什么消息，消息类型）</li></ol><h2 id="协议里有什么">协议里有什么</h2><p>下面是一个示例：</p><p>请求报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/sis</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Who</span><span class="punctuation">: </span>ALex</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8888</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>28</span><br><span class="line"></span><br><span class="line"><span class="language-vbnet"><span class="keyword">Let</span><span class="comment">&#x27;s watch a movie together</span></span></span><br></pre></td></tr></table></figure><p>响应报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> 0K</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>hertz</span><br><span class="line">Date:Thu, 21 Apr 2022 11:46:32 GMT</span><br><span class="line">Content-Type:text/plain;charset=utf-8</span><br><span class="line">Content-Length:2</span><br><span class="line"><span class="attribute">Upstream-Caught</span><span class="punctuation">: </span>1650541592984580</span><br><span class="line"></span><br><span class="line"><span class="language-mathematica"><span class="number">0</span><span class="built_in">K</span></span></span><br></pre></td></tr></table></figure><p>下图是结构</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411091529048.png" alt=""></p><h2 id="请求流程">请求流程</h2><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411091537059.png" alt=""></p><h2 id="不足">不足</h2><p>HTTP1：队头阻塞，传输效率低，明文传输不安全</p><p>HTTP2：多路复用，头部压缩，二进制协议</p><p>QUIC：基于UDP实现，解决队头阻塞，加密减少握手次数，支持快速启动</p><h1 id="http框架设计与实现">HTTP框架设计与实现</h1><h2 id="分层设计">分层设计</h2><h2 id="应用层设计">应用层设计</h2><h2 id="中间件设计">中间件设计</h2><h2 id="路由设计">路由设计</h2><h2 id="协议层设计">协议层设计</h2><h2 id="传输层设计">传输层设计</h2><h1 id="性能修炼之道">性能修炼之道</h1><h2 id="网络库优化">网络库优化</h2><h3 id="buffer设计">buffer设计</h3><h2 id="协议优化">协议优化</h2><h3 id="header解析">header解析</h3><h3 id="热点资源池化">热点资源池化</h3>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L3-高质量编程与性能调优实践</title>
      <link href="/2024/11/06/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L3-%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/11/06/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L3-%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量编程">高质量编程</h1><h2 id="高质量编程简介">高质量编程简介</h2><p>什么是高质量</p><p>​——编写的代码能够达到正确可靠、简洁清晰的目标可称之为高质量代码</p><ul><li>各种边界条件是否考虑完备</li><li>异常情况处理，稳定性保证</li><li>易读易维护</li></ul><h3 id="编程原则">编程原则</h3><p>实际应用场景千变万化，各种语言的特性和语法各不相同，但是高质量编程遵循的原则是相通的</p><p><strong>简单性</strong>：</p><ul><li><p>消除“多余的复杂性”，以简单清晰的逻辑编写代码</p></li><li><p>不理解的代码无法修复改进</p></li></ul><p><strong>可读性</strong>：</p><ul><li>代码是写给人看的，而不是机器</li><li>编写可维护代码的第一步是确保代码可读</li></ul><p><strong>生产力</strong>：</p><ul><li>团队整体工作效率非常重要</li></ul><h2 id="编码规范">编码规范</h2><p>如何编写高质量的 Go 代码</p><ul><li><p>代码格式</p></li><li><p>注释</p></li><li><p>命名规范</p></li><li><p>控制流程</p></li><li><p>错误和异常处理</p></li></ul><h3 id="代码格式">代码格式</h3><p>推荐使用 gofmt 自动格式化代码</p><p><strong>gofmt</strong>：</p><p>Go 语言官方提供的工具，能自动格式化 Go 语言代码为官方统一风格，常见IDE都支持方便的配置</p><p><strong>gofmt</strong>：</p><p>也是 Go 语言官方提供的工具实际等于 gofmt 加上依赖包管理自动增删依赖的包引用、将依赖包按字母序排序并分类</p><h3 id="注释">注释</h3><p><strong>注释应该做的：</strong></p><ul><li>注释应该解释代码作用</li><li>注释应该解释代码如何做的</li><li>注释应该解释代码实现的原因</li><li>注释应该解释代码什么情况会出错</li></ul><p><strong>公共符号始终要注释：</strong></p><ul><li><p>包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释</p></li><li><p>任何既不明显也不简短的公共功能必须予以注释</p></li><li><p>无论长度或复杂程度如何，对库中的任何函数都必须进行注释</p></li></ul><h4 id="小结">小结</h4><ul><li>代码是最好的注释</li><li>注释应该提供代码未表达出的上下文信息</li></ul><h3 id="命名规范">命名规范</h3><h4 id="valuables">Valuables</h4><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写<ul><li>例如使用 ServeHTTP 而不是 ServeHttp</li><li>使用 XMLHTTPRequest 或者 xmlHTTPRequest</li></ul></li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息<ul><li>全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul></li></ul><h4 id="function">Function</h4><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的</li><li>函数名尽量简短</li><li>当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义</li><li>当名为 foo 的包某个函数返回类型T时(T 并不是 Foo)，可以在函数名中加入类型信息</li></ul><p>例子：</p><p>http 包中创建服务的函数如何命名更好? 第一种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><h4 id="package">package</h4><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如 schema、task 等</li><li>不要与标准库同名。例如不要使用 sync 或者 strings</li></ul><p>以下规则尽量满足，以标准库包名为例</p><ul><li><p>不使用常用变量名作为包名。例如使用 bufio 而不是 buf</p></li><li><p>使用单数而不是复数。例如使用 encoding 而不是 encodings</p></li><li><p>谨慎地使用缩写。例如使用 fmt 在不破坏上下文的情况下比 format 更加简短</p></li></ul><h4 id="小结">小结</h4><p>核心目标是降低阅读理解代码的成本</p><p>重点考虑上下文信息，设计简洁清晰的名称</p><h3 id="控制流程">控制流程</h3><ul><li><p>避免嵌套，保持正常流程清晰</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></li><li><p>优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span><span class="type">error</span> &#123;</span><br><span class="line">err := doSomething( )</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err := doAnotherThing()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// normal case</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最常见的正常流程的路径被嵌套在两个 if 条件内</li><li>成功的退出条件是 return nil，必须仔细匹配大括号来发现</li><li>函数最后一行返回一个错误，需要追溯到匹配的左括号，才能了解何时会触发错误</li><li>如果后续正常流程需要增加一步操作，调用新的函数，则又会增加一层嵌套</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := doSomething(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := doAnothorThing(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尽量保持正常代码路径为最小缩进</p></li></ul><h4 id="小结">小结</h4><ul><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li><li>正常流程代码沿着屏幕向下移动</li><li>提升代码可维护性和可读性</li><li>故障问题大多出现在复杂的条件语句和循环语句中</li></ul><h3 id="错误和异常处理">错误和异常处理</h3><h4 id="简单错误">简单错误</h4><p>简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误</p><p>优先使用 errors.New 来创建匿名变量来直接表示简单错误</p><p>如果有格式化的需求，使用 fmt.Errorf</p><h4 id="错误的-wrap-和-unwrap">错误的 Wrap 和 Unwrap</h4><ul><li>错误的 Wrap 实际上是提供了一个 error 嵌套另一个error 的能力，从而生成一个 error 的跟踪链</li><li>在 fmt.Errorf 中使用: %w 关键字来将一个错误关联至错误链中</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list, _, err := c.GetBytes(cache.Subkey(a.actionID, <span class="string">&quot;srcdiles&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;reading srcfiles list: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误判定">错误判定</h4><ul><li><p>判定一个错误是否为特定错误，使用 <a href="http://errors.ls">errors.ls</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _,err := os<span class="number">.0</span>pen(<span class="string">&quot;non-existing&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> pathError *fs.PathError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;pathError)&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed at path:&quot;</span>, pathError.Path)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同于使用 ==，使用该方法可以判定错误链上的所有错误是否含有特定的错误</p></li></ul><h4 id="panic">panic</h4><ul><li>不建议在业务代码中使用 panic</li><li>调用函数不包含 recover 会造成程序崩溃</li><li>若问题可以被屏蔽或解决，建议使用error 代替 panic</li><li>当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic</li></ul><h4 id="recover">recover</h4><ul><li>recover 只能在被 defer 的函数中使用</li><li>嵌套无法生效</li><li>只在当前 goroutine 生效</li><li>defer 的语句是后进先出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *ss)</span></span>Token(skipSpace <span class="type">bool</span>,f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">rune</span>)</span></span><span class="type">bool</span>)</span><br><span class="line">(tok [lbyte, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>();e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> se,ok :=e.(scanError);ok&#123;</span><br><span class="line">err = se.err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结">小结</h4><p>error 尽可能提供简明的上下文信息链，方便定位问题<br>panic 用于真正异常的情况<br>recover 生效范围，在当前 goroutine 的被 defer 的函数中生效</p><h2 id="性能优化建议">性能优化建议</h2><h3 id="benchmark">Benchmark</h3><p>go的基准性能测试工具</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411061933327.png" alt=""></p><ul><li><p><strong>goos</strong>: 显示运行基准测试的操作系统，这里是 <code>linux</code>。</p></li><li><p><strong>goarch</strong>: 处理器架构，表明测试在 <code>amd64</code>（64位架构）上运行。</p></li><li><p><strong>pkg</strong>: 指向正在测试的包，即 <code>github.com/MoonLight-Zhao/go-project-example/test</code>。</p></li><li><p><strong>cpu</strong>: 显示使用的 CPU 的型号及核心数，这里是 <code>AMD EPYC 9Y24 96-Core Processor</code>。</p></li><li><p>运行了 132,493 次</p></li><li><p>每次调用的平均时间是 8981 纳秒</p></li><li><p>每次调用的内存分配是 5376 字节</p></li><li><p>每次调用的内存分配次数是 1</p></li></ul><h3 id="slice">slice</h3><p><strong>预分配内存：</strong></p><ul><li>尽可能在使用 <code>make()</code> 初始化切片时提供容量信息</li></ul><p><strong>使用<code>copy</code></strong></p><ul><li><p>在已有切片基础上创建切片，如果原切片较大，应该用 <code>copy</code> 替代重复切片</p><p>因为原切片较大，代码在原切片基础上新建小切片原底层数组在内存中有引用，得不到释放</p></li></ul><h3 id="map">map</h3><p><strong>预分配内存：</strong></p><p>分析：</p><ul><li>不断向 map 中添加元素的操作会触发 map 的扩容</li><li>提前分配好空间可以减少内存拷贝和 Rehash 的消耗</li><li>建议根据实际需求提前预估好需要的空间</li></ul><h3 id="字符串处理">字符串处理</h3><p><strong>使用strings.Builder</strong>:</p><p>一般情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Plus</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    s := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        s += str[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strings.Builder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> builder <span class="type">string</span>.Builder</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++&#123;</span><br><span class="line">        builder.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ByteBuffer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ByteBuffer</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span><span class="type">string</span>&#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">buf.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> buf.<span class="type">string</span>( )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 +拼接性能最差，strings.Builder，bytes.Buffer 相近，strings.Buffer 更快</li><li>分析：<ul><li>字符串在 Go 语言中是不可变类型，占用内存大小是固定的</li><li>使用+每次都会重新分配内存</li><li>strings.Builder，bytes.Buffer 底层都是 []byte 数组</li><li>内存扩容策略，不需要每次拼接重新分配内存</li></ul></li></ul><p>想要再进一步提升性能，用 <code>PreStrBuilder</code>，<code>PreByteBuffer</code> (提前知道长度)</p><h3 id="空结构体">空结构体</h3><p><strong>使用空结构体节省内存</strong>:</p><ul><li>空结构体 struct8 实例不占据任何的内存空间</li><li>可作为各种场景下的占位符使用<ul><li>节省资源</li><li>空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符</li></ul></li></ul><p>使用示例：</p><ul><li>实现 Set，可以考虑用 map 来代替</li><li>对于这个场景，只需要用到 map 的键，而不需要值</li><li>即使是将 map 的值设置为 bool 类型，也会多占据 1个字节空间</li></ul><h3 id="如何使用atomic包">如何使用atomic包</h3><p>使用 <code>atomic</code> 来代替 <code>sync.Mutex</code></p><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li>atomic 操作是通过硬件实现，效率比锁高</li><li>sync.Mutex 应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值操作，可以使用 atomic.Value，能承载一个 interface0}</li></ul><h3 id="小结">小结</h3><p>避免常见的性能陷阱可以保证大部分程序的性能</p><p>普通应用代码，不要一味地追求程序的性能</p><p>越高级的性能优化手段越容易出现问题</p><p>在满足正确可靠、简洁清晰的质量要求的前提下提高程序性能</p><hr><h1 id="性能调优实战">性能调优实战</h1><h2 id="性能调优简介">性能调优简介</h2><h2 id="性能分析工具pprof实战">性能分析工具pprof实战</h2><h2 id="性能调优案例">性能调优案例</h2>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L2-Go语言工程实践</title>
      <link href="/2024/11/04/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L2-Go%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/11/04/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L2-Go%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="语言进阶">语言进阶</h1><h2 id="goroutine">goroutine</h2><h3 id="如何使用">如何使用</h3><p>只需要在调用的函数或方法前加上<code>go</code>关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>    <span class="comment">//创建一个新的 goroutine 运行函数f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;()          <span class="comment">//匿名函数也支持使用go关键字创建 goroutine 去执行。</span></span><br></pre></td></tr></table></figure><h3 id="启动单个goroutine">启动单个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;你好，世界&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会交替输出这两句话</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411041354126.png" alt=""></p><p>而如果没有加入for循环，重新执行程序后会输出</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好，世界</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>为什么会先打印 <code>你好，世界</code>？因为程序创建一个<code>goroutine</code>执行函数是是要花费时间的，而此时main函数会继续执行下去，所以会先打印下面的那句话，而如果当main函数执行完之后<code>goroutine</code>的创建还没有完成，那就会在打印了你好，世界 后直接退出程序，也就是只有这一句话</p><p>那我们如何做到确保所有的并发结束后才退出程序呢？我们可以使用sync包中的<code>sync.WaitGroup</code>来等待所有并发完成</p><p>下面是示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动多个goroutine">启动多个goroutine</h3><p>启动多个goroutine和单个同理，使用<code>sync.WaitGroup</code>来等待所有并发完成即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>, i)</span><br><span class="line">wg2.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg2.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello2(i)</span><br><span class="line">&#125;</span><br><span class="line">wg2.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现程序输出时 i 是无序的(注意：每次程序的输出都会不一样)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hello world <span class="number">2</span></span><br><span class="line">hello world <span class="number">7</span></span><br><span class="line">hello world <span class="number">8</span></span><br><span class="line">hello world <span class="number">5</span></span><br><span class="line">hello world <span class="number">9</span></span><br><span class="line">hello world <span class="number">6</span></span><br><span class="line">hello world <span class="number">1</span></span><br><span class="line">hello world <span class="number">0</span></span><br><span class="line">hello world <span class="number">4</span></span><br><span class="line">hello world <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这是因为10个 goroutine 是并发的，而 goroutine 的调度是随机的</p><h2 id="channel">channel</h2><h3 id="为什么要用channel">为什么要用channel</h3><p>单纯的函数的并发是没有意义的，函数与函数交换数据才能体现并发执行函数的意义，这一般有内存共享和通信共享两种方式。go语言中采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡通过通信共享内存</p><p>而<code>channel</code>就是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>**Go 语言中的通道（channel）是一种特殊的类型 。**通道像一个传送带或者队列，总是遵循先入先出的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="声明和初始化">声明和初始化</h3><ul><li><strong>声明：</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><ul><li><strong>初始化</strong>：</li></ul><p>声明的chan变量需要用<code>make</code>函数初始化后才能使用，未初始化的chan变量默认为<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)  <span class="comment">// 声明一个缓冲区大小为1的通道</span></span><br></pre></td></tr></table></figure><h3 id="基本操作">基本操作</h3><p>channel有发送，接受，关闭三种操作，发送和接受都使用<code>-&gt;</code>符号</p><ul><li><p><strong>发送</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接收</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></li><li><p><strong>取出所有值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ok判断</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    v, ok := &lt;-ch    <span class="comment">// 从通道接收数据</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;        <span class="comment">// 如果通道已经关闭，退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(v)  <span class="comment">// 打印接收到的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用range</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> <span class="keyword">chan</span>&#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>**注意：**一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p></blockquote><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408201950086.png" alt=""></p><h3 id="无缓冲通道">无缓冲通道</h3><p>如果在初始化时不设置缓冲区，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时 会报错表示 <code>deadlock</code></p><p>这是因为无缓冲区的通道就表示接收值后无法接收其他值而是处于发送状态，只有在发送出之后才能继续接受值。就好比快递员一次只能送一个快递，而快递柜则可以容纳多个快递</p><p>要解决这个问题，就需要在传入channel的同时存在另一个接收者接收，这个接收必须是同步的，所以最好先创建接收者，在向channel中传值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;接收失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> receive(ch)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲通道">有缓冲通道</h3><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="多返回值模式">多返回值模式</h3><p>对一个通道执行接收操作时支持如下多返回值模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;- <span class="keyword">chan</span></span><br></pre></td></tr></table></figure><ul><li><p>value: 从通道中取出的值，如果通道被关闭则返回对应类型的零值</p></li><li><p>ok: 通道ch关闭时返回 false，否则返回 true</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch1</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="依赖管理-go-module">依赖管理(Go Module)</h1><h2 id="go依赖管理演进路线">go依赖管理演进路线</h2><h3 id="gopath">GOPATH</h3><p><strong>特点</strong>：</p><ul><li>项目代码直接依赖 src 下的代码</li><li>使用 go get 下载最新的包到 src 目录下</li></ul><p><strong>弊端</strong>：</p><ul><li>场景：A 和 B依赖于某一 package 的不同版本</li><li>问题：无法实现 package 的多版本控制</li></ul><h3 id="go-vender">Go Vender</h3><p>在项目目录下增加 vendor 文件，所有依赖包副本形式存放在 vender 中</p><p>依赖寻址方式：vendor =&gt; GOPATH</p><p>解决了多个项目需要同一个 package 的问题</p><p><strong>弊端</strong>：</p><p>场景：</p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411041901948.png" style="zoom: 80%;" /><ul><li>无法控制依赖的版本</li><li>更新项目有可能出现依赖冲突，导致编译出错</li></ul><h3 id="go-module">Go Module</h3><ul><li>通过 go.mod 文件管理依赖包版本</li><li>通过 go get/go mod 指令工具管理依赖包</li></ul><h2 id="依赖管理三要素">依赖管理三要素</h2><ol><li>配置文件，描述依赖go.mod</li><li>中心仓库管理依赖库        Proxy</li><li>本地工具                           go get/mod</li></ol><h2 id="依赖配置">依赖配置</h2><h3 id="go-mod">go.mod</h3><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411041913560.png" style="zoom:80%;" /><h3 id="version">version</h3><ul><li><p><strong>语义化版本</strong>：</p><p><code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code></p><p>major是两个不兼容的版本，minor在major下做到前后兼容，patch是修复一些bug</p><p>例子：V1.3.0 V2.3.0</p></li><li><p><strong>基于commit伪版本</strong>：</p><p>每次提交commit，go mod 都会生成伪版本</p></li></ul><h3 id="indirect">indirect</h3><ul><li><strong>定义</strong>：标记为 <code>indirect</code> 的依赖是项目中并不直接引用的库。这些库是通过直接依赖的其他库间接引入的。</li><li><strong>示例</strong>：比如，项目 A 直接依赖库 B，而库 B 又依赖于库 C，当库 C 的版本在项目中被引入时，它会被标记为 <code>indirect</code>。</li></ul><h3 id="incompatible">incompatible</h3><ul><li><strong>定义</strong>：<code>incompatible</code> 是指依赖的版本间存在不兼容的情况，即不同的包依赖于同一目标包的不同版本。这样可能导致运行时错误或程序崩溃。</li><li><strong>示例</strong>：假设库 A 依赖于库 B 的版本 1.0，而库 C 依赖于库 B 的版本 2.0，则会出现不兼容的问题，因为它们无法共存。</li></ul><h2 id="依赖分发">依赖分发</h2><h3 id="回源">回源</h3><p>使用管理版本仓库下载依赖，如 github，SVN等</p><p>但存在问题：无法保证稳定性，可用性，增加第三方压力</p><h3 id="proxy">Proxy</h3><p>代理会缓存已下载的模块，使用后会直接从proxy中拉取依赖，实现了稳定和可靠</p><h3 id="变量-goproxy">变量 GOPROXY</h3><p>GOPROXY=&quot;<a href="https://proxy1.cn">https://proxy1.cn</a>, <a href="https://proxy2.cn">https://proxy2.cn</a> ,direct’<br>服务站点URL列表，“direct”表示源站</p><p>请求依赖时，proxy1请求，在向proxy2请求，最后到源站direct</p><h2 id="工具">工具</h2><h3 id="go-get">go get</h3><p>go get <a href="http://example.org/pkg">example.org/pkg</a> + :</p><p>@update：默认</p><p>@none：删除依赖</p><p>@v1.1.2：tag版本，语义版本</p><p>@23dfdd5：特定的commit</p><p>@master：分支的最新commit</p><h3 id="go-mod">go mod</h3><p><code>go mod init</code>：初始化，创建go.mod文件</p><p><code>go mod download</code>：下载模块到本地缓存</p><p><code>go mod tidy</code>：增加需要的依赖，删除不需要的依赖</p><hr><h1 id="测试">测试</h1><p>Go语言中的测试依赖<code>go test</code>命令，所有测试文件都以 <code>_test.go</code> 结尾</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">格式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">测试函数</td><td style="text-align:center">函数名前缀为Test</td><td style="text-align:center">测试程序的一些逻辑行为是否正确</td></tr><tr><td style="text-align:center">基准函数</td><td style="text-align:center">函数名前缀为Benchmark</td><td style="text-align:center">测试函数的性能</td></tr><tr><td style="text-align:center">示例函数</td><td style="text-align:center">函数名前缀为Example</td><td style="text-align:center">为文档提供示例文档</td></tr></tbody></table><h2 id="单元测试">单元测试</h2><p><strong>规则</strong>：</p><ul><li>所有测试文件以 _test.go 结尾</li><li>func TestXxx(*testing.T)</li><li>初始化逻辑放到 TestMain 中</li></ul><p><strong>例子：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/go-playground/assert&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloTom</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">output := HelloTom()</span><br><span class="line">expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">assert.Equal(t, expectOutput, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411042018171.png" alt=""></p><h3 id="覆盖率">覆盖率</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test --cover</span><br></pre></td></tr></table></figure><p>衡量代码测试水平</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JudgePassLine</span><span class="params">(score <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">isPass := JudgePassLine(<span class="number">60</span>)</span><br><span class="line">assert.Equal(t, <span class="literal">true</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241104202153585.png" alt="image-20241104202153585"></p><p>因为我们的测试函数只经过了2/3的语句，所以显示了66.7%，这个时候我们就可以进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineTrue</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">isPass := JudgePassLine(<span class="number">70</span>)</span><br><span class="line">assert.Equal(t,<span class="literal">true</span>,isPass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineFail</span><span class="params">(t*testing.T)</span></span>&#123;</span><br><span class="line">isPass := JudgePassLine(<span class="number">50</span>)</span><br><span class="line">assert.Equal(t,exected: <span class="literal">false</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般项目中50%-60%</p><h3 id="mock">Mock</h3><p>使测试可以在任何环境下进行，不依赖于本地文件，可以为函数，方法打桩，在最终测试时调用的是打桩函数</p><p><strong>例子：</strong></p><p>现在假设我们有一个处理文本的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">open, err := os.Open(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> open.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">scanner := bufio.NewScanner(open)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line"><span class="keyword">return</span> scanner.Text()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">line := ReadFirstLine()</span><br><span class="line">destLine := strings.ReplaceAll(line, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;00&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> destLine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正常的测试函数是：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessFirstLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">firstLine := ProcessFirstLine()</span><br><span class="line">assert.Equal(t, <span class="string">&quot;line00&quot;</span>, firstLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样存在的问题就是没有这个文件，就无法进行测试，这时候我们就可以在使用mock测试</p><p><strong>mock的测试函数是：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessFirstLineWithMock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">monkey.Patch(ReadFirstLine, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;line110&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> monkey.Unpatch(ReadFirstLine)</span><br><span class="line">line := ProcessFirstLine()</span><br><span class="line">assert.Equal(t, <span class="string">&quot;line000&quot;</span>, line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>Patch()</code> 将一个匿名函数替换掉了原来的函数，测试不再依赖于本地文件，可以在任何时间运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Patch</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;, replacement <span class="keyword">interface</span>&#123;&#125;)</span></span> *PatchGuard  </span><br></pre></td></tr></table></figure><h2 id="基准测试">基准测试</h2><p>用于测试性能，和单元测试类似</p><p>例子：</p><p>随机选择服务器执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServerIndex [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitServerIndex</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ServerIndex[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ServerIndex[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelectParallel</span><span class="params">(b *testing.B)</span></span> &#123; <span class="comment">// 并发测试</span></span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试后发现，并发情况下程序运行时间显著增加，原因是 <code>rand</code> 函数调用时会自动创建锁，从而降低并发速度，对此可使用 <code>fastrand</code> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FastSelect</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ServerIndex[fastrand.Intn(<span class="number">10</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelectFastrandParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">FastSelect()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三者时间对比如下：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411050124266.png" alt=""></p><h2 id="项目实战">项目实战</h2><p>项目具体代码在：<a href="https://github.com/KQLXK/topic_post-backend">KQLXK/topic_post-backend</a></p><p>实现了两个功能：</p><ol><li><p>根据topicid查询topic和相关post</p></li><li><p>在topic下发表post</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[第六届字节青训营]L1-Go语言基础语法</title>
      <link href="/2024/11/02/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L1-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/11/02/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5-L1-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言优势">go语言优势</h1><ol><li>高性能高并发</li><li>语法简单，学习曲线平缓</li><li>丰富的标准库</li><li>完善的工具链</li><li>静态链接</li><li>快速编译</li><li>跨平台</li><li>垃圾回收</li></ol><h1 id="go语言入门">go语言入门</h1><p>之前做过详细笔记([<a href="https://kqlxk.github.io/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Go]基本语法 | YC’s Blog</a>)，不多做赘述，只记一下有点生疏的</p><h2 id="错误处理">错误处理</h2><p>errors包</p><p>在返回值中加一个 <code>err</code> ，可以由 <code>errors.New(&quot;...&quot;)</code> 创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用这个函数后，要先判断<code>err</code>是否为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">users := []user&#123;</span><br><span class="line">&#123;<span class="string">&quot;kqlxk&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;ycccc&quot;</span>, <span class="number">15</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u1, err := findUser(users, <span class="string">&quot;yc&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串操作">字符串操作</h2><p>strings包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    strings.Contains(a, <span class="string">&quot;ll&quot;</span>)<span class="comment">//是否包含某个字符串</span></span><br><span class="line">    strings.Count(a, <span class="string">&quot;l&quot;</span>)<span class="comment">//a中有几个l</span></span><br><span class="line">    strings.HasPrefix(a, <span class="string">&quot;he&quot;</span>)<span class="comment">//a是否以he开头</span></span><br><span class="line">    strings.HasSuffix(a, <span class="string">&quot;llo&quot;</span>)<span class="comment">//a是否以llo结尾</span></span><br><span class="line">    strings.Index(a, <span class="string">&quot;ll&quot;</span>)<span class="comment">//ll的第一个位置</span></span><br><span class="line">    strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>)<span class="comment">//用&quot;-&quot;把切片中的字符串连起来</span></span><br><span class="line">strings.Repeat(a, <span class="number">2</span>)<span class="comment">//返回重复两次的a</span></span><br><span class="line">strings.Replace(a, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">-1</span>)<span class="comment">//将所有e换成E，-1表示所有</span></span><br><span class="line">strings.Split(<span class="string">&quot;a-b-c&quot;</span>, <span class="string">&quot;-&quot;</span>)<span class="comment">//用字符串中的-符号分割字符串</span></span><br><span class="line">strings.ToUpper(a)<span class="comment">//全部大写</span></span><br><span class="line">strings.ToLower(a)<span class="comment">//全部小写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="json处理">JSON处理</h2><p>encoding/json包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">buf, err := json.Marshal(user&#123;<span class="string">&quot;kqlxk&quot;</span>, <span class="number">18</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br><span class="line">buf, err = json.MarshalIndent(user&#123;<span class="string">&quot;kqlxk&quot;</span>, <span class="number">18</span>&#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo user</span><br><span class="line">err = json.Unmarshal(buf, &amp;userinfo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userinfo)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>json.Marshal</code> ：用于将 Go 数据结构（如结构体、切片、字典等）编码为 JSON 格式的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>json.MarshalIndent</code>：用于将数据结构编码为格式化（缩进）JSON</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>json.Unmarshal</code>：用于将json格式的数据反序列化成go语言中的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="时间处理">时间处理</h2><p>time包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">t := time.Date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">21</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">t2 := time.Date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second())</span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">diff := t2.Sub(t)</span><br><span class="line">fmt.Println(diff)</span><br><span class="line">fmt.Println(diff.Minutes(), diff.Hours(), diff.Seconds())</span><br><span class="line">t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2024-11-02 22:14:00&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t3 == t)</span><br><span class="line">fmt.Println(now.Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>time.Now()</code> : 获取当前的本地时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time</span><br></pre></td></tr></table></figure></li><li><p><code>time.Date</code> : 创建指定时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="type">int</span>, month Month, day, hour, min, sec, nsec <span class="type">int</span>, loc *Location)</span></span> Time</span><br></pre></td></tr></table></figure></li><li><p><code>time.Format()</code>：将时间 t 格式化为字符串，传入的是具体格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Format(layout <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure></li><li><p><code>time.sub()</code>：计算 t2 和 t 之间的时间差</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure></li><li><p><code>time.Parse()</code>：将给定的时间字符串解析为 <code>time.Time</code> 对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>now.Unix()</code> ：当前时间的 Unix 时间戳（自 1970 年 1 月 1 日起的秒数）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Unix() <span class="type">int64</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数字解析">数字解析</h2><p>strconv包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(f) <span class="comment">// 1.234</span></span><br><span class="line"></span><br><span class="line">n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line">n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 4096</span></span><br><span class="line"></span><br><span class="line">n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">fmt.Println(n2) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">fmt.Println(n2, err) <span class="comment">// 0 strconv.Atoi: parsing &quot;AAA&quot;: invalid syntax</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>strconv.ParseFloat()</code> ：将字符串转换为 <code>float64</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>strconv.ParseInt()</code> : 将字符串转换为整数, 默认使用十六进制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>strconv.Atoi()</code> : 使用 <code>Atoi</code> 函数直接将字符串转换为整数，默认使用十进制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程信息">进程信息</h2><p>os包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;os&quot;</span>  </span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">// go run example/20-env/main.go a b c d  </span></span><br><span class="line">    fmt.Println(os.Args) <span class="comment">// [/var/folders/8p/n34xxfnx38d98bv_x8162t_m0000gn/T/go-build3406891276/b001/exe/main a b c d]  </span></span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))  </span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;AA&quot;</span>), <span class="string">&quot;BB&quot;</span>)  </span><br><span class="line">    </span><br><span class="line">    buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombinedOutput()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// 127.0.0.1 localhost</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战">实战</h1><h2 id="猜数字游戏">猜数字游戏</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">maxNum := <span class="number">100</span></span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line">r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">num := r.Intn(maxNum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入你猜的数字：&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">input = strings.TrimSuffix(input, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">guessNum, err := strconv.Atoi(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;你猜的数字是：&quot;</span>, guessNum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> guessNum &gt; num &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;猜大了&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> guessNum &lt; num &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;猜小了&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在线词典">在线词典</h2><p>实现一个简单的英文单词查询工具，用过调用彩云小译的api来获取单词的中文翻译</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DictRequest 定义了发送到彩云小译API的请求结构体</span></span><br><span class="line"><span class="keyword">type</span> DictRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">TransType <span class="type">string</span> <span class="string">`json:&quot;trans_type&quot;`</span> <span class="comment">// 翻译类型，这里是从英文到中文</span></span><br><span class="line">Sourse    <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span>      <span class="comment">// 要翻译的源语言文本，这里是英文单词</span></span><br><span class="line">UserID    <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>     <span class="comment">// 用户ID，这里没有使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DictResponse 定义了从彩云小译API返回的响应结构体</span></span><br><span class="line"><span class="keyword">type</span> DictResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Rc   <span class="type">int</span> <span class="string">`json:&quot;rc&quot;`</span>   <span class="comment">// 返回码，表示请求是否成功</span></span><br><span class="line">Wiki <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125; <span class="string">`json:&quot;wiki&quot;`</span> <span class="comment">// 维基百科相关信息，这里没有使用</span></span><br><span class="line">Dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">Prons <span class="keyword">struct</span> &#123;</span><br><span class="line">EnUs <span class="type">string</span> <span class="string">`json:&quot;en-us&quot;`</span> <span class="comment">// 美式英语发音</span></span><br><span class="line">En   <span class="type">string</span> <span class="string">`json:&quot;en&quot;`</span>    <span class="comment">// 英式英语发音</span></span><br><span class="line">&#125; <span class="string">`json:&quot;prons&quot;`</span> <span class="comment">// 发音信息</span></span><br><span class="line">Explanations []<span class="type">string</span>      <span class="string">`json:&quot;explanations&quot;`</span> <span class="comment">// 解释，即单词的中文翻译</span></span><br><span class="line">Synonym      []<span class="type">string</span>      <span class="string">`json:&quot;synonym&quot;`</span>      <span class="comment">// 同义词</span></span><br><span class="line">Antonym      []<span class="type">string</span>      <span class="string">`json:&quot;antonym&quot;`</span>      <span class="comment">// 反义词</span></span><br><span class="line">WqxExample   [][]<span class="type">string</span>    <span class="string">`json:&quot;wqx_example&quot;`</span>  <span class="comment">// 例句</span></span><br><span class="line">Entry        <span class="type">string</span>        <span class="string">`json:&quot;entry&quot;`</span>        <span class="comment">// 词条</span></span><br><span class="line">Type         <span class="type">string</span>        <span class="string">`json:&quot;type&quot;`</span>         <span class="comment">// 类型</span></span><br><span class="line">Related      []<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;related&quot;`</span>      <span class="comment">// 相关词汇</span></span><br><span class="line">Source       <span class="type">string</span>        <span class="string">`json:&quot;source&quot;`</span>       <span class="comment">// 来源</span></span><br><span class="line">&#125; <span class="string">`json:&quot;dictionary&quot;`</span> <span class="comment">// 词典信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// query 函数用于向彩云小译API发送请求，查询单词的翻译和相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(word <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">request := DictRequest&#123;TransType: <span class="string">&quot;en2zh&quot;</span>, Sourse: word&#125;</span><br><span class="line">buf, err := json.Marshal(request)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;application/json, text/plain, */*&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;accept-language&quot;</span>, <span class="string">&quot;zh&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;app-name&quot;</span>, <span class="string">&quot;xiaoyi&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;authorization&quot;</span>, <span class="string">&quot;bearer&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;device-id&quot;</span>, <span class="string">&quot;7b52fb2996701068b59c76be472b757b&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;origin&quot;</span>, <span class="string">&quot;https://fanyi.caiyunapp.com&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;os-type&quot;</span>, <span class="string">&quot;web&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;os-version&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;priority&quot;</span>, <span class="string">&quot;u=1, i&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;referer&quot;</span>, <span class="string">&quot;https://fanyi.caiyunapp.com/&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-ch-ua&quot;</span>, <span class="string">`&quot;Chromium&quot;;v=&quot;130&quot;, &quot;Microsoft Edge&quot;;v=&quot;130&quot;, &quot;Not?A_Brand&quot;;v=&quot;99&quot;`</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-ch-ua-mobile&quot;</span>, <span class="string">&quot;?0&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-ch-ua-platform&quot;</span>, <span class="string">`&quot;Windows&quot;`</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-fetch-dest&quot;</span>, <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-fetch-mode&quot;</span>, <span class="string">&quot;cors&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;sec-fetch-site&quot;</span>, <span class="string">&quot;cross-site&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;x-authorization&quot;</span>, <span class="string">&quot;token:qgemv4jr1y38jyq6vhvi&quot;</span>)</span><br><span class="line">resp, err := client.Do(req)                     <span class="comment">//发送请求到api并接受返回的响应</span></span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">bodyText, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dictResponse DictResponse</span><br><span class="line">err = json.Unmarshal(bodyText, &amp;dictResponse)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;%#v\n&quot;, dictResponse)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;good&quot;</span>, <span class="string">&quot;UK:&quot;</span>, dictResponse.Dictionary.Prons.En, <span class="string">&quot;US:&quot;</span>, dictResponse.Dictionary.Prons.EnUs)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">fmt.Println(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数是程序的入口点，它解析命令行参数并调用 query 函数查询单词</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args)!= <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">`usage: simpleDict WORD example: simpleDict hello`</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">word := os.Args[<span class="number">1</span>]</span><br><span class="line">    query(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先我们要从浏览器中获得我们请求头的一些参数，在使用一次翻译后找到dict包，复制其curl并用代码生成工具 (<a href="https://curlconverter.com/">Convert curl commands to code</a>) 直接转化成代码这样生成的代码是静态的，只支持固定的单词查询</li><li>之后我们要自己设计发送请求和接收响应的结构体，就需要用到另一个可以把json格式数据直接转换成对应的结构体的网站(<a href="https://oktools.iokde.com/json2go">JSON转Golang Struct - 在线工具 - OKTools</a>)</li><li>完成之后，就大致可以使用了</li></ol><h2 id="socks5代理服务器">socks5代理服务器</h2><h3 id="原理">原理</h3><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202411072354605.png" style="zoom: 80%;" /><h3 id="实现">实现</h3><p><strong>协商阶段</strong>:</p><p>使用 <code>auth</code> 函数实现。该函数实现了版本和认证方法的协商。客户端首先发送协议版本和可用的方法，服务器响应未使用任何认证的方法。</p><p>整体来说这个函数做的事就是从客户端发来的数据流中读取到<strong>版本号</strong>，<strong>支持认证的方法数量</strong>，<strong>具体的方法</strong>这三个东西，前两个大小就是一个字节，所以用 <code>reader.ReadByte()</code> 方法，第三个可能由多个字节，所以创建了一个切片，用 <code>io.ReadFull()</code> 方法。最后，服务端用 <code>conn.Write()</code> 方法返回一个响应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// |VER | NMETHODS | METHODS  |</span></span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// | 1  |    1     | 1 to 255 |</span></span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// VER: 协议版本，socks5为0x05</span></span><br><span class="line"><span class="comment">// NMETHODS: 支持认证的方法数量</span></span><br><span class="line"><span class="comment">// METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:</span></span><br><span class="line"><span class="comment">// X’00’ NO AUTHENTICATION REQUIRED</span></span><br><span class="line"><span class="comment">// X’02’ USERNAME/PASSWORD</span></span><br><span class="line"></span><br><span class="line">ver, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;ver not support: %v&quot;</span>, ver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodSize, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodsize failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">_, err = io.ReadFull(reader, method)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;ver:&quot;</span>, ver, <span class="string">&quot;method:&quot;</span>, method)</span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送请求</strong>:</p><ul><li><p>2.1 建立TCP连接</p><p>对应代码中的 <code>connect</code> 函数开头部分。这里解析客户端的连接请求并将其转发至目标主机。</p><p>请求数据流比协商数据流多了几个字段，代理服务器要依次读取出，读取方法和 <code>auth</code> 函数类似，在读取完之后 用<code>net.Dial()</code>方法建立连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// VER 版本号，socks5的值为0x05</span></span><br><span class="line"><span class="comment">// CMD 0x01表示CONNECT请求，表示代理服务器和下游服务器创建链接</span></span><br><span class="line"><span class="comment">// RSV 保留字段，值为0x00</span></span><br><span class="line"><span class="comment">// ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。</span></span><br><span class="line"><span class="comment">//   0x01表示IPv4地址，DST.ADDR为4个字节</span></span><br><span class="line"><span class="comment">//   0x03表示域名，DST.ADDR是一个可变长度的域名</span></span><br><span class="line"><span class="comment">// DST.ADDR 一个可变长度的值</span></span><br><span class="line"><span class="comment">// DST.PORT 目标端口，固定2个字节</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//接下来要做的就是把这六个字段从字节流中读出来</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">//读取头部信息</span></span><br><span class="line">_, err = io.ReadFull(reader, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read header failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ver, cmd, atyp := buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;ver not support: %v&quot;</span>, ver)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cmd != cmdBind &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cmd not support: %v&quot;</span>, cmd)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//读取目标地址</span></span><br><span class="line">addr := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">switch</span> atyp &#123;</span><br><span class="line"><span class="keyword">case</span> atyIPV4:</span><br><span class="line">_, err = io.ReadFull(reader, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read atyp failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">addr = fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">case</span> atypeHOST:</span><br><span class="line">hostSize, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read hostSize failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">host := <span class="built_in">make</span>([]<span class="type">byte</span>, hostSize)</span><br><span class="line">_, err = io.ReadFull(reader, host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read host failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">addr = <span class="type">string</span>(host)</span><br><span class="line"><span class="keyword">case</span> atypeIPV6:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;ipv6 not support&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;invalid atyp&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">////读取端口号</span></span><br><span class="line">_, err = io.ReadFull(reader, buf[:<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read port failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">port := binary.BigEndian.Uint16(buf[:<span class="number">2</span>]) <span class="comment">// 大端序</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//连接下游服务器</span></span><br><span class="line">dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;dial failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dest.Close()</span><br></pre></td></tr></table></figure></li><li><p>2.2 返回响应</p><p>在 <code>connect</code> 函数中，建立连接后，会发送成功的响应到客户端，比如 <code>0x05, 0x00</code> 表示连接成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = conn.Write([]<span class="type">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>2.3 返回状态</p><p>这个部分表示连接建立的状态，会在成功建立连接后通过响应返回。</p></li></ul><p><strong>发送数据</strong>:</p><ul><li><p>3.1 relay数据</p><p>对应代码中的两个 goroutine，分别负责将从客户端读取的数据写入目标服务器（<code>io.Copy(dest, reader)</code>）和将从目标服务器读取的数据写入客户端（<code>io.Copy(conn, dest)</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(dest, reader)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(conn, dest)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li><li><ol start="3"><li>2 结果</li></ol><p>当数据交换完成，连接就可以关闭。在代码中通过取消上下文 (<code>cancel()</code>) 来结束数据转输流。</p></li></ul><p><strong>代码</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">socks5Ver = <span class="number">0x05</span></span><br><span class="line">cmdBind   = <span class="number">0x01</span></span><br><span class="line">atyIPV4   = <span class="number">0x01</span></span><br><span class="line">atypeHOST = <span class="number">0x03</span></span><br><span class="line">atypeIPV6 = <span class="number">0x04</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Server started, listening on 127.0.0.1:9000&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">client, err := server.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Accept failed, Err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(client)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line">err := auth(reader, conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = connect(reader, conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// |VER | NMETHODS | METHODS  |</span></span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// | 1  |    1     | 1 to 255 |</span></span><br><span class="line"><span class="comment">// +----+----------+----------+</span></span><br><span class="line"><span class="comment">// VER: 协议版本，socks5为0x05</span></span><br><span class="line"><span class="comment">// NMETHODS: 支持认证的方法数量</span></span><br><span class="line"><span class="comment">// METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:</span></span><br><span class="line"><span class="comment">// X’00’ NO AUTHENTICATION REQUIRED</span></span><br><span class="line"><span class="comment">// X’02’ USERNAME/PASSWORD</span></span><br><span class="line"></span><br><span class="line">ver, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;ver not support: %v&quot;</span>, ver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodSize, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodsize failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">_, err = io.ReadFull(reader, method)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;ver:&quot;</span>, ver, <span class="string">&quot;method:&quot;</span>, method)</span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析客户端发送的连接请求，验证请求的版本号和命令类型，</span></span><br><span class="line"><span class="comment">// 解析目标地址和端口，并向客户端发送响应表示连接成功。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line"><span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">// VER 版本号，socks5的值为0x05</span></span><br><span class="line"><span class="comment">// CMD 0x01表示CONNECT请求，表示代理服务器和下游服务器创建链接</span></span><br><span class="line"><span class="comment">// RSV 保留字段，值为0x00</span></span><br><span class="line"><span class="comment">// ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。</span></span><br><span class="line"><span class="comment">//   0x01表示IPv4地址，DST.ADDR为4个字节</span></span><br><span class="line"><span class="comment">//   0x03表示域名，DST.ADDR是一个可变长度的域名</span></span><br><span class="line"><span class="comment">// DST.ADDR 一个可变长度的值</span></span><br><span class="line"><span class="comment">// DST.PORT 目标端口，固定2个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来要做的就是把这六个字段从字节流中读出来</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">//读取头部信息</span></span><br><span class="line">_, err = io.ReadFull(reader, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read header failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ver, cmd, atyp := buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;ver not support: %v&quot;</span>, ver)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cmd != cmdBind &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cmd not support: %v&quot;</span>, cmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取目标地址</span></span><br><span class="line">addr := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">switch</span> atyp &#123;</span><br><span class="line"><span class="keyword">case</span> atyIPV4:</span><br><span class="line">_, err = io.ReadFull(reader, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read atyp failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">addr = fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">case</span> atypeHOST:</span><br><span class="line">hostSize, err := reader.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read hostSize failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">host := <span class="built_in">make</span>([]<span class="type">byte</span>, hostSize)</span><br><span class="line">_, err = io.ReadFull(reader, host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read host failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">addr = <span class="type">string</span>(host)</span><br><span class="line"><span class="keyword">case</span> atypeIPV6:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;ipv6 not support&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;invalid atyp&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////读取端口号</span></span><br><span class="line">_, err = io.ReadFull(reader, buf[:<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read port failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">port := binary.BigEndian.Uint16(buf[:<span class="number">2</span>]) <span class="comment">// 大端序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接下游服务器</span></span><br><span class="line">dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;dial failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dest.Close()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;dial&quot;</span>, addr, port)</span><br><span class="line"></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接后，需要启动两个goroutine,</span></span><br><span class="line"><span class="comment">//一个goroutine负责从客户端读取数据并写入下游服务器，</span></span><br><span class="line"><span class="comment">//另一个goroutine负责从下游服务器读取数据并写入客户端。</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(dest, reader)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(conn, dest)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 青训营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc</title>
      <link href="/2024/10/26/grpc/"/>
      <url>/2024/10/26/grpc/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置">环境配置</h1><ul><li><p>安装protobuf：</p><p><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf</a></p></li><li><p>安装grpc：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure></li><li><p>安装go语言插件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/<span class="built_in">cmd</span>/protoc-gen-go@latest</span><br></pre></td></tr></table></figure></li><li><p>安装grpc插件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/grpc/<span class="built_in">cmd</span>/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> grpc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2024/10/21/JWT/"/>
      <url>/2024/10/21/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是jwt">什么是JWT</h1><p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token 实现方式，目前多用于前后端分离项目和 OAuth2.0 业务场景下。</p><h1 id="jwt原理">JWT原理</h1><p>服务器认证后，生成一个如下的JSON对象</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再由JSON对象生成如下签名，返回给客户端，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJOYW1lIjoieWMiLCJBZ2UiOjE4LCJleHAiOjE3MzAyNzk1ODUsIm5iZiI6MTczMDI3NTk4NSwiaWF0IjoxNzMwMjc1OTg1fQ.CSzwT3CuFhASXII1ssfpUFSVK3VgWeAPydOAsUDGd0M</span><br></pre></td></tr></table></figure><p>对于 <code>HMAC</code> (对称加密算法) ，生成签名需要一个 <code>key</code> (密钥) 和一个 <code>SigningMethod</code> (签名算法)</p><p>对于 <code>RSA</code> (非对称加密算法)，需要 <code>private key</code>，<code>public key</code>，<code>SigningMethod</code></p><p>之后每次客户端和服务器的通信都要发回这个签名，服务器通过这个签名认定用户身份</p><h1 id="jwt数据结构">JWT数据结构</h1><p>包括三个部分：header，payload，signnature，中间用点连接</p><p>具体就是这样</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202410311546998.jpeg" alt=""></p><p>接下来介绍这三个部分分别代表哪些信息</p><h2 id="header">Header</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line"><span class="string">&quot;alg&quot;</span>: method.Alg(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>typ</code> ：表示这个令牌的类型</li><li><code>alg</code> ：表示签名用的算法，在这里调用的是 <code>token</code> 中的 <code>method</code></li></ul><h2 id="payload">Payload</h2><p>默认包含以下七个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><p>也可以自己加字段</p><h2 id="signature">Signature</h2><p>signature是对于前两部分的签名，防止数据篡改</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释</span><br><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（<code>.</code>）分隔，就可以返回给用户。</p><h1 id="go语言中使用jwt">go语言中使用JWT</h1><h2 id="生成jwt">生成JWT</h2><p>JWT的令牌就是由 <code>jwt</code> 库中的 <code>token</code> 结构体经过算法加密得出的</p><p>先看一下jwt库中<code>token</code>结构体的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span> &#123;</span><br><span class="line">Raw       <span class="type">string</span>                 <span class="comment">// The raw token.  Populated when you Parse  a token</span></span><br><span class="line">Method    SigningMethod          <span class="comment">// The signing method used or to be used</span></span><br><span class="line">Header    <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// The first segment of the token</span></span><br><span class="line">Claims    Claims                 <span class="comment">// The second segment of the token</span></span><br><span class="line">Signature <span class="type">string</span>                 <span class="comment">// The third segment of the token.  Populated when you Parse a token</span></span><br><span class="line">Valid     <span class="type">bool</span>                   <span class="comment">// Is the token valid?  Populated when you Parse/Verify a token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Header</strong>：<code>token</code> 中的 <code>Header</code> 是一个 <code>map[string]interface&#123;&#125;</code>，会转换成 JSON 格式之后再有<code>base64</code>编码后存在 JWT 的 Header 中</p></li><li><p><strong>Payload</strong>：一般来说，Payload是由 <code>token</code> 结构体中的 <code>claim</code> 生成的，<code>claim</code>中会包含我们自己定义的字段和一个<code>jwt</code>库中的 <code>jwt.RegisteredClaims</code> 结构体，将 <code>Claims</code> 进行 <code>base64</code> 编码后存在 JWT的 Payload 中</p></li><li><p><strong>Signature</strong>：将Header和Payload中的字符串由 <code>t.Method.Sign()</code> 方法生成</p></li></ul><p>下面是生成一个JWT的go语言代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Myclaims&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myclaims := Myclaims&#123;</span><br><span class="line">    Name: <span class="string">&quot;yc&quot;</span>,</span><br><span class="line">    Age: <span class="number">18</span>,</span><br><span class="line">    RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">        ExpiredAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),</span><br><span class="line">        NotBefore: jwt.NewNumericDate(time.Now()),</span><br><span class="line">        IssuedAt: jwt.NewNumericDate(time.Now()),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SecretKey <span class="type">string</span> = <span class="string">&quot;111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(claim jwt.Claims)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    token := jwt.NewWithClaims(jwt.SigningMeyhodHS256, claims)</span><br><span class="line">    </span><br><span class="line">    sign, err := token.SignedString([]<span class="type">byte</span>(SecretKey))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span> sign, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign, <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    myclaims := Myclaims&#123;</span><br><span class="line">    Name: <span class="string">&quot;yc&quot;</span>,</span><br><span class="line">    Age: <span class="number">18</span>,</span><br><span class="line">    RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">        ExpiredAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),</span><br><span class="line">        NotBefore: jwt.NewNumericDate(time.Now()),</span><br><span class="line">        IssuedAt: jwt.NewNumericDate(time.Now()),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    sign, err := Encode(myClaims)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>jwt.NewWithClaims</code> ：使用传入的 <code>claims</code> 生成一个<code>token</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWithClaims</span><span class="params">(method SigningMethod, claims Claims)</span></span> *Token</span><br></pre></td></tr></table></figure></li><li><p><code>token.SignedString</code> ：用密钥生成签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Token)</span></span> SignedString(key <span class="keyword">interface</span>&#123;&#125;) (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：改变key只会改变第三部分Signature的值</p></blockquote></li></ul><h2 id="解析jwt">解析JWT</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseToken 解析JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="type">string</span>)</span></span> (*CustomClaims, <span class="type">error</span>) &#123;</span><br><span class="line">token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (i <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> CustomSecret, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对token对象中的Claim进行类型断言</span></span><br><span class="line"><span class="keyword">if</span> claims, ok := token.Claims.(*CustomClaims); ok &amp;&amp; token.Valid &#123; <span class="comment">// 校验token</span></span><br><span class="line"><span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jwt.Parse</code>：直接使用标准的Claim则可以直接使用Parse方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(tokenString <span class="type">string</span>, keyFunc Keyfunc)</span></span> (*Token, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>jwt.ParseWithClaims</code>：如果是自定义Claim结构体则需要使用 ParseWithClaims 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseWithClaims</span><span class="params">(tokenString <span class="type">string</span>, claims Claims, keyFunc keyFunc)</span></span> (*Token, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>keyFunc</code> ：根据具体业务逻辑返回相应的密钥，用于验证签名</p>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]GORM使用</title>
      <link href="/2024/10/11/Go-GORM%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/11/Go-GORM%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gorm.io/zh_CN/">中文文档</a></p><h1 id="基本的gorm示例">基本的GORM示例</h1><h2 id="安装">安装</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure><p>也可以是<code>mysql</code>，<code>sqlsever</code>，<code>postgres</code></p><h2 id="demo">demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line">dsn := <span class="string">&quot;root:yuchao123@tcp(127.0.0.1:3306)/work?charset=utf8mb4&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动创建数据库表来匹配User结构体</span></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//create</span></span><br><span class="line">db.Create(&amp;User&#123;Name: <span class="string">&quot;yc&quot;</span>, Age: <span class="number">15</span>&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>&amp;gorm.Config&#123;&#125;</code>：是GORM中用于配置数据库连接的结构体，允许你在打开数据库时自定义一些选项</p></li><li><p><code>db.AutoMigrate</code>：自动创建于该结构体匹配的数据表，如果表已存在且与结构体字段不匹配，则会更新字段。但是不会删除。</p></li><li><p><code>gorm.Model</code>：是GORM自带的结构体，里面包含了<code>ID</code>，<code>CreateAt</code>，<code>UpdateAt</code>， <code>DeleteAt</code> 四个参数，用来记录数据的主键，创建时间，修改时间，删除时间(GORM删除数据时不会直接删除，而是将删除时间设置)</p><blockquote><p>如果创建时间与实际时间不符，有可能是数据库时区不对，只需在dsn中加上 <code>parseTime=true&amp;loc=Local</code></p></blockquote></li></ul><h1 id="crud">CRUD</h1><h2 id="创建">创建</h2><h3 id="创建记录">创建记录</h3><p>使用 <code>Create()</code> 创建记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Create(value <span class="keyword">interface</span>&#123;&#125;) (tx *DB)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Create(&amp;User&#123;Name: <span class="string">&quot;yc&quot;</span>, Age: <span class="number">15</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以创建多条记录</span></span><br><span class="line">db.Create([]*User&#123;</span><br><span class="line">    &#123;Name:<span class="string">&quot;yc&quot;</span>, Age:<span class="number">10</span>&#125;,</span><br><span class="line">    &#123;Name:<span class="string">&quot;ycc&quot;</span>, Age:<span class="number">11</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用指定字段创建">使用指定字段创建</h3><p>为指定字段赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;User)</span><br></pre></td></tr></table></figure><p>忽略指定字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;User) <span class="comment">//会忽略User中name和age的值来创建记录</span></span><br></pre></td></tr></table></figure><h3 id="使用map创建">使用map创建</h3><p>GORM支持使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]map[string]interface&#123;&#125;</code> 来创建记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch insert from `[]map[string]interface&#123;&#125;&#123;&#125;`</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>使用map创建不会执行钩子方法，关联不会被保存且不会写回主键</p></blockquote><h3 id="创建记录时使用sql表达式">创建记录时使用sql表达式</h3><p>需要使用map创建记录才能使用sql语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span> : <span class="string">&quot;sql&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Location&quot;</span>: clause.Expr&#123;SQL: <span class="string">&quot;ST_PointFromText(?)&quot;</span>, Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;POINT(100     100)&quot;</span>&#125;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>clause.Expr</code> ：是一个结构体，用于表示sql表达式及其参数这一特性使得在构建复杂 SQL 查询时，可以直接使用一些特定的 SQL 函数、操作符或其他表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">struct</span> &#123;</span><br><span class="line">SQL                <span class="type">string</span></span><br><span class="line">Vars               []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">WithoutParentheses <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>db.Model</code> ：用于指定模型对像即数据库表，在这里表示对User表进行操作</p></li></ul><p>也可以使用自定义数据类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create from customized data type</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan implements the sql.Scanner interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc *Location)</span></span> Scan(v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// Scan a value into struct from database driver</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormDataType() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;geometry&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormValue(ctx context.Context, db *gorm.DB) clause.Expr &#123;</span><br><span class="line">  <span class="keyword">return</span> clause.Expr&#123;</span><br><span class="line">    SQL:  <span class="string">&quot;ST_PointFromText(?)&quot;</span>,</span><br><span class="line">    Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;fmt.Sprintf(<span class="string">&quot;POINT(%d %d)&quot;</span>, loc.X, loc.Y)&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Location Location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User&#123;</span><br><span class="line">  Name:     <span class="string">&quot;jinzhu&quot;</span>,</span><br><span class="line">  Location: Location&#123;X: <span class="number">100</span>, Y: <span class="number">100</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES (&quot;jinzhu&quot;,ST_PointFromText(&quot;POINT(100 100)&quot;))</span></span><br></pre></td></tr></table></figure><p>此方法自定义了结构体Location，实现了Scan，GormDataType，GormValue三个方法，GORM会在创建时自动调用这三个方法(自动实现函数名)，其中</p><ul><li><code>Scan</code> 方法允许 GORM 将从数据库中读取到的地理数据转换为 <code>Location</code> 类型。具体实现未提供，可以根据需要解析数据库返回的地理数据。</li><li><code>GormDataType</code> 方法指定了 <code>Location</code> 在数据库中的数据类型为 <code>geometry</code>。</li><li><code>GormValue</code> 方法构建 SQL 表达式，生成用于插入的 WKT 表达式。</li></ul><h3 id="关联创建">关联创建</h3><p>关联创建时，如果关联值非零，这些关联会被upsert，并且他们的<code>Hooks</code> 方法也会被调用，如果不需要更新关联制，可以用 <code>Omit()</code> 方法忽略掉不需要的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Number <span class="type">string</span></span><br><span class="line">UserID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">UserID     <span class="type">int</span></span><br><span class="line">CreditCard CreditCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">dsn := <span class="string">&quot;root:yuchao123@tcp(127.0.0.1:3306)/work?charset=utf8mb4&amp;parseTime=true&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line">db.Omit(<span class="string">&quot;CreditCard&quot;</span>).Create(&amp;User&#123;UserID: <span class="number">1012</span>, CreditCard: CreditCard&#123;Number: <span class="string">&quot;1016&quot;</span>, UserID: <span class="number">1012</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认值">默认值</h3><p>tag定义字段的默认值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name <span class="type">string</span> <span class="string">`gorm:&quot;default:&#x27;KQLXK&#x27;&quot;`</span></span><br><span class="line">Age  <span class="type">int</span> <span class="string">`gorm:&quot;default:10&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询">查询</h2><p>一般来说没有字段名的都是对主键进行的操作</p><h3 id="一般查询">一般查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机获取一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询最后一条记录</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有的记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure><h3 id="where条件">where条件</h3><p><strong>普通sql查询</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&gt;</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN (?)&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name in (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><p><strong>struct/map查询</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主键的切片</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><h3 id="not条件">not条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="or条件">or条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(*User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * from user where role = &#x27;admin&#x27; or role = &#x27;super_admin&#x27;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name&quot;</span> = <span class="string">&quot;KQLXK&quot;</span>).Or(User&#123;Name: <span class="string">&quot;KQLXK2&quot;</span>&#125;).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//select * from user where name =&#x27;KQLXK&#x27; or name = &#x27;KQLXK2&#x27;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name&quot;</span> = <span class="string">&quot;KQLXK&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;KQLXK2&quot;</span>&#125;).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//select * from user where name =&#x27;KQLXK&#x27; or name = &#x27;KQLXK2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="内联条件">内联条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据主键获取记录 (只适用于整形主键)</span></span><br><span class="line">db.First(&amp;user, <span class="number">23</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class="line"><span class="comment">// 根据主键获取记录, 如果它是一个非整形主键</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h3 id="子查询">子查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; ?&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>).Where(<span class="string">&quot;state = ?&quot;</span>, <span class="string">&quot;paid&quot;</span>).SubQuery()).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot;  WHERE &quot;orders&quot;.&quot;deleted_at&quot; IS NULL AND (amount &gt; (SELECT AVG(amount) FRO&quot; where(state = &#x27;paid&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="更新">更新</h2><h3 id="更新所有字段">更新所有字段</h3><p><code>Save()</code>默认会更新该对象的所有字段，即使你没有赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">user.Age = <span class="number">99</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">////  UPDATE `users` SET `created_at` = &#x27;2020-02-16 12:52:20&#x27;, `updated_at` = &#x27;2020-02-16 12:54:55&#x27;, `deleted_at` = NULL, `name` = &#x27;七米&#x27;, `age` = 99, `active` = true  WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1</span></span><br></pre></td></tr></table></figure><h3 id="更新修改字段">更新修改字段</h3><p>如果你只希望更新指定字段，可以使用<code>Update</code>或者<code>Updates</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">// 更新单个属性，如果它有变化</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的条件更新单个属性</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 map 更新多个属性，只会更新其中有变化的属性</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span></span><br><span class="line"><span class="comment">// 对于下面的操作，不会发生任何更新，&quot;&quot;, 0, false 都是其类型的零值</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">0</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新选定字段">更新选定字段</h3><p>如果你想更新或忽略某些字段，你可以使用 <code>Select</code>，<code>Omit</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><h3 id="删除记录">删除记录</h3><p><strong>警告</strong> 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">// 删除现有记录</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:delete_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure><h3 id="批量删除">批量删除</h3><p>删除全部匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="软删除">软删除</h3><p>如果一个 model 有 <code>DeletedAt</code> 字段，他将自动获得软删除的功能！ 当调用 <code>Delete</code> 方法时， 记录不会真正的从数据库中被删除， 只会将<code>DeletedAt</code> 字段的值会被设置为当前时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询记录时会忽略被软删除的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unscoped 方法可以查询被软删除的记录</span></span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h3 id="物理删除">物理删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unscoped 方法可以物理删除记录</span></span><br><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line"><span class="comment">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure><h1 id="none">…</h1><h2 id="gorm处理指针">gorm处理指针</h2><p>当我们在结构体中定义了一个指针类型的字段并让gorm存储时，gorm会把值存入数据库中而不是指针，在查询时会把值相应的地址存在相应字段中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;time&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;gorm.io/driver/mysql&quot;</span>  </span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Comment <span class="keyword">struct</span> &#123;  </span><br><span class="line">    CommentId  <span class="type">int64</span>     <span class="string">`json:&quot;comment_id&quot;`</span>  </span><br><span class="line">    ArticleId  <span class="type">int64</span>     <span class="string">`json:&quot;article_id&quot;`</span>  </span><br><span class="line">    UserId     <span class="type">int64</span>     <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">    Content    <span class="type">string</span>    <span class="string">`json:&quot;content&quot;`</span>  </span><br><span class="line">    ParentId   *<span class="type">int64</span>    <span class="string">`json:&quot;parent_id&quot;`</span> <span class="comment">// 指针类型  </span></span><br><span class="line">    CreateTime time.Time  <span class="string">`json:&quot;create_time&quot;`</span>  </span><br><span class="line">    Status     <span class="type">string</span>     <span class="string">`json:&quot;status&quot;`</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    dsn := <span class="string">&quot;user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>  </span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;failed to connect to database&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询评论  </span></span><br><span class="line">    <span class="keyword">var</span> comment Comment  </span><br><span class="line">    result := db.First(&amp;comment, <span class="number">1</span>) <span class="comment">// 根据 ID 查询  </span></span><br><span class="line">    <span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(result.Error)  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 ParentId 的内存地址和实际值  </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ParentId memory address: %v\n&quot;</span>, comment.ParentId)  </span><br><span class="line">    <span class="keyword">if</span> comment.ParentId != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Printf(<span class="string">&quot;ParentId value: %d\n&quot;</span>, *comment.ParentId) <span class="comment">// 解引用以获取值  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;ParentId is nil&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> GORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前端]HTML入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-HTML%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-HTML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="html基本概念">HTML基本概念</h1><p>HTML 是用来描述网页的一种语言。</p><p>一个完整的html文件必须包括文档声明，html，head，body标签</p><p>最简单的HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        welcome!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html标签">HTML标签</h2><p>HTML基本元素由 <code>&lt;&gt;</code> 包裹，比如</p><ul><li><code>&lt;html&gt;</code>: 表示一个HTML文档的开始和结束。</li><li><code>&lt;head&gt;</code>: 包含文档的元信息，如标题和链接。</li><li><code>&lt;title&gt;</code>: 定义文档的标题。</li><li><code>&lt;body&gt;</code>: 包含网页的可见内容，如文本、图像、链接等。</li></ul><h2 id="html元素">HTML元素</h2><p>一个开始标签和结束标签包含了内容组成了一个元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="html属性">HTML属性</h2><p>HTML的每个标签都有自己的属性</p><p>常见的属性有：</p><ol><li><p><strong><code>id</code></strong>:</p><p>用于唯一标识一个元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;main-title&quot;</span>&gt;</span>欢迎来到我的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>class</code></strong>:用于指定一个或多个类名，可用于CSS样式和JavaScript操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>这是一个突出显示的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>style</code></strong>:</p><p>用于直接为HTML元素设定内联样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>这是一个红色的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>title</code></strong>:</p><p>提供关于元素的额外信息，当鼠标悬停在元素上时显示该信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一张图片&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>href</code></strong>:</p><p>用于定义超链接的目标网址，常用于<code>&lt;a&gt;</code>（链接）标签中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>src</code></strong>:</p><p>用于指定图像、脚本或框架的源路径，常用于<code>&lt;img&gt;</code>和<code>&lt;script&gt;</code>标签中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;网站logo&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>name</code></strong>:</p><p>在 <code>&lt;input&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;select&gt;</code> 等表单元素中使用，定义元素的名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>type</code></strong>:</p><p>指定表单元素的类型（如 <code>text</code>, <code>password</code>, <code>submit</code>）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="html常用标签">HTML常用标签</h1><h2 id="标题">标题</h2><p><code>h1-h6</code>表示六级标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水平线">水平线</h2><p><code>&lt;hr&gt;</code>表示创建水平线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释">注释</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ....  --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="段落">段落</h2><p><code>&lt;p&gt;</code> 表示段落</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="换行">换行</h2><p><code>&lt;br&gt;</code>  标签表示换行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个<span class="tag">&lt;<span class="name">br</span>&gt;</span>段落<span class="tag">&lt;<span class="name">br</span>&gt;</span>演示了分行的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文本处理">文本处理</h2><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-b.html"><b></a></td><td style="text-align:left">定义粗体文本</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-em.html"><em></a></td><td style="text-align:left">定义着重文字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-i.html"><i></a></td><td style="text-align:left">定义斜体字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-small.html"><small></a></td><td style="text-align:left">定义小号字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-strong.html"><strong></a></td><td style="text-align:left">定义加重语气</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-sub.html"><sub></a></td><td style="text-align:left">定义下标字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/html/m/tags/tag-sup.html"><sup></a></td><td style="text-align:left">定义上标字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-ins.html"><ins></a></td><td style="text-align:left">定义插入字</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/tags/tag-del.html"><del></a></td><td style="text-align:left">定义删除字</td></tr></tbody></table><h2 id="头部-head">头部(head)</h2><p><code>&lt;head&gt;</code> 标签里可以包含多个标签，表示不同的含义</p><ol><li><p><code>&lt;meta&gt;</code> 标签</p><p>提供文档的信息比如字符集，作者，关键词等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;base&gt;</code> 标签</p><p>文档里的相对链接的基本URL，接下来文档对此URL的调用可以省略不写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;title&gt;</code> 标签</p><p>网页标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;link&gt;</code> 标签</p><p>链接外部资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span> <span class="comment">&lt;!-- 链接CSS样式表 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span> <span class="comment">&lt;!-- 页面图标 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;style&gt;</code> 标签</p><p>用于包含内联CSS样式。通常不推荐在构建大型项目时使用，但适合小型项目或快速测试。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css">  </span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;  </span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: lightblue;  </span></span><br><span class="line"><span class="language-css">    &#125;  </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="图像">图像</h2><p><code>&lt;img&gt;</code> 标签创建图像，<code>src</code> 属性表示图片源地址，<code>alt</code> 属性表示替换图片的文字，在浏览器无法加载出图片时用这些信息代替，<code>width</code>，<code>height</code>用来设置图片大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;boad.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Big Goat&quot;</span> <span class="attr">width</span>=<span class="string">&quot;334&quot;</span> <span class="attr">height</span>=<span class="string">&quot;228&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="链接">链接</h2><p><code>&lt;a&gt;</code> 用于创建链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://kqlxk.github.io&quot;</span>&gt;</span>YC&#x27;s Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这行代码的效果就是 <a href="https://kqlxk.github.io">YC’s Blog</a></p><h2 id="区块">区块</h2><ol><li><p><code>&lt;div&gt;</code> 可以布局和容纳其他元素，适合做大的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;span&gt;</code> 适合对行内其他元素进行样式化，标记和包裹</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的词。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202410051901429.png" alt=""></p></li></ol><h2 id="表单">表单</h2><p><code>&lt;form&gt;</code> 是获取用户输入的地方，<code>action</code> 属性定义了数据提交的目标URL，<code>method</code> 属性定义了提交数据的HTTP方法（GET，POST…）</p><p><code>&lt;label&gt;</code> 可以告诉用户要输入的是什么</p><p><code>&lt;input&gt;</code> 创建文本输入框，密码框，单选按钮，复选框，文件，<code>id</code> 属性用于在HTML文件中标记这个元素，<code>name</code> 和输入值组成键值对，传送到后端</p><p><code>&lt;select&gt;</code> 创建下拉表，<code>&lt;option&gt;</code> 创建选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;country&quot;</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cn&quot;</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;uk&quot;</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--提交文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202410061325612.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前端]JS入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-JS%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-JS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前端]css入门</title>
      <link href="/2024/09/26/%E5%89%8D%E7%AB%AF-css%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/%E5%89%8D%E7%AB%AF-css%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[Go]模板与渲染</title>
      <link href="/2024/09/24/Go-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
      <url>/2024/09/24/Go-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><ol><li>导包：<code>text/template</code>，<code>html/template</code>，前面文本模板，后面html模板</li><li>作用：一个html文件中需要使用到会改变的各种后端传送的数据和不会改变的html基本架构，在html文件中用模板语言标记出这些数据要在的地方，渲染就是将数据填入，可以理解为一种文本替换操作</li><li>通常定义为 .tmpl 和 .tpl，必须使用UTF-8编码</li><li>传给模板的数据用包裹起来</li></ol><h2 id="相关方法">相关方法</h2><p><strong>解析</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span></span> Parse(src <span class="type">string</span>) (*Template, <span class="type">error</span>)      <span class="comment">//对已存在的Template对象使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="type">string</span>)</span></span> (*Template, <span class="type">error</span>)      <span class="comment">//解析具体文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseGlob</span><span class="params">(pattern <span class="type">string</span>)</span></span> (*Template, <span class="type">error</span>)            <span class="comment">//解析大量文件</span></span><br></pre></td></tr></table></figure><p><strong>渲染</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t, *Template)</span></span> Execute(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t, *Template)</span></span> ExecuteTemplate(wr io.Writer, name <span class="type">string</span>, data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p>模板文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;.&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//解析模板</span></span><br><span class="line">t, err := template.ParseFiles(<span class="string">&quot;./template_demo/hello.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;template files failed, err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">err = t.Execute(w, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;exceute data failed, err:%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;HTTP server start failed&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409261028588.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计网]互联网协议入门</title>
      <link href="/2024/09/19/%E8%AE%A1%E7%BD%91-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/19/%E8%AE%A1%E7%BD%91-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>看 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议入门（一） - 阮一峰的网络日志 (ruanyifeng.com)</a> 做的笔记</p><h1 id="概述">概述</h1><p>互联网(internet) 一共分为五层，每层有对应的协议，如表</p><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">/</th><th style="text-align:center">/</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">应用层(Application Layer)</td><td style="text-align:center">HTTP，DHCP…</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层(Transport Layer)</td><td style="text-align:center">UDP，TCP…</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层(Network Layer)</td><td style="text-align:center">ARP，IP…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">链接层(Link Layer)</td><td style="text-align:center">以太网协议(IEEE,IEEE 802.3)…</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">实体层(Physical Layer)</td><td style="text-align:center">网线，光纤的接口类型等</td></tr></tbody></table><p>每一层都是为了完成一个功能，而协议就是为了让所有人都按照一样的格式完成这个功能，从而实现世界的互联</p><h1 id="五层模型">五层模型</h1><h2 id="实体层">实体层</h2><p>把电脑连接起来的一些物理手段比如光纤，电缆，<strong>负责传递0，1的电信号</strong></p><h2 id="链接层">链接层</h2><h3 id="作用">作用</h3><p>将0，1的电信号用某种分组方式格式化成含有信息的数据</p><p>这就会导致不同公司生产的设备使用不同的分组方式，而以太网协议(IEEE,IEEE 802.3)就是对这种格式化方式的统一规定</p><h3 id="以太网协议-ieee-ieee-802-3">以太网协议(IEEE,IEEE 802.3）</h3><p>此协议规定，一组电信号组成一个数据包，叫做“帧”（Frame），由标头（head），数据（data）组成</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409191936549.png" alt=""></p><ul><li><p>以太网数据包：</p><p>标头：源mac和目标mac，固定是18字节</p><p>数据：帧校验序列等具体内容，46-1500字节</p></li></ul><h3 id="mac地址">MAC地址</h3><p><strong>是什么：就是网卡的地址</strong></p><p>以太网规定，连入网络的所有设备，都必须具有网卡接口，数据包必须从一块网卡传送到另一块网卡，网卡的地址就是数据包发送和接受的地址，称为MAC地址</p><p><strong>组成</strong></p><p>每块网卡都有独一无二的MAC地址，由48个二进制位组成，通常用12个十六进制数表示。</p><p>前六个是厂商编号，后六位是网卡流水号</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png" alt="img"></p><h3 id="广播-数据发送方式">广播(数据发送方式)</h3><p><strong>作用</strong>：以太网的一种数据发送方式</p><p>以太网采用一种很原始的方法发送数据包给接受方，本机会向子网络内每一台计算机都发送一份数据包，由计算机自身判断是否为接收方（通过标头内的标识信息判断）。</p><p>至于怎么样获得这些mac地址，后文会提到</p><h2 id="网络层">网络层</h2><h3 id="作用">作用</h3><p>引进一套新的地址，使我们可以区分不同的计算机是否属于同一个子网络，这套地址叫做”网络地址“，也就是网址。</p><blockquote><p>注意：我们所熟知的形如 <code>www.xxxx.com</code> 并不是网址，我们访问这个域名时会向万维网(www)服务器发送一个请求，而服务器会给我们返回这个域名对应的IP地址，我们才可以继续访问这个网站</p></blockquote><p>如果属于一个子网络，就采用广播方式发送，否则就采用路由方式发送</p><h3 id="ip协议">IP协议</h3><p><strong>作用</strong>：规定IP地址的协议，普遍采用IPv4，也就是第四版IP协议</p><p>IP地址由32个二进制组成</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409211921356.png" alt=""></p><p>IP地址由 <strong>网络</strong> 和 <strong>主机</strong> 两部分组成，但是网络和主机各占几个字符是不确定的</p><p>例如，有可能前24位是网络的地址 也就是 <code>172.16.254</code>，那么最后一个<code>1</code>就是主机地址</p><p>也有可能是前28位是网络地址…</p><p>然而，一个IP地址可以使用的地址要去除两种情况，将主机地址全设为0的和全设为1的，在上面的例子中就是</p><p><code>172.16.254.0 </code> 和 <code>172.16.254.255</code> 后者是广播地址，用于发送广播消息</p><p><strong>那么如何对计算机做区分呢，需要使用另一个参数“子网掩码”</strong></p><h3 id="子网掩码">子网掩码</h3><p><strong>作用</strong>：确定一个IP地址所在的子网络</p><p>和IP地址长度一样，当前24位表示网络地址时，子网掩码就是 <code>11111111.11111111.11111111.0000000</code>，换算成十进制就是 <code>255.255.255.0</code></p><p>使用子网掩码时，将子网掩码和IP地址二进制AND运算，从而得到网络地址，如果相同就在同一子网络</p><h3 id="ip数据包">IP数据包</h3><p>同样包括标头和数据部分</p><p>标头：版本，长度，IP地址，20-60字节</p><p>数据：最长65515字节，因此要分成多个以太网数据包发送</p><p>IP数据包会放在以太网数据包的数据部分中</p><h3 id="arp协议">ARP协议</h3><p><strong>作用</strong>：从IP地址获取MAC地址(在同一个子网络情况下)</p><p>ARP协议会向子网络中所有计算机发送一个数据包，包括自己的IP地址和查询主机的IP地址，在对方MAC地址上填<code>FF:FF:FF:FF:FF:FF</code>，每台计算机对IP地址进行比较，如果相同就回复自己的MAC地址</p><h2 id="传输层">传输层</h2><h3 id="作用">作用</h3><p>建立端口到端口之间的通信，从而实现程序之间的交流</p><h3 id="端口-port">端口(port)</h3><p><strong>作用</strong>：用来辨别数据包具体是给某个程序使用的</p><p>端口是一个0-65535之间的整数，正好16位二进制，它其实就是每一个网卡使用程序的编号，其中0-1023由系统占用</p><blockquote><p>Unix系统把主机+端口称为”套接字“，也就是socket，我们熟悉的socket编程就是在这一层进行</p></blockquote><h3 id="udp协议">UDP协议</h3><p><strong>作用</strong>： 在数据包中加入端口号</p><p>标头：发出端口和接收端口</p><p>数据：就是数据</p><p>总长不超过65535字节，刚好放入一个IP数据包</p><h3 id="tcp协议">TCP协议</h3><p><strong>作用</strong>：有确认机制的UDP协议，如果有一个数据包遗失了，发出方就收不到确认要求，就会重发数据包</p><p>其他和UDP差不多</p><h2 id="应用层">应用层</h2><h3 id="作用">作用</h3><p>规定应用程序的数据格式</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p><h3 id="dhcp协议">DHCP协议</h3><p><strong>作用</strong>：用于内部网或网络服务供应商自动分配IP地址给用户，用于内部网管理员对所有电脑作中央管理</p><h3 id="dns协议">DNS协议</h3><p><strong>作用</strong>：域名（如 <a href="http://www.example.com">www.example.com</a>）转换为计算机能够理解的IP地址（如 192.0.2.1）</p><h2 id="小结">小结</h2><p>通过以上的学习，我们知道数据在计算机之间传输的大概流程：</p><p>在应用中产生要传输的数据，传输层加入端口号，网络层加入IP地址，链接层加入MAC地址，物理层传送这些数据</p><p>如果我们要访问一个网页，</p><ol><li>首先设置好自己的网络参数，IP地址，子网掩码，网关的IP地址，DNS的IP地址，当然这些参数都应该有网络管理员来分配，而不是我们自己随便写。</li><li>输入域名(<a href="http://www.xxxxxx.com">www.xxxxxx.com</a>)，通过DNS协议把这个域名转换为IP地址</li><li>判断这个IP地址是否在同一子网络，如果在，就直接获得MAC地址，如果不在，通过网关转发，那么网关的MAC地址就是我们要传送的MAC地址</li><li>到这里，我们的主机会向目标主机发送一个访问请求，由于浏览网页使用的是HTTP协议，所以我们要生成一个HTTP数据包，再通过TCP，IP，以太网等协议的包装形成最后的以太网数据包，通过多个网关发送的目标主机，而目标主机则会返回一个HHTTP响应，用TCP协议发回来，这就完成了一次网络通信</li></ol><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409201853411.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]gin框架基本使用</title>
      <link href="/2024/09/16/Go-gin%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/16/Go-gin%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>官方文档：<a href="https://gin-gonic.com/zh-cn/docs/">文档 | Gin Web Framework (gin-gonic.com)</a></p><h1 id="基本的gin示例">基本的gin示例</h1><p><strong>安装</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p><strong>demo</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span>        <span class="comment">//导入gin包</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;  </span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello golang!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()            <span class="comment">//创建一个默认的路由引擎</span></span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, sayHello)     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><pre><code class="language-go">func sayHello(c *gin.Context) &#123;c.JSON(200, gin.H&#123;  &quot;message&quot;: &quot;hello golang!&quot;,&#125;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  1. `sayHello`函数是一个处理HTTP请求的函数，形参`c`是`*gin.Context`类型，其中**封装了客户端发来的请求数据**表示当前请求的上下文，可以从中获得当前请求的信息，响应信息，执行中间件</span><br><span class="line">  2. `c.JSON`将HTTP状态码200和一个JSON响应发送回客户。`gin.H`是gin提供的一个便利类型，**其数据类型是 `map[string]interface&#123;&#125;`** ，它的键必须是字符串，它的值可以存储任意类型的数据</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  r := gin.Default()</span><br></pre></td></tr></table></figure>初始化了一个默认的gin引擎，`gin.Default()` 会创建一个带有默认中间件的路由器，包括日记记录和恢复中间件，这意味着他会在每个请求中记录日志，并处理`panic`</code></pre></li><li><pre><code class="language-go">r.GET(&quot;/hello&quot;, sayHello)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  向`r`路由器注册一个 `GET` 请求的路由，当用户访问时调用`sayHello()`函数处理</span><br><span class="line"></span><br><span class="line">- ````go</span><br><span class="line">  r.Run()</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">  启动了gin 的HTTP服务器，监听本地的8080端口（默认） </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RESTful API</span><br><span class="line"></span><br><span class="line">RESTful API（Representational State Transfer）是一种基于 HTTP 协议的网络服务架构风格，它使得系统的各个部分能够通过统一接口进行交互。RESTful API 通常遵循以下原则：</span><br><span class="line"></span><br><span class="line">1. **无状态性**：每个请求都应包含处理该请求所需的所有信息，以便服务器不需要保留用户的状态信息。</span><br><span class="line">2. **资源导向**：API 的每一个 URL 代表一个资源（例如用户、订单等）。</span><br><span class="line">3. 使用标准 HTTP 方法：</span><br><span class="line">   - `GET`：获取资源。</span><br><span class="line">   - `POST`：创建资源。</span><br><span class="line">   - `PUT`：更新资源。</span><br><span class="line">   - `DELETE`：删除资源。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># Gin渲染</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTML渲染</span><br><span class="line"></span><br><span class="line">**方法**：</span><br><span class="line"></span><br><span class="line">`LoadHTMLGlob()` 加载一坨文件</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func (engine *Engine) LoadHTMLGlob(pattern string)</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>LoadHTMLFiles()</code> 加载指定名的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> LoadHTMLFiles(files ...<span class="type">string</span>)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析模板</span></span><br><span class="line">r.LoadHTMLFiles(<span class="string">&quot;./gin_demo1/hello.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">        c.HTML(<span class="number">200</span>, <span class="string">&quot;hello.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span>:   <span class="string">&quot;yc&quot;</span>,</span><br><span class="line"><span class="string">&quot;Gender&quot;</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>:    <span class="number">19</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义模板函数">自定义模板函数</h2><p>方法：</p><p><code>SetFuncMap()</code>：用于定义模板文件中的自定义函数，需要在解析模板前用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> SetFuncMap()(funcMap template.FuncMap)</span><br></pre></td></tr></table></figure><p>例子：</p><p>index.tmpl</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; .| safe&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.SetFuncMap(template.FuncMap&#123;</span><br><span class="line"><span class="string">&quot;safe&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> template.HTML&#123;</span><br><span class="line"><span class="keyword">return</span> template.HTML(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">router.LoadHTMLFiles(<span class="string">&quot;./index.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;index.tmpl&quot;</span>, <span class="string">&quot;&lt;a href=&#x27;https://liwenzhou.com&#x27;&gt;李文周的博客       &lt;/a&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对需要返回html的场景可能发生有风险的内容，比如用户评论了html语言，如果不进行转移就会污染返回的html文件，而如果完全信任输入，就可以用如上的方法阻止转义</p><h2 id="静态文件处理">静态文件处理</h2><p><code>gin.Static()</code>：如果HTML文件中引用了静态文件，调用此方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Static(relativePath, root <span class="type">string</span>) IRoutes</span><br></pre></td></tr></table></figure><h2 id="json渲染">JSON渲染</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> JSON(code <span class="type">int</span>, obj any)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">Age     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.JSON(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xml渲染">xml渲染</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> c.XML(code <span class="type">int</span>, obj any)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">&quot;/someXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.XML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/moreXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">Age     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg MessageRecord</span><br><span class="line">msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.XML(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ymal渲染">YMAL渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someYAML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.YAML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br></pre></td></tr></table></figure><h1 id="获取参数">获取参数</h1><h2 id="获取querytring参数">获取querytring参数</h2><p><code>querystring()</code>：参数指的是URL <code>？</code>后的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> DefaultQuery(key, defaultValue <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/query&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取form参数">获取form参数</h2><p><code>PostForm</code>：接受前端发来的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gin.Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(<span class="number">200</span>, <span class="string">&quot;login.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取path参数">获取path参数</h2><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数绑定">参数绑定</h2><p><code>ShoudBind()</code>：自动提取请求中的<code>querystring</code>，<code>form</code>，<code>json</code>，<code>xml</code>类型的数据，并绑定到结构体中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShoudBind(obj any) <span class="type">error</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/bind&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u1 User</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;u1); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>: u1.Username,</span><br><span class="line"><span class="string">&quot;pass&quot;</span>: u1.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;err&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只用了表单举例子</p><blockquote><p>如果结构体中使用的指针字段，shouldbind会先接收值然后使用相应地址赋值给相应字段</p></blockquote><h1 id="文件上传">文件上传</h1><p><code>c.FormFile</code> ：从HTTP请求中获取通过表单上传的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> FormFile(key <span class="type">string</span>) (multipart.File, *multipart.FileHeader, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>uploadfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/file&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;./gin_demo2/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;file.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/file&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, err := c.FormFile(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;get file failed, panic&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">&quot;D:/develop/file/%s&quot;</span>, file.Filename)</span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">c.JSON(http.StatusOK, <span class="string">&quot;submit sucess&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重定向">重定向</h1><h2 id="http重定向">HTTP重定向</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.sogo.com/&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由重定向">路由重定向</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指定重定向的URL</span></span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="gin路由">Gin路由</h1><h2 id="路由组">路由组</h2><p>相同URL前缀的路由可以划分为一个路由组，可以用 <code>&#123;&#125;</code> 包裹起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">userGroup := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.Run()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gin中间件">Gin中间件</h1><h2 id="定义">定义</h2><p>gin 的中间件 <code>gin.HandlerFunc</code> 类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line"><span class="comment">// 计算耗时</span></span><br><span class="line">cost := time.Since(start)</span><br><span class="line">log.Println(cost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册中间件">注册中间件</h2><h3 id="全局注册">全局注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.Use(StatCost())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为某个路由单独注册">为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="为路由组注册中间件">为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。</p><p>写法1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解释shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gin默认中间件">gin默认中间件</h2><p><code>gin.Default</code> 默认用了 <code>Logger</code> 和 <code>Recovery</code> 中间件</p><p><code>gin.New</code> 会创建一个没有任何中间件的路由</p><h2 id="gin中间件中使用goroutine">gin中间件中使用goroutine</h2><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p><blockquote><p>一般项目的结构：</p><p>controller：包含了各个路由使用的函数</p><p>static：包含了静态文件</p><p>dao：数据库相关？</p><p>model：所有模型，及其相关的增删改查操作</p><p>url --&gt; controller --&gt; logic --&gt; model</p><p>请求 --&gt; 控制器 --&gt; 业务逻辑 --&gt; 模型层的增删改查</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[git]基本使用</title>
      <link href="/2024/09/13/git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/13/git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本的linux命令">基本的linux命令</h1><p><code>cd</code> ：改变目录（直接cd，进入默认目录）</p><p><code>cd ..</code> ：回退到上一级目录</p><p><code>pwd</code> ：显示当前所在目录路径</p><p><code>ls / ll</code>：列出所有文件（ll更加详细）</p><p><code>rm + 文件名</code> ：删除文件</p><p><code>rm -r + 文件夹名</code> ：删除文件夹</p><p><code>mkdir</code> ：新建一个文件夹</p><p><code>reset</code> ：初始化终端</p><p><code>history</code> ：查看历史命令</p><p><code>clear</code> ：清屏</p><p><code>help</code> ：帮助</p><p><code>exit</code> ：退出</p><h1 id="配置">配置</h1><p>使用 <code>git config</code> 命令</p><p>显示当前配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p>编辑配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --e               <span class="comment">#针对当前仓库</span></span><br><span class="line">$ git config --e --global      <span class="comment">#针对系统上所有仓库 </span></span><br></pre></td></tr></table></figure><p>设置用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;...&quot;</span></span><br><span class="line">$ git config --global user.email ...</span><br></pre></td></tr></table></figure><h1 id="创建仓库">创建仓库</h1><p>有两种方法</p><ul><li><p><strong>git init</strong></p><p>进入一个目录，并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init            <span class="comment">#将当前目录作为git仓库</span></span><br><span class="line">$ git init 目录名      <span class="comment">#将指定目录作为git仓库</span></span><br></pre></td></tr></table></figure><p>执行该命令后，对应目录会生成一个 .git 的文件夹（隐藏文件夹）</p></li><li><p><strong>git clone</strong></p><p>从现有的git仓库中拷贝项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt;  <span class="comment">#克隆到当前目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;  <span class="comment">#克隆到指定目录</span></span><br></pre></td></tr></table></figure><p>例子：</p><p>随便克隆一个github上的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/KQLXK/Linkup.git</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本操作">基本操作</h1><h2 id="常见操作">常见操作</h2><ul><li><p>git add:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件名       <span class="comment">#提交到暂存区</span></span><br></pre></td></tr></table></figure></li><li><p>git commit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;...&quot;</span>  <span class="comment">#将暂存区内容添加到仓库</span></span><br></pre></td></tr></table></figure></li><li><p>git status：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status           <span class="comment">#确认哪些文件被修改暂存或未被跟踪</span></span><br></pre></td></tr></table></figure></li><li><p>git log:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>             <span class="comment">#查看提交日志</span></span><br></pre></td></tr></table></figure></li><li><p>git branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch          <span class="comment"># 查看当前分支</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="提交与修改">提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git add</code></td><td style="text-align:left">添加文件到暂存区</td></tr><tr><td style="text-align:left"><code>git status</code></td><td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td style="text-align:left"><code>git diff</code></td><td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td style="text-align:left"><code>git difftool</code></td><td style="text-align:left">使用外部差异工具查看和比较文件的更改。</td></tr><tr><td style="text-align:left"><code>git range-diff</code></td><td style="text-align:left">比较两个提交范围之间的差异。</td></tr><tr><td style="text-align:left"><code>git commit</code></td><td style="text-align:left">提交暂存区到本地仓库。</td></tr><tr><td style="text-align:left"><code>git reset</code></td><td style="text-align:left">回退版本。</td></tr><tr><td style="text-align:left"><code>git rm</code></td><td style="text-align:left">将文件从暂存区和工作区中删除。</td></tr><tr><td style="text-align:left"><code>git mv</code></td><td style="text-align:left">移动或重命名工作区文件。</td></tr><tr><td style="text-align:left"><code>git notes</code></td><td style="text-align:left">添加注释。</td></tr><tr><td style="text-align:left"><code>git checkout</code></td><td style="text-align:left">分支切换。</td></tr><tr><td style="text-align:left"><code>git switch （Git 2.23 版本引入）</code></td><td style="text-align:left">更清晰地切换分支。</td></tr><tr><td style="text-align:left"><code>git restore （Git 2.23 版本引入）</code></td><td style="text-align:left">恢复或撤销文件的更改。</td></tr><tr><td style="text-align:left"><code>git show</code></td><td style="text-align:left">显示 Git 对象的详细信息。</td></tr></tbody></table><h3 id="提交日志">提交日志</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git log</code></td><td style="text-align:left">查看历史提交记录</td></tr><tr><td style="text-align:left"><code>git blame &lt;file&gt;</code></td><td style="text-align:left">以列表形式查看指定文件的历史修改记录</td></tr><tr><td style="text-align:left"><code>git shortlog</code></td><td style="text-align:left">生成简洁的提交日志摘要</td></tr><tr><td style="text-align:left"><code>git describe</code></td><td style="text-align:left">生成一个可读的字符串，该字符串基于 Git 的标签系统来描述当前的提交</td></tr></tbody></table><h3 id="远程操作">远程操作</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git remote</code></td><td style="text-align:left">远程仓库操作</td></tr><tr><td style="text-align:left"><code>git fetch</code></td><td style="text-align:left">从远程获取代码库</td></tr><tr><td style="text-align:left"><code>git pull</code></td><td style="text-align:left">下载远程代码并合并</td></tr><tr><td style="text-align:left"><code>git push</code></td><td style="text-align:left">上传远程代码并合并</td></tr><tr><td style="text-align:left"><code>git submodule</code></td><td style="text-align:left">管理包含其他 Git 仓库的项目</td></tr></tbody></table><blockquote><p>注意：git commit 后会进入vim编辑器界面</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409161405612.png" alt=""></p><p>基本操作：</p><ol><li>按下字母键<code>i</code>或<code>a</code>或<code>o</code>，此时进入到可编辑状态，这时就可以输入你的注释</li><li>当你输入完之后，按下<code>Esc</code>键就可退出编辑状态，回到一般模式。</li><li>最后就是怎么退出vim编辑器并提交commit， 有两种方法：</li></ol><ul><li>输入两字大写字母<code>ZZ</code>（记住是大写）</li><li>输入<code>:wq</code>或<code>:wq!</code>(强行退出)</li></ul></blockquote><h1 id="忽略文件">忽略文件</h1><p>.gitignore文件中可以选择忽略的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt          <span class="comment">#忽略 .txt结尾的文件</span></span><br><span class="line">!lib.txt       <span class="comment">#处理 lib.txt</span></span><br><span class="line">/temp    <span class="comment">#忽略名为 temp 的目录及其所有内容</span></span><br><span class="line">build/         <span class="comment">#忽略 build 目录下所有文件</span></span><br><span class="line">doc/*.txt      <span class="comment">#忽略doc文件夹下的 .txt结尾的所有文件 </span></span><br></pre></td></tr></table></figure><h1 id="github远程仓库">github远程仓库</h1><p>在使用前要先连接github <a href="https://www.runoob.com/git/git-remote-repo.html">Git 远程仓库(Github) | 菜鸟教程 (runoob.com)</a></p><h2 id="添加远程仓库">添加远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;别名&gt; &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:KQLXK/test.git</span><br></pre></td></tr></table></figure><h2 id="查看远程仓库">查看远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h2 id="拉取远程仓库">拉取远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin main</span><br></pre></td></tr></table></figure><h2 id="推送到远程仓库">推送到远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h2 id="删除远程仓库">删除远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> [别名]</span><br></pre></td></tr></table></figure><h1 id="使用gitee进行团队协作">使用gitee进行团队协作</h1><ol><li><p><strong>首先在gitee上新建仓库</strong></p></li><li><p><strong>创建之后邀请成员</strong></p></li></ol><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20241029175439743.png" alt="image-20241029175439743" style="zoom: 33%;" /><ol start="3"><li><p><strong>各个成员在本地创建本地仓库连接上这个远程仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> test2<span class="comment">#创建文件夹test2</span></span><br><span class="line">$ <span class="built_in">cd</span> test2<span class="comment">#转换到test2目录下操作</span></span><br><span class="line">$ git init <span class="comment">#初始化本地仓库</span></span><br><span class="line">$ git remote add origin git@gitee.com:kqlxk/test2.git<span class="comment">#连接远程仓库</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建自己的分支进行代码编写</strong></p><p>为了让不同成员负责不同的模块操作，一般不同的成员会使用不同的分支，在编写完自己的部分后传到远程仓库对应分支后用 <code>pull request</code> 再合并到主分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch feature-branch           <span class="comment">#创建新分支</span></span><br><span class="line">$ git checkout feature-branch     <span class="comment">#切换到新分支</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从远程仓库拉取代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch_name&gt;  </span><br></pre></td></tr></table></figure><p>如果我们要从 <code>master</code> 分支拉取就运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li><li><p><strong>本地编写并保存</strong></p><p>本地编写完代码后，应该使用 <code>git add</code> ，<code>git commit</code> 提交到本地仓库</p></li><li><p><strong>push到远程仓库</strong></p><p>在本地仓库提交完代码后，需要push到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;远程仓库分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>发起pull request</strong></p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20241029190454682.png" alt="image-20241029190454682" style="zoom:33%;" /><p>发起pull request之后由组长或管理员进行审核，再进行合并分支，就可以完成团队协作</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]事务</title>
      <link href="/2024/09/10/Mysql-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/09/10/Mysql-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><h2 id="是什么">是什么</h2><p><strong>事务是一组操作的集合</strong>，可以包括查询，删除，修改等具体操作，是作为一个整体出现，可以理解为一个函数，一般包含多个语句</p><p>比如，在一个人员管理系统中，要删除一个人，就要先找到这个人的id，在删除与他相关的各种信息如文章，信箱等，这些数据库操作语句就构成了一个事务</p><h2 id="操作语句">操作语句</h2><p>方法一：用BEGIN, ROLLBACK, COMMIT 来实现</p><ul><li><p>开启事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><p>方法二：直接用 SET 来改变 MySQL 的自动提交模式</p><ul><li><p>禁止自动提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line"></span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">程序抛出异常</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">commit;   --(手动)</span><br><span class="line">rollback; --(手动)</span><br></pre></td></tr></table></figure><h2 id="性质-acid">性质(ACID)</h2><p><strong>原子性</strong>：事务是不可分割的最小单元，要么全部成功，要么全部失败</p><p><strong>一致性</strong>： 事务完成时，必须使所有的数据都保持和数据库的一致状态，也就是写入或修改的数据必须和数据库的预设完全一样</p><p><strong>隔离性</strong>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p><p><strong>持久性</strong>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h1 id="并发事务引发问题">并发事务引发问题</h1><p>只是指出了问题</p><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">一个事务在查询数据时，没有对应的数据行，但是在插入数据是，又发现这行数据已经存在，好像出现了幻影</td></tr></tbody></table><h1 id="事务隔离级别">事务隔离级别</h1><p>用于解决并发事务所引发的问题</p><p>安全性越来越高，性能越低</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202409121056830.png" alt=""></p><p>read uncommited(读未提交)：读取的数据是未提交的数据，自然会导致三个问题</p><p>read commited(读已提交)：读取的数据是已提交的，可以避免脏读，但是如果提交后数据被改变，还是会出现不可重复读和幻读</p><p>repeatable read(重复读)：解决不可重复读问题</p><p>serializable(串行化)：只允许同时有一个事务操作数据表，解决幻读</p><ul><li><p>设置事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level ...</span><br></pre></td></tr></table></figure></li><li><p>查询事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]go语言操作MySQL</title>
      <link href="/2024/08/26/Go-go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMySQL/"/>
      <url>/2024/08/26/Go-go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="连接数据库">连接数据库</h1><h2 id="下载依赖">下载依赖</h2><p>首先在终端用以下代码下载依赖</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><h2 id="建立连接">建立连接</h2><ul><li><p><strong>dsn语句存储连接信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">&quot;username:password@tcp(127.0.0.1:3306)/dbname?charset=utf8&quot;</span></span><br></pre></td></tr></table></figure><p>用户名+密码+主机+数据库名+字符集</p></li><li><p><strong>sql.open()函数建立连接</strong></p><p>函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err = sql.open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br></pre></td></tr></table></figure></li><li><p><strong>错误判断</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="built_in">panic</span>(err) <span class="comment">// 如果连接失败则 panic，通常不推荐使用 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;连接数据库成功&quot;</span>)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p><strong>有效性检查</strong></p><p><code>sql.open()</code>并不能建立起实际的连接，也就是不能验证dsn里所给信息是否正确，所以我们要用<code>ping</code>方法来检查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;检查成功，已正确连接&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭数据库</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></li></ul><h1 id="crud">CRUD</h1><h2 id="查询">查询</h2><p>使用<code>QueryRow()</code>,<code>Query()</code>函数</p><p>函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*Row, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>创建结构体</strong></p><p>首先要创建一个符合数据库中数据类型和结构的结构体来储存数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建sqlStr储存查询信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>调用QueryRow</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;u.id, &amp;u.name. &amp;u.age)</span><br></pre></td></tr></table></figure></li><li><p><strong>错误处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查询成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整体代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(id <span class="type">int</span>, db *sql.DB)</span></span> User &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br><span class="line">err := db.QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;user.id, &amp;user.name, &amp;user.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查询成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="插入">插入</h2><p>插入，删除，更新都使用<code>Exec</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, err)</span><br></pre></td></tr></table></figure><p><code>Result</code>是对<code>sql</code>命令的总结</p><p>代码大体和查询相同，不多做赘述</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(user User, db *sql.DB)</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;insert into student(sname,sage,sid,ssex) values(?,?,?,?)&quot;</span></span><br><span class="line">res, err := db.Exec(sqlStr, user.name, user.age, user.id, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(res.LastInsertId())</span><br><span class="line">fmt.Println(<span class="string">&quot;成功添加&quot;</span>, user.name, <span class="string">&quot;到数据库中&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改">修改</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;update user set age=? where id = ?&quot;</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;update failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;update success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;delete from user where id = ?&quot;</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;delete failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;delete success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mysql预处理">MySQL预处理</h1><h2 id="是什么">是什么</h2><p>先传一段带有占位符的语句给Mysql服务端，之后只需要传数据即可</p><p>类似于模板</p><h2 id="实现">实现</h2><p>由 <code>database/sql</code>中的<code>Prepare</code>方法实现</p><p>原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>以查询操作为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareQuery</span><span class="params">(id <span class="type">int</span>, db *sql.DB)</span></span> User &#123;</span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">sqlStr := <span class="string">&quot;select sid, sname, sage from student where sid = ?&quot;</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">fmt.Println(<span class="string">&quot;query failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">err = stmt.QueryRow(id).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现mysql事务">实现MySQL事务</h1><h2 id="相关方法">相关方法</h2><ul><li>开始事务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin()(*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>提交</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db* DB)</span></span> Commit() <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li>回滚</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="事务示例">事务示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">dsn := <span class="string">&quot;root:yuchao123@tcp(127.0.0.1:3306)/test&quot;</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">tx, err := db.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;begin a transaction failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlstr := <span class="string">&quot;update account set money = 1000 where name = &#x27;张三&#x27;&quot;</span></span><br><span class="line">res, err := tx.Exec(sqlstr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">fmt.Println(<span class="string">&quot;update1 failed&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">affrow, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">fmt.Println(<span class="string">&quot;get rowsaffected failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affrow == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;transaction commited&quot;</span>)</span><br><span class="line">tx.Commit()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;transaction Rollback&quot;</span>)</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]反射</title>
      <link href="/2024/08/21/Go-%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/08/21/Go-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射是什么">反射是什么</h1><p>反射在 Go 语言中是一个非常强大的工具，它允许程序在运行时检查和操作类型和数据。用通俗的话来解释，就是反射可以让你“看见”或“操控”程序中的值和类型</p><p>具体来说，反射就是一个包，包里有各种函数可以返回对象的 <strong>类型</strong> 和 <strong>值</strong> ，而类型又分为<code>name</code>和<code>kind</code>，而对于结构体，又有<code>NumField()</code>和<code>Field()</code>等方法来获得详细信息</p><h1 id="reflect-typeof">reflect.Typeof()</h1><p><code>type</code> 还分为 <code>name</code>和<code>kind</code>，name可以是一些自定义类型或结构体名，而 Kind 就是它最底层的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《跟小王子学Go语言》&quot;</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reflect-valueof">reflect.Valueof()</h1><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Interface() interface {}</td><td style="text-align:center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td style="text-align:center">Int() int64</td><td style="text-align:center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Uint() uint64</td><td style="text-align:center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Float() float64</td><td style="text-align:center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td style="text-align:center">Bool() bool</td><td style="text-align:center">将值以 bool 类型返回</td></tr><tr><td style="text-align:center">Bytes() []bytes</td><td style="text-align:center">将值以字节数组 []bytes 类型返回</td></tr><tr><td style="text-align:center">String() string</td><td style="text-align:center">将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"><span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>通过反射设置变量的值</strong></p><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>isNil()和isValid()</strong></p><p><strong>isNil()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsNil() <span class="type">bool</span></span><br></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><p><strong>isValid()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsValid() <span class="type">bool</span></span><br></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><h4 id="举个例子">举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// *int类型空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line"><span class="comment">// nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;娜扎&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="结构体反射">结构体反射</h1><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Field(i int) StructField</td><td style="text-align:center">根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">NumField() int</td><td style="text-align:center">返回结构体成员字段数量。</td></tr><tr><td style="text-align:center">FieldByName(name string) (StructField, bool)</td><td style="text-align:center">根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">FieldByIndex(index []int) StructField</td><td style="text-align:center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td style="text-align:center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td style="text-align:center">根据传入的匹配函数匹配需要的字段。</td></tr><tr><td style="text-align:center">NumMethod() int</td><td style="text-align:center">返回该类型的方法集中方法的数目</td></tr><tr><td style="text-align:center">Method(int) Method</td><td style="text-align:center">返回该类型方法集中的第i个方法</td></tr><tr><td style="text-align:center">MethodByName(string)(Method, bool)</td><td style="text-align:center">根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h3 id="structfield类型">StructField类型</h3><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体反射示例">结构体反射示例</h3><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Score: <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line"><span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line"><span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType := v.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]并发</title>
      <link href="/2024/08/19/Go-%E5%B9%B6%E5%8F%91/"/>
      <url>/2024/08/19/Go-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><p>并发：同一时刻执行多个任务</p><p>并行：一个时间段内执行多个任务</p><p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p><p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。</p><p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。</p><p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p><h1 id="goroutine">goroutine</h1><h2 id="如何使用">如何使用</h2><p>只需要在调用的函数或方法前加上<code>go</code>关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>    <span class="comment">//创建一个新的 goroutine 运行函数f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;()          <span class="comment">//匿名函数也支持使用go关键字创建 goroutine 去执行。</span></span><br></pre></td></tr></table></figure><h2 id="启动单个goroutine">启动单个goroutine</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会交替输出这两句话</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408192039040.png" alt=""></p><p>而如果没有加入for循环，重新执行程序后会输出</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuck you apex</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>为什么会先打印 fuck you apex？因为程序创建一个<code>goroutine</code>执行函数是是要花费时间的，而此时main函数会继续执行下去，所以会先打印下面的那句话，而如果当main函数执行完之后<code>goroutine</code>的创建还没有完成，那就会在打印了fuck you apex 后直接退出程序，也就是只有这一句话</p><p>那我们如何做到确保所有的并发结束后才退出程序呢？我们可以使用sync包中的<code>sync.WaitGroup</code>来等待所有并发完成</p><p>下面是示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动多个goroutine">启动多个goroutine</h2><p>启动多个goroutine和单个同理，使用<code>sync.WaitGroup</code>来等待所有并发完成即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>, i)</span><br><span class="line">wg2.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg2.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello2(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg2.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现程序输出时 i 是无序的(注意：每次程序的输出都会不一样)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fuck you apex</span><br><span class="line">hello world <span class="number">2</span></span><br><span class="line">hello world <span class="number">7</span></span><br><span class="line">hello world <span class="number">8</span></span><br><span class="line">hello world <span class="number">5</span></span><br><span class="line">hello world <span class="number">9</span></span><br><span class="line">hello world <span class="number">6</span></span><br><span class="line">hello world <span class="number">1</span></span><br><span class="line">hello world <span class="number">0</span></span><br><span class="line">hello world <span class="number">4</span></span><br><span class="line">hello world <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这是因为10个 goroutine 是并发的，而 goroutine 的调度是随机的</p><h2 id="gomaxprocs">GOMAXPROCS</h2><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过<code>runtime.GOMAXPROCS</code>函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部CPU逻辑核心数）</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只有一个核心，所以只能先完成一个，在完成另一个</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B: 0</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 2</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 3</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 4</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 5</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 6</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 7</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 8</span></span><br><span class="line"><span class="function"><span class="title">B</span>: 9</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 0</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 1</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 2</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 3</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 4</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 5</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 6</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 7</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 8</span></span><br><span class="line"><span class="function"><span class="title">A</span>: 9</span></span><br></pre></td></tr></table></figure><h1 id="channel">channel</h1><h2 id="为什么要用channel">为什么要用channel</h2><p>单纯的函数的并发是没有意义的，函数与函数交换数据才能体现并发执行函数的意义，这一般有内存共享和通信共享两种方式。go语言中采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡通过通信共享内存</p><p>而<code>channel</code>就是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>**Go 语言中的通道（channel）是一种特殊的类型 。**通道像一个传送带或者队列，总是遵循先入先出的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h2 id="声明和初始化">声明和初始化</h2><ul><li><strong>声明：</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><ul><li><strong>初始化</strong>：</li></ul><p>声明的chan变量需要用<code>make</code>函数初始化后才能使用，未初始化的chan变量默认为<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)  <span class="comment">// 声明一个缓冲区大小为1的通道</span></span><br></pre></td></tr></table></figure><h2 id="基本操作">基本操作</h2><p>channel有发送，接受，关闭三种操作，发送和接受都使用<code>-&gt;</code>符号</p><ul><li><p><strong>发送</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接收</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></li><li><p><strong>取出所有值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ok判断</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">    v, ok := &lt;-ch    <span class="comment">// 从通道接收数据</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;        <span class="comment">// 如果通道已经关闭，退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(v)  <span class="comment">// 打印接收到的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用range</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> <span class="keyword">chan</span>&#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>**注意：**一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p></blockquote><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408201950086.png" alt=""></p><h2 id="无缓冲通道">无缓冲通道</h2><p>如果在初始化时不设置缓冲区，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时 会报错表示 <code>deadlock</code></p><p>这是因为无缓冲区的通道就表示接收值后无法接收其他值而是处于发送状态，只有在发送出之后才能继续接受值。就好比快递员一次只能送一个快递，而快递柜则可以容纳多个快递</p><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h2 id="有缓冲通道">有缓冲通道</h2><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h2 id="多返回值模式">多返回值模式</h2><p>对一个通道执行接收操作时支持如下多返回值模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;- <span class="keyword">chan</span></span><br></pre></td></tr></table></figure><ul><li><p>value: 从通道中取出的值，如果通道被关闭则返回对应类型的零值</p></li><li><p>ok: 通道ch关闭时返回 false，否则返回 true</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch1</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向通道">单向通道</h2><p>通过<code>-&gt;</code>和<code>chan</code> 的相对位置可以使通道成为 <strong>只接收</strong> 和 <strong>只发送</strong> 两种类型</p><p>比如下面代码里的f1函数和f2函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 &lt;-<span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch1</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> f1(ch1)</span><br><span class="line"><span class="keyword">go</span> f2(ch1, ch2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ret := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="worker-pool-goroutine-池">worker pool (goroutine 池)</h2><p>工作中我们通常使用<code>workerpool</code>模式来控制goroutine的数量</p><details class="toggle" ><summary class="toggle-button" style="">例子</summary><div class="toggle-content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="string">&quot;sync&quot;</span>  </span><br><span class="line"><span class="string">&quot;time&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 结构体，表示任务  </span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;  </span><br><span class="line">ID <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 函数，处理任务  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(id <span class="type">int</span>, tasks &lt;-<span class="keyword">chan</span> Task, wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line"><span class="keyword">defer</span> wg.Done()  </span><br><span class="line"><span class="keyword">for</span> task := <span class="keyword">range</span> tasks &#123;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d: processing task %d\n&quot;</span>, id, task.ID)  </span><br><span class="line"><span class="comment">// 模拟任务处理时间  </span></span><br><span class="line">time.Sleep(time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">const</span> numWorkers = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">const</span> numTasks = <span class="number">10</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建任务通道  </span></span><br><span class="line">tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, numTasks)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工作 goroutines  </span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= numWorkers; w++ &#123;  </span><br><span class="line">wg.Add(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">go</span> Worker(w, tasks, &amp;wg)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= numTasks; i++ &#123;  </span><br><span class="line">tasks &lt;- Task&#123;ID: i&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">close</span>(tasks) <span class="comment">// 关闭任务通道  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有 worker 完成  </span></span><br><span class="line">wg.Wait()  </span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All tasks completed.&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ol><li><strong>Task 结构体</strong>：表示一个任务，这里使用简单的结构体 <code>Task</code> 来表示任务，你可以根据需要添加其他字段。</li><li><strong>Worker 函数</strong>：<ul><li>每个 worker goroutine 在循环中从 <code>tasks</code> 通道接收任务，并对其进行处理。</li><li>使用 <code>fmt.Printf</code> 打印正在处理的任务的 ID。</li><li>使用 <code>time.Sleep</code> 模拟任务处理时的延迟（可以替换为实际任务逻辑）。</li></ul></li><li><strong>主函数</strong>：<ul><li><code>numWorkers</code> 和 <code>numTasks</code> 常量用于定义工作池的大小和要处理的任务数量。</li><li>创建一个 <code>tasks</code> 通道，用于存储任务。</li><li>启动多个 worker goroutines，每个 worker 都会处理来自 <code>tasks</code> 通道的任务。</li><li>向 <code>tasks</code> 通道发送任务并在发送完所有任务后关闭通道。</li><li>使用 <code>sync.WaitGroup</code> 等待所有的 worker 完成任务。</li></ul></li></ol></div></details><h1 id="select多路复用">select多路复用</h1><p>某些场景下我们需要从多个通道中接收数据，我们可以使用<code>select</code>语句，可以同时响应多个通道的操作</p><p>类似于switch语句，select 语句有一系列case分支和默认分支，每个case分支对应一个通道的通信过程，select会等待到其中一个case的通信操作完成后，执行该case分支对应的语句，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> data := &lt;- ch2:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> ch3 &lt;- <span class="number">10</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，</p><p>第一个for循环，i = 0，ch是空的所以会执行第一个case</p><p>第二个for循环，i = 1，ch满了，所以会执行第二个case</p><p>会依次打出 0 2 4 6 8</p><h1 id="并发安全和锁">并发安全和锁</h1><p>在我们的代码中，可能会出现多个goroutine公用一个资源的情况，这种情况下就会发生 <code>竟态问题</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，两个goroutine都在调用<code>add</code>函数，同时对<code>x</code>进行<code>+1</code>操作，会导致两次<code>add</code>操作被覆盖为一次，从而使最后输出的<code>x</code>不到10000</p><p>这个时候我们就可以使用 <code>sync</code> 包中的 <code>mutex</code> 类型来实现互斥锁，达到我们想要的效果</p><h2 id="互斥锁">互斥锁</h2><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Mutex) Lock()</td><td style="text-align:center">获取互斥锁</td></tr><tr><td style="text-align:center">func (m *Mutex) Unlock()</td><td style="text-align:center">释放互斥锁</td></tr></tbody></table><p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量<code>x</code>，从而修复上面代码中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x    <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改写之后，每次运行都会得到10000</p><blockquote><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p></blockquote><h1 id="sync包">sync包</h1><h2 id="sync-waitgroup">sync.WaitGroup</h2><p>Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (wg * WaitGroup) Add(delta int)</td><td style="text-align:center">计数器+delta</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Done()</td><td style="text-align:center">计数器-1</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Wait()</td><td style="text-align:center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done() 方法吧计数器减1，调用 wait() 等待所有并发任务完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg2 sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>, i)</span><br><span class="line">wg2.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg2.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello2(i)</span><br><span class="line">    &#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;fuck you apex&quot;</span>)</span><br><span class="line">wg2.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-once">sync.Once</h2><p>不是很了解，就搬点代码</p><details class="toggle" ><summary class="toggle-button" style="">llll</summary><div class="toggle-content"><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure><p>**注意：**如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p><h4 id="加载配置文件示例">加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line"><span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line">icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发安全的单例模式">并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p></div></details><h2 id="sync-map">sync.Map</h2><p>go语言并发编程中不能使用内置数据类型map，会导致数据竞争问题，所以编译器会报错。sync包中提供了一个并发安全版map，还内置了一下方法</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Map) Store(key, value interface{})</td><td style="text-align:center">存储key-value数据</td></tr><tr><td style="text-align:center">func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td style="text-align:center">查询key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td style="text-align:center">查询或存储key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td style="text-align:center">查询并删除key</td></tr><tr><td style="text-align:center">func (m *Map) Delete(key interface{})</td><td style="text-align:center">删除key</td></tr><tr><td style="text-align:center">func (m *Map) Range(f func(key, value interface{}) bool)</td><td style="text-align:center">对map中的每个key-value依次调用f</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="string">&quot;sync&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">var</span> m sync.Map  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 存储一些值到 sync.Map 中  </span></span><br><span class="line">m.Store(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)  </span><br><span class="line">m.Store(<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>)  </span><br><span class="line">m.Store(<span class="string">&quot;baz&quot;</span>, <span class="number">3</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Range 遍历所有键值对  </span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, key, value)  </span><br><span class="line"><span class="comment">// 返回 true 以继续遍历  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止遍历示例  </span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;bar&quot;</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 停止遍历  </span></span><br><span class="line">&#125;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, key, value)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续遍历  </span></span><br><span class="line">&#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>创建 <code>sync.Map</code></strong>：通过 <code>var m sync.Map</code> 创建一个并发安全的映射。</li><li><strong>存储键值对</strong>：使用 <code>Store</code> 方法将键值对存储到 <code>sync.Map</code> 中。</li><li><strong>遍历映射</strong>：通过 <code>Range</code> 方法遍历映射中的所有项，传入的回调函数会在每个键值对被迭代时被调用。</li><li><strong>停止遍历</strong>：在第二次调用 <code>Range</code> 方法的回调函数中，可以通过返回 <code>false</code> 来提前停止遍历。</li></ol><h1 id="原子操作">原子操作</h1><details class="toggle" ><summary class="toggle-button" style="">以下内容搬运自 [Go语言基础之并发 | 李文周的博客 (liwenzhou.com)](https://www.liwenzhou.com/posts/Go/concurrence/#c-0-6-5)</summary><div class="toggle-content"><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包">atomic包</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">func LoadInt32(addr *int32) (val int32)func LoadInt64(addr *int64) (val int64)func LoadUint32(addr *uint32) (val uint32)func LoadUint64(addr *uint64) (val uint64)func LoadUintptr(addr *uintptr) (val uintptr)func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td style="text-align:center">读取操作</td></tr><tr><td style="text-align:center">func StoreInt32(addr *int32, val int32)func StoreInt64(addr *int64, val int64)func StoreUint32(addr *uint32, val uint32)func StoreUint64(addr *uint64, val uint64)func StoreUintptr(addr *uintptr, val uintptr)func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td style="text-align:center">写入操作</td></tr><tr><td style="text-align:center">func AddInt32(addr *int32, delta int32) (new int32)func AddInt64(addr *int64, delta int64) (new int64)func AddUint32(addr *uint32, delta uint32) (new uint32)func AddUint64(addr *uint64, delta uint64) (new uint64)func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td style="text-align:center">修改操作</td></tr><tr><td style="text-align:center">func SwapInt32(addr *int32, new int32) (old int32)func SwapInt64(addr *int64, new int64) (old int64)func SwapUint32(addr *uint32, new uint32) (old uint32)func SwapUint64(addr *uint64, new uint64) (old uint64)func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td style="text-align:center">交换操作</td></tr><tr><td style="text-align:center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td style="text-align:center">比较并交换操作</td></tr></tbody></table><h3 id="示例">示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Inc() &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Inc() &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Inc() &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">test(c1)</span><br><span class="line">c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">test(&amp;c2)</span><br><span class="line">c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数/类型实现同步更好。</p></div></details><h1 id="练习题">练习题</h1><p>使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。</p><ol><li>开启一个 goroutine 循环生成int64类型的随机数，发送到<code>jobChan</code></li><li>开启24个 goroutine 从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code></li><li>主 goroutine 从<code>resultChan</code>取出结果并打印到终端输出</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(i <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sum += i % <span class="number">10</span></span><br><span class="line">i = i / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addnums</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">randomnum := rand.Int63()</span><br><span class="line">ch &lt;- randomnum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">caul</span><span class="params">(jch &lt;-<span class="keyword">chan</span> <span class="type">int64</span>, rch <span class="keyword">chan</span>&lt;- <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">temp, ok := &lt;-jch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">lock.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lock.Unlock()</span><br><span class="line">rch &lt;- sub(temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">100</span>)</span><br><span class="line">reschan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> addnums(jobchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">24</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> caul(jobchan, reschan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*go func() &#123;</span></span><br><span class="line"><span class="comment">wg.Wait()</span></span><br><span class="line"><span class="comment">close(reschan)</span></span><br><span class="line"><span class="comment">&#125;()*/</span></span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(reschan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp := <span class="keyword">range</span> reschan &#123;</span><br><span class="line">fmt.Println(temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deadlock</strong></p><ol><li>channel阻塞(缓冲区不够)</li><li>channel未关闭</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]常见数据结构</title>
      <link href="/2024/08/15/Go-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/08/15/Go-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组</h2><h3 id="定义：">定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：go语言数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化</p></blockquote><h3 id="初始化：">初始化：</h3><p>三种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明时初始化列表</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ... 省略长度</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引初始化</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125; </span><br></pre></td></tr></table></figure><blockquote><ol><li>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</li><li>数组支持 “==&quot;、”!=&quot; 操作符，因为内存总是被初始化过的。</li></ol></blockquote><h2 id="多维数组">多维数组</h2><h3 id="二维数组的定义："><strong>二维数组的定义</strong>：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说只有第一个参数可以省略</p></blockquote><h2 id="切片-slice">切片(slice)</h2><p>切片的底层就是数组，不同的是切片非常灵活，支持自动扩容</p><h3 id="定义："><strong>定义</strong>：</h3><p><code>var 切片名 []数据类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name[] <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时初始化</span></span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span> = array[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="初始化：">初始化：</h3><ul><li><p><strong>数组得到切片</strong></p><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>切片再次切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    name2 := name[<span class="number">0</span>:<span class="number">1</span>]     <span class="comment">//切片构造切片</span></span><br><span class="line">fmt.Println(name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用make()函数构造切片</strong></p><p>make函数使用格式：<code>make([]T, size, cap)</code></p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用make函数构造切片时会自动加入size个值，默认为0</p></blockquote></li></ul><h3 id="切片增加复制和删除元素">切片增加复制和删除元素</h3><ul><li><p><strong>append()</strong>:</p><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你调用 <code>append</code> 时，Go 会检查切片的容量。如果容量足够容纳新元素，<code>append</code> 将直接在原来的底层数组上添加元素，并返回同一个切片。</li><li>如果当前切片的容量不够，<code>append</code> 将创建一个新的底层数组，复制原有元素并添加新元素，最后返回指向新底层数组的切片。</li></ul></li><li><p><strong>copy()</strong>:</p><p><code>copy(destSlice, srcSlice []T)</code></p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>相当于深拷贝</p></li><li><p><strong>删除元素</strong>：</p><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p></li></ul><h3 id="切片表达式">切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><p>切片表达式就是刚刚初始化切片用到的[]</p><ul><li><p><strong>简单切片表达式</strong>：</p><p><code>a[low : high]</code></p><ul><li><p><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</p></li><li><p><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br></pre></td></tr></table></figure><p>省略部分参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完整切片表达式</strong>：</p><p><code>a[low : high : max]</code></p><ul><li><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</li><li><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</li><li><code>max</code>: 这是切片的最大容量，可以大于 <code>high</code>，但是不能超过原数组的长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表-map">哈希表(map)</h2><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="定义">定义</h3><p><code>map [KeyType]ValueType</code></p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><h3 id="初始化">初始化</h3><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><p><code>make(map[KeyType]ValueType, [cap])</code></p><blockquote><p>注意：map在进行操作前必须用make进行初始化，不然其地址默认为nil</p></blockquote><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本使用">基本使用</h3><ul><li><p>添加数据：</p><p><code>map[key] = value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>          <span class="comment">// 添加键为 &quot;apple&quot;，值为 5  </span></span><br><span class="line">m[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>         <span class="comment">// 添加键为 &quot;banana&quot;，值为 3  </span></span><br><span class="line">m[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span>         <span class="comment">// 添加键为 &quot;orange&quot;，值为 7</span></span><br></pre></td></tr></table></figure></li><li><p>删除数据：</p><p><code>delete(map, key)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断某个键是否存在：</p><p><code>value, ok := map[key]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go]基本语法</title>
      <link href="/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="变量">变量</h1><h2 id="常见变量类型">常见变量类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//布尔型</span><br><span class="line">bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//字符型</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//数值型</span><br><span class="line">有符号 int  int8  int16  int32  int64</span><br><span class="line">无符号 uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">         // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">复数 complex64 complex128</span><br></pre></td></tr></table></figure><blockquote><p>go语言里没有char类型，单个字符会用对应的ASCII码以及别的码以int32类型来存储</p></blockquote><h2 id="变量声明">变量声明</h2><ul><li><p><strong>var关键字</strong>：</p><p>语法：<code>var 变量 类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&#x27;yc&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span>         <span class="comment">//同时定义多个变量</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>短变量声明</strong>：</p><p>语法：<code>变量 := 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&#x27;yc&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认值</strong>:</p><table><thead><tr><th style="text-align:center">变量类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">int, float…</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">‘’</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">切片，函数，指针…</td><td style="text-align:center">null</td></tr></tbody></table></li></ul><h2 id="变量交换">变量交换</h2><p>go语言中由独特的变量交换机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><h2 id="匿名变量">匿名变量</h2><p>匿名变量的特点是是一个下划线&quot;_&quot; , 它可以像别的变量一样被赋值，声明，但不能被使用，因为任何被赋给他的值都会被抛弃</p><p>人话：用来处理不需要的数据，比如多余的函数返回值等</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ = test()</span><br><span class="line">    _ ,b = test()</span><br><span class="line">    fmt.Println(a, b)     <span class="comment">//输出结果为100，200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li><p><strong>局部变量</strong></p><p>函数体内定义的变量，只能在函数体内使用</p></li><li><p><strong>全局变量</strong></p><p>函数外定义的变量，可以在整个go文件使用</p></li></ul><blockquote><p>局部变量可以和全局变量同名，调用时优先考虑局部变量</p></blockquote><hr><h1 id="常量">常量</h1><h2 id="const关键字">const关键字</h2><p>语法：<code>const 常量名 (类型) = 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name <span class="type">string</span> = <span class="string">&quot;yc&quot;</span>   <span class="comment">//显示声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;ycc&quot;</span>         <span class="comment">//隐式声明</span></span><br></pre></td></tr></table></figure><h2 id="iota计数器">iota计数器</h2><p>iota计数器在const中定义，每增加一个常量就加一，在下一个const出现时重置为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span>(</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">        b   <span class="comment">//1</span></span><br><span class="line">        c   <span class="comment">//2</span></span><br><span class="line">        d = <span class="string">&quot;yccc&quot;</span></span><br><span class="line">        e   <span class="comment">//yccc</span></span><br><span class="line">        f = <span class="number">100</span></span><br><span class="line">        g   <span class="comment">//100</span></span><br><span class="line">        h = <span class="literal">iota</span>  <span class="comment">//7</span></span><br><span class="line">        i   <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数据类型">数据类型</h1><p>不多做赘述，就写点快忘记的</p><ul><li><p>转义字符</p><p>”\“后的字符是 转义字符</p><p>常见的转义字符</p><ol><li><strong><code>\n</code></strong>: 换行符</li><li><strong><code>\r</code></strong>: 回车符</li><li><strong><code>\t</code></strong>: 制表符（水平Tab）</li><li><strong><code>\\</code></strong>: 反斜杠（<code>\</code>）</li><li><strong><code>\'</code></strong>: 单引号</li><li><strong><code>\&quot;</code></strong>: 双引号</li><li><strong><code>\b</code></strong>: 退格符</li><li><strong><code>\f</code></strong>: 换页符</li><li><strong><code>\v</code></strong>: 垂直制表符</li><li><strong><code>\a</code></strong>: 响铃（警告音）</li></ol></li><li><p>数据类型转换</p><p>同c</p></li></ul><hr><h1 id="运算符">运算符</h1><h2 id="位运算符">位运算符</h2><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符&quot;&amp;&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td style="text-align:left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">按位或运算符&quot;|&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td style="text-align:left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符&quot;^&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td style="text-align:left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移运算符&quot;&lt;&lt;“是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;“左边的运算数的各二进位全部左移若干位，由”&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移运算符&quot;&gt;&gt;“是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数。</td><td style="text-align:left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr><tr><td style="text-align:left">&amp;^</td><td style="text-align:left">位清空，a&amp;^b，对于被上的每一个值，若为0则取a对应位上的数值，若为1，则取0</td><td style="text-align:left">a&amp;^b结果位48</td></tr></tbody></table><h2 id="赋值运算符">赋值运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td style="text-align:left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">相加后再赋值</td><td style="text-align:left">C += A 等于 C = C + A</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">相减后再赋值</td><td style="text-align:left">C -= A 等于 C = C - A</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">相乘后再赋值</td><td style="text-align:left">C *= A 等于 C = C * A</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">相除后再赋值</td><td style="text-align:left">C /= A 等于 C = C / A</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">求余后再赋值</td><td style="text-align:left">C %= A 等于 C = C % A</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">左移后赋值</td><td style="text-align:left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">右移后赋值</td><td style="text-align:left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">按位与后赋值</td><td style="text-align:left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">按位异或后赋值</td><td style="text-align:left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td style="text-align:left">|=</td><td style="text-align:left">按位或后赋值</td><td style="text-align:left">C |= 2 等于 C = C | 2</td></tr></tbody></table><hr><h1 id="流程控制">流程控制</h1><h2 id="选择结构">选择结构</h2><ul><li><strong>if语句</strong>：</li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;  </span><br><span class="line">    <span class="comment">// 条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> anotherCondition &#123;  </span><br><span class="line">    <span class="comment">// 第一个条件为 false 且第二个条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 所有条件均为 false 时执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>switch语句</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> variable &#123;  </span><br><span class="line"><span class="keyword">case</span> value1:  </span><br><span class="line">    <span class="comment">// 当 variable == value1 时执行的代码  </span></span><br><span class="line"><span class="keyword">case</span> value2:  </span><br><span class="line">    <span class="comment">// 当 variable == value2 时执行的代码  </span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">    <span class="comment">// 如果没有匹配的值，执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环结构">循环结构</h2><blockquote><p>go语言只有<code>for</code>关键字，没有<code>while</code></p></blockquote><ul><li><p>基本for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件循环（类似于<code>while</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">        i++  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>死循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    count := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">        count++  </span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 退出循环  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>range关键字：</p><p>在go语言中，我们可以用<code>range</code>关键字来遍历切片，数组等数据结构</p><p>一般会返回两个值，<code>index</code>和<code>value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, number := <span class="keyword">range</span> numbers &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;索引: %d, 数字: %d\n&quot;</span>, index, number)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="函数">函数</h1><h2 id="函数声明">函数声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数">可变参数</h2><ul><li><p><strong>是什么</strong>：一个函数的参数类型确定，但个数不确定，可以使用可变参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(arg ... <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg ... int会告诉go语言这个函数接收不定数量的参数，类型全是int</span></span><br></pre></td></tr></table></figure></li><li><p><strong>例子</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := getSum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">sum = sum + nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数传递">参数传递</h2><table><thead><tr><th style="text-align:left">传递类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-value.html">值传递</a></td><td style="text-align:left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-reference.html">引用传递</a></td><td style="text-align:left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><h2 id="递归函数">递归函数</h2><p>递归，就是在运行的过程中调用自己。</p><p>语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p><p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p><ul><li>实例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">uint64</span>)</span></span>(result <span class="type">uint64</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">15</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(<span class="type">uint64</span>(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例执行输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 的阶乘是 1307674368000</span><br></pre></td></tr></table></figure><h2 id="defer语句">defer语句</h2><p>在 Go 语言中，<code>defer</code> 语句用于在函数返回之前执行某个操作。它常被用于进行清理工作，比如关闭文件、解锁资源、记录日志等。<code>defer</code> 语句会被推迟执行，直到外层函数返回。</p><p>如果有多个defer语句，会按照先进后出的顺序执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Third  </span><br><span class="line">Second  </span><br><span class="line">First</span><br></pre></td></tr></table></figure><blockquote><p>defer语句一般用于关闭文件，在并发编程中解锁资源等</p></blockquote><h2 id="函数的数据类型">函数的数据类型</h2><p>当我们用printf函数打印函数的类型是，我们会发现编译器会输出函数的类型</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408101757129.png" alt=""></p><p>在 Go 语言中，函数本身也是一种数据类型。这使得函数可以像其他变量一样被赋值、传递和返回。</p><ul><li><p><strong>函数作为变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a + b  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> = add  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := myFunc(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> op(a, b)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := operate(<span class="number">3</span>, <span class="number">4</span>, add)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAdder</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    add5 := getAdder(<span class="number">5</span>)  </span><br><span class="line">    fmt.Println(add5(<span class="number">3</span>)) <span class="comment">// 输出: 8  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="匿名函数">匿名函数</h2><p>匿名函数（又称为闭包）是 Go 语言中一种没有名字的函数。它们可以在定义时立即调用，或者赋值给变量以便之后使用。匿名函数在处理回调、并发等场景中非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f1()</span><br><span class="line">    f2 := f1</span><br><span class="line">    f2()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名函数</span></span><br><span class="line">    f3 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接执行匿名函数（自己调用自己）</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;我是自己调用自己&quot;</span>)</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是f1函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：假设<code>func</code>是一个函数名，则<code>func</code>就是一个函数变量，<code>func()</code>就是在调用这个函数，所以<code>c := func</code> 是在把一个匿名函数赋值给变量c，而 <code>c := func()</code> 则是在就收func的返回值</p></blockquote><h2 id="回调函数">回调函数</h2><ul><li><p><strong>定义</strong>：回调函数是一个函数，它作为参数传递给另一个函数，并在某一时刻被调用。</p></li><li><p><strong>用途</strong>：通常用于处理某些事件或条件后的逻辑执行，例如排序、自定义迭代等。</p></li><li><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, add)</span><br><span class="line"></span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a / b &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a, b <span class="type">int</span>, fun <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">r := fun(a, b)</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包">闭包</h2><p>闭包（Closure）指的是一个函数包含了其外部环境的状态。也就是说，闭包可以“记住”创建时的上下文，即使外部函数已经返回。闭包通常用于实现数据的封装、私有变量或状态的管理。</p><p>在 Go 语言中，闭包非常常见，以下是对闭包的详细解释和示例。</p><ul><li><p>概念</p><p>环境：闭包可以访问其外部函数的变量。</p><p>持久性：即使外部函数执行完毕，闭包仍然可以使用这些外部变量。</p></li><li><p>闭包示例</p><p>下面是一个简单的示例，演示如何在 Go 中使用闭包：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个闭包，生成一个计数器  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    count := <span class="number">0</span> <span class="comment">// 外部变量  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个匿名函数（闭包）  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        count++ <span class="comment">// 修改外部变量  </span></span><br><span class="line">        <span class="keyword">return</span> count  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    counter1 := createCounter() <span class="comment">// 创建第一个计数器  </span></span><br><span class="line">    counter2 := createCounter() <span class="comment">// 创建第二个计数器  </span></span><br><span class="line"></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 1  </span></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 2  </span></span><br><span class="line">    fmt.Println(counter2()) <span class="comment">// 输出: 1  </span></span><br><span class="line">    fmt.Println(counter2()) <span class="comment">// 输出: 2  </span></span><br><span class="line">    fmt.Println(counter1()) <span class="comment">// 输出: 3  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong>：</p><ol><li><p>定义外部变量：在 <code>createCounter</code> 函数中，定义了一个外部变量 <code>count</code>，初始值为 0。</p></li><li><p>返回闭包：该函数返回一个匿名函数（闭包），这个闭包会增加并返回 <code>count</code> 的值。</p></li><li><p>保持状态：每次调用 <code>counter1</code> 和 <code>counter2</code> 时，返回的闭包都会记住自己的 <code>count</code> 状态。尽管 <code>createCounter</code> 函数已经返回，但闭包仍然可以操作 <code>count</code> 变量。</p></li><li><p>独立状态：<code>counter1</code> 和 <code>counter2</code> 是两个独立的计数器，不会互相影响。</p></li></ol></li><li><p><strong>输出结果</strong></p><p>运行上述代码会得到以下输出：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br></pre></td></tr></table></figure><ul><li><p><strong>总结</strong></p><p>闭包是一种强大的工具，可以让你在函数内部保留状态，从而实现更灵活和强大的程序设计。在 Go 语言中，闭包被广泛使用，例如在并发编程、事件处理和数据封装等场景中。</p></li></ul><hr><h1 id="指针">指针</h1><h2 id="声明">声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>   <span class="comment">// 声明一个指向 int 的指针 p  </span></span><br></pre></td></tr></table></figure><h2 id="初始化">初始化</h2><p>指针的初始化通常有两种方式：</p><ol><li><p><strong>使用 <code>new</code> 函数</strong>：<br><code>new(T)</code> 会分配零值的类型 <code>T</code> 的空间，并返回一个指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p 是指向 int 的指针  </span></span><br><span class="line">*p = <span class="number">42</span>       <span class="comment">// 设置指针指向的值为 42  </span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过取地址运算符 <code>&amp;</code></strong>：<br>可以通过取已有变量的地址来初始化指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">10</span>  </span><br><span class="line">p := &amp;x       <span class="comment">// p 是指向 x 的指针  </span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：指针作为引用类型，在使用前必须用new来分配内存空间，否则就会默认指向nil</p></blockquote><hr><h1 id="结构体">结构体</h1><h2 id="定义">定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**注意：**结构体中首字母大写字段表示公开，首字母小写表示私有</p></blockquote><h2 id="实例化">实例化</h2><p><code>var 结构体实例 结构体类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化">初始化</h2><blockquote><p>没有初始化的结构体，成员变量都是对应其类型的零值</p></blockquote><ul><li><p>键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>值的列表初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line"><span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol></li></ul><h2 id="构造函数">构造函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名结构体">匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针类型结构体">指针类型结构体</h2><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><h2 id="匿名字段">匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">&quot;小王子&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="结构体嵌套">结构体嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="方法-method">方法(method)</h1><p>（类似于类和类的成员函数）</p><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><h2 id="定义">定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型，<strong>使用非指针类型时go会复制一个结构体，因此对于较大的结构体应使用指针作为接收者类型</strong></li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> work() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is working...\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := newPerson(<span class="string">&quot;yuchao&quot;</span>, <span class="number">19</span>)</span><br><span class="line">p1.work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接收者分为指针类型的接收者和值类型的接收者，要改变接收者自身参数时应该使用指针类型的接收者</p></blockquote><h2 id="任意类型添加方法">任意类型添加方法</h2><p>go语言中接收者的类型可以是任意类型，不一定要是结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span></span> SayHello() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法</p></blockquote><h2 id="结构体继承">结构体继承</h2><p>类似于面向对象编程中的继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Animal)</span></span> move() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is moving\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> bark()&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s is barking\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := dog&#123;<span class="number">15</span>, Animal&#123;<span class="string">&quot;yc&quot;</span>&#125;&#125;</span><br><span class="line">d1.move()</span><br><span class="line">d1.bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="接口-interface">接口(interface)</h1><blockquote><p>go语言中的接口是一种<strong>类型</strong>，是一种抽象类型</p><p>类似于面向对象编程的多态</p></blockquote><h2 id="定义">定义</h2><p>接口是一个抽象类型，一个接口由多个方法名组成，当我们声明一个接口的实例后，我们可以直接调用这几个方法，和面向对象编程中动态多态性类似</p><p>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><h2 id="实现一个接口的条件">实现一个接口的条件</h2><p>只要一个类型实现了接口中规定的全部方法，那么他就实现了这个接口</p><p>ex：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dg <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dg)</span></span> say() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dog is barking&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;cat is miao&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">da</span><span class="params">(arg sayer)</span></span> &#123;</span><br><span class="line">arg.say() <span class="comment">//不管传经来的是什么，都要say</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := cat&#123;&#125;</span><br><span class="line">da(c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套">接口嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口">空接口</h2><p>空接口没有定义任何方法，因此可以存储任意类型的值</p><p>ex：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 狗结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Dog&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空接口主要有俩个应用</p><ul><li><p>作为函数参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为map里的value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口值">接口值</h2><p>接口值由 <strong>“类型”</strong> 和 <strong>“值”</strong> 组成，我们称之为接口的 <strong>”动态类型“</strong> 和 <strong>”动态值“</strong></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408170052834.png" alt=""></p><p>我们接下来通过一个示例来加深对接口值的理解。</p><p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Move() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;狗在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Brand <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Move() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汽车在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br></pre></td></tr></table></figure><p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface02.png" alt="接口值示例"></p><p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>**注意：**我们不能对一个空接口值调用任何方法，否则会产生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.Move() <span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface03.png" alt="接口值示例"></p><p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c *Car</span><br><span class="line">m = c</span><br></pre></td></tr></table></figure><p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p><p><img src="https://www.liwenzhou.com/images/Go/interface/interface04.png" alt="接口值示例"></p><p>**注意：**此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x Mover = <span class="built_in">new</span>(Dog)</span><br><span class="line">y Mover = <span class="built_in">new</span>(Car)</span><br><span class="line">)</span><br><span class="line">fmt.Println(x == y) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(z == z) <span class="comment">// panic: runtime error: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure><hr><h1 id="一些用法">一些用法</h1><h2 id="生成随机数">生成随机数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)                <span class="comment">//导入包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 使用当前时间设置随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个范围在[0, 2^63)的随机整数</span></span><br><span class="line">    randomInt := rand.Int63()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个范围在[0, 100)的随机整数</span></span><br><span class="line">    randomInt := rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]作业题</title>
      <link href="/2024/08/03/Mysql-%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2024/08/03/Mysql-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目">题目</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031408188.png" alt=""></p><ol><li>查询姓“朱&quot;&quot;的学生名单</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where sname like &#x27;朱%&#x27;</span><br></pre></td></tr></table></figure></div></details><ol start="2"><li>查询同名同性学生名单，并统计同名人数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname, ssex, count(*) from Student group by sname, ssex having count(*) &gt;= 2</span><br></pre></td></tr></table></figure></div></details><ol start="3"><li>查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cid, avg(score) as score from sc group by cid order by score asc, cid desc;</span><br></pre></td></tr></table></figure></div></details><ol start="4"><li>查询平均成绩大于85的所有学生的学号、姓名和平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sid, s.sname, avg(score) </span><br><span class="line">from sc inner join student s on sc.sid = s.sid </span><br><span class="line">group by s.sid, s.sname having avg(score) &gt;= 85</span><br></pre></td></tr></table></figure></div></details><ol start="5"><li>查询课程名称为“睡觉”&quot;，且分数低于60的学生姓名和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--关联查询</span><br><span class="line">select s.sname, c.cname, sc.score </span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid </span><br><span class="line">where sc.score &lt; 60 and c.cname = &#x27;睡觉&#x27;</span><br><span class="line"></span><br><span class="line">--子查询</span><br><span class="line">select s.sname, sc.score from student s, sc where s.sid = sc.sid and sc.score &lt; 60 and sc.cid in (select cid from course c where c.cname = &#x27;睡觉&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="6"><li>查询所有学生的选课情况</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname</span><br><span class="line">from course c left join sc on c.cid = sc.cid left join student s on s.sid = sc.sid</span><br></pre></td></tr></table></figure></div></details><ol start="7"><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname, sc.score</span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid</span><br><span class="line">where sc.score &gt; 70</span><br></pre></td></tr></table></figure></div></details><ol start="8"><li>查询每门课程被选修的学生数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.cname, count(*)</span><br><span class="line">from sc inner join course c on sc.cid = c.cid</span><br><span class="line">group by c.cname</span><br></pre></td></tr></table></figure></div></details><ol start="9"><li>查询不同老师所教不同课程平均分从高到低显示</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">t.tname as &#x27;老师&#x27;, </span><br><span class="line">c.cname as &#x27;课程名&#x27;, </span><br><span class="line">avg(sc.score) as &#x27;平均分&#x27;</span><br><span class="line">from </span><br><span class="line">course c inner join sc on sc.cid = c.cid </span><br><span class="line">inner join teacher t on t.tid = c.tid</span><br><span class="line">group by </span><br><span class="line">t.tname, </span><br><span class="line">c.cname</span><br><span class="line">order by </span><br><span class="line">avg(sc.score) desc</span><br></pre></td></tr></table></figure></div></details><ol start="10"><li>按各科平均成绩从低到高和及格率的百分数从高到低顺序</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">sc.cid, </span><br><span class="line">avg(sc.score),</span><br><span class="line">(select count(*) from sc sc2 where sc2.cid = sc.cid and </span><br><span class="line">     sc2.score &gt;= 60)/count(*)</span><br><span class="line">from </span><br><span class="line">course c inner join sc on c.cid = sc.cid</span><br><span class="line">group by </span><br><span class="line">sc.cid</span><br><span class="line">order by </span><br><span class="line">avg(sc.score)desc</span><br></pre></td></tr></table></figure></div></details><ol start="11"><li>查询和“2&quot;号的同学学习的课程完全相同的其他同学学号和姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select sc.sid, s.sname </span><br><span class="line">from sc </span><br><span class="line">inner join student s on sc.sid = s.sid </span><br><span class="line">where sc.sid not in(</span><br><span class="line">select sc.sid from sc where sc.cid not in(</span><br><span class="line">    select sc.cid from sc where sc.sid = 2</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">group by sc.sid, s.sname</span><br></pre></td></tr></table></figure></div></details><ol start="12"><li>查询学过“黄观&quot;老师所教的所有课的同学的学号、姓名.</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT sc.sid   </span><br><span class="line">FROM sc   </span><br><span class="line">WHERE sc.cid IN (  </span><br><span class="line">    SELECT c.cid   </span><br><span class="line">    FROM course c   </span><br><span class="line">    INNER JOIN teacher t ON t.tid = c.tid   </span><br><span class="line">    WHERE t.tname = &#x27;黄观&#x27;  </span><br><span class="line">)   </span><br><span class="line">GROUP BY sc.sid   </span><br><span class="line">HAVING COUNT(*) = 2;</span><br></pre></td></tr></table></figure></div></details><ol start="13"><li>把“SC“表中&quot;黄观&quot;老师教的课的成绩都更改为此课程的平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="14"><li>查询课程编号“2&quot;的成绩比课程编号&quot;1&quot;课程低的所有同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select sc1.sid, s.sname</span><br><span class="line">from sc sc2, sc sc1 </span><br><span class="line">inner join student s on s.sid = sc1.sid</span><br><span class="line">where (</span><br><span class="line">sc2.score &lt; sc1.score </span><br><span class="line">and sc2.cid = 2 and sc1.cid = 1 </span><br><span class="line">and sc1.sid = sc2.sid</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><ol start="15"><li>查询没学过“黄观&quot;老师课的同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.sid, s.sname </span><br><span class="line">from student s</span><br><span class="line">where s.sid not in(</span><br><span class="line">select sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    where sc.cid in(</span><br><span class="line">    select c.cid </span><br><span class="line">        from course c</span><br><span class="line">        inner join teacher t on t.tid = c.tid</span><br><span class="line">        where t.tname = &#x27;黄观&#x27;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><blockquote><p>select from 只会往from后面的第一个数据表里做查询，不会对inner join的表里查询，因此如果写了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct s.sid, s.sname </span><br><span class="line">from sc</span><br><span class="line">inner join student s on s.sid = sc.sid</span><br><span class="line">where s.sid not in(</span><br><span class="line"><span class="keyword">select</span> sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    inner join course c on c.cid = sc.cid</span><br><span class="line">    inner join teacher t on t.tid = c.tid</span><br><span class="line">    where t.tname = <span class="string">&#x27;黄观&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样是查不出在student表里但不在sc表里的同学的</p></blockquote><ol><li>查询平均成绩大于60分的同学的学号和平均成绩</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]多表查询</title>
      <link href="/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="创建多表关系">创建多表关系</h1><blockquote><p><strong>外键</strong>：把一张表的主键拿到另一张表中作为一个普通的字段，用来联系起两张表</p><p>语法：constraint 外键名 foreign key 字段 references 表(字段名)</p><p>示例：constraint fk_deptNo foreign key (deptNo) references dept(id)</p><p>其中 fk_deptNo是外键名，deptNo是在这张表里这个外键对应的是字段deptNo，dept(id)是在表dept中，外键对应的是字段id</p></blockquote><h2 id="一对一">一对一</h2><ul><li><p>案例：用户与用户详情的关系</p></li><li><p>关系： 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情</p><p>字段放在另外一张表中，以提升操作效率（呈现的是一些分类的信息）</p></li><li><p>实现： 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique)</p><p>例如每个学员有各种信息，然后每种信息都有ID表示，这个时候就能够用id来建立</p><p>（unique）外键实现两个表的关联（这个外键可以特地设置）</p></li></ul><h2 id="一对多">一对多</h2><ul><li><p>案例： 部门与员工的关系</p></li><li><p>关系： 一个部门对应多个员工，一个员工对应一个部门 （员工是多，部门是一）</p></li><li><p>实现： 在多的一方建立外键，指向一的一方的主键</p></li></ul><p><strong>一对多代码实现</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">------dept------</span><br><span class="line">create table dept(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">deptName varchat(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">deptLeader varchar(<span class="number">10</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------employee------</span><br><span class="line">create table employee(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">salary decimal(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">deptNo varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_deptNo foreign key (deptNo) references dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="多对多">多对多</h2><ul><li><p>案例： 学生与课程的关系</p></li><li><p>关系： 一个学生可以选修多个课程，一门课程也能供多个学生选择</p></li><li><p>实现： 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><strong>多对多代码实现</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------student-------</span><br><span class="line">create table stu(</span><br><span class="line">stu_id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">age int(<span class="number">4</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------course-------</span><br><span class="line">create table course(</span><br><span class="line">course_id varchar(<span class="number">10</span>) primary key,</span><br><span class="line">course_name varchar(<span class="number">255</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------student_course------</span><br><span class="line">create table stu_course(</span><br><span class="line">id varchar(<span class="number">100</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">courseID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">stuID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_courseID foreign key (courseID) references </span><br><span class="line">course(course_id),</span><br><span class="line">constraint fk_stuID foreign key (stuID) references stu(stu_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="多表查询">多表查询</h1><h2 id="子查询">子查询</h2><h2 id="关联查询">关联查询</h2><p><strong>语法规则</strong>：<code>A xxx join B on A.字段 = B.字段</code>，当a字段的值和b字段的值相等时就join</p><ol><li><p><strong>inner join</strong></p><p><code>select 字段列表 from 表1 [inner] join 表2 on 连接条件；</code></p><p>相当于查询两表交集</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011937904.png" alt=""></p></li><li><p><strong>left join</strong></p><p><code>select 字段列表 from 表1 left [outer] join 表2 on 条件….；</code></p><p>相当于查询表1的所有数据 包含表1与表2交集部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011938059.png" alt=""></p></li><li><p><strong>right join</strong></p><p><code>select 字段列表 from 表1 right [outer] join 表2 on 条件… ；</code></p><p>相当于查询表2的所有数据，包含表1与表2交集的部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408041326679.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]排序</title>
      <link href="/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="order-by">order by</h1><p>select * from 表名 order by 字段名 asc(升序)/desc(降序)；</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301502381.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DQL基本查询语句</title>
      <link href="/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="查询所有内容："><strong>查询所有内容</strong>：</h1><p><code>select * from 表名</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291824531.png" alt=""></p><h1 id="查询部分信息："><strong>查询部分信息</strong>：</h1><p><code>select 字段名1，字段名2 from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291825490.png" alt=""></p><h1 id="指定列名："><strong>指定列名</strong>：</h1><p><code>select 字段1 as 名称1，字段2 as 名称2.... from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291829760.png" alt=""></p><h1 id="根据指定字段查询："><strong>根据指定字段查询</strong>：</h1><p><strong>where</strong>：</p><ul><li><p><strong>单条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292039972.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291834601.png" alt=""></p></li><li><p><strong>模糊查询</strong>：</p><p><code>select * from 表名 where 字段名 like '%值%'；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001897.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001206.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292003232.png" alt=""></p></li><li><p><strong>in</strong>：</p><p><code>select * from 表名 where 字段名 in &#123;....&#125;；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292005949.png" alt=""></p></li><li><p><strong>判空查询</strong>：</p><p><code>select * from 表名 where 字段名 is null / is not null;</code></p><p>懒得举例子了</p></li></ul><h1 id="聚合函数查询">聚合函数查询</h1><ul><li><strong>语法</strong>: <code>select function(字段名) from 表名;</code><ol><li><strong>max()</strong></li><li><strong>min()</strong></li><li><strong>avg()</strong></li><li><strong>count()</strong></li><li><strong>sum()</strong></li></ol></li></ul><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301345917.png" alt=""></p><ul><li><p><strong>聚合函数配合group by</strong>:</p><p>作用：按照需要字段分组查询</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301431926.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301432410.png" alt=""></p></li><li><p><strong>having</strong>：</p><p>作用：<strong>对于分组后的数据</strong>按照指定字段进行筛选</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2    having 约束;</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301437352.png" alt=""></p></li></ul><h1 id="综合使用">综合使用</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031428620.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DML增删改操作</title>
      <link href="/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="增加">增加</h1><ol><li><p><strong>单条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values(值1，值2，值3....)</code></p><blockquote><p>注意：传字符串时要手动加上单引号</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291655861.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values</code></p><p>(值1，值2，值3…),</p><p>(值1，值2，值3…);</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291659546.png" alt=""></p></li></ol><h1 id="修改">修改</h1><ul><li><p><code>update 表名 set 字段名1 = 值1，字段名2 = 值2，..... where(限定条件)；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291707563.png" alt=""></p></li></ul><h1 id="删除">删除</h1><ul><li><p><code>delete from 表名 条件限制</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291709519.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]基本DDL操作</title>
      <link href="/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ddl是什么">DDL是什么</h1><p>数据定义语言，用来创建删除修改数据结构</p><h1 id="数据库操作">数据库操作</h1><ol><li><p><strong>创建</strong>：</p><p><code>create database 数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281956271.png" alt=""></p></li><li><p><strong>删除</strong>：</p><p><code>drop database 数据库名；</code></p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958803.png" style="zoom:150%;" /></li><li><p><strong>查询所有数据库</strong>：</p><p><code>show databases;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958717.png" alt=""></p></li><li><p><strong>查询当前数据库</strong>：</p><p><code>select database();</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281959343.png" alt=""></p></li><li><p><strong>使用数据库</strong>：</p><p><code>use  数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282000951.png" alt=""></p></li></ol><h1 id="表的操作">表的操作</h1><h2 id="创建">创建</h2><p>要先指定使用一个数据库</p><p>create table 表的名字{</p><p>​字段名 类型(长度) 约束，</p><p>​字段…</p><p>};</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282007932.png" alt=""></p><p><strong>约束</strong>：</p><ol><li><p>主键约束：唯一地表示一条数据，使其不可以重复，主键不可以为空。</p><p>primary key auto_increment</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282024574.png" alt=""></p></li><li><p>非空约束：这一列数据不允许为空</p><p>not null</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282027885.png" alt=""></p></li><li><p>默认值约束：设置默认值</p><p>default 默认值</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282028665.png" alt=""></p></li><li><p>唯一性约束：数据不允许重复</p><p>unique</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282030689.png" alt=""></p></li></ol><h2 id="删除">删除</h2><p><code>drop table 表名;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291403019.png" alt=""></p><h2 id="修改表结构">修改表结构</h2><ol><li><p><strong>添加字段</strong>：</p><p><code>alter table 表名 add 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291407182.png" alt=""></p></li><li><p><strong>删除字段</strong>：</p><p><code>alter table 表名 drop column 字段名</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291409972.png" alt=""></p></li><li><p><strong>修改字段</strong>：</p><p><code>alter table 表明 modify 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291412790.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]STL标准库</title>
      <link href="/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>C++ STL（标准模板库）提供了多种容器，每种容器都有其特定的功能和一组基本函数。以下是一些常用容器及其基本函数的概览：</p><h3 id="1-序列容器-sequential-containers">1. 序列容器（Sequential Containers）</h3><ul><li><strong>vector</strong><ul><li><code>push_back()</code>: 在容器末尾添加一个元素。</li><li><code>pop_back()</code>: 删除容器末尾的元素。</li><li><code>size()</code>: 返回容器中元素的数量。</li><li><code>capacity()</code>: 返回容器分配的内存足以容纳的元素数量。</li><li><code>reserve()</code>: 改变当前容器的容量。</li><li><code>clear()</code>: 移除容器中的所有元素。</li><li><code>begin()</code>/<code>end()</code>: 返回指向容器开始和结束的迭代器。</li></ul></li><li><strong>deque</strong>（双端队列）<ul><li><code>push_front()</code>: 在容器开头添加一个元素。</li><li><code>pop_front()</code>: 删除容器开头的元素。</li><li>其他函数与 <code>vector</code> 类似。</li></ul></li><li><strong>list</strong><ul><li><code>push_front()</code>: 在列表开头添加一个元素。</li><li><code>pop_front()</code>: 删除列表开头的元素。</li><li><code>sort()</code>: 排序列表中的元素。</li><li>其他函数与 <code>vector</code> 类似，但不支持随机访问迭代器。</li></ul></li><li><strong>forward_list</strong><ul><li>功能类似于 <code>list</code>，但只支持单向迭代。</li></ul></li><li><strong>array</strong><ul><li><code>at()</code>: 安全访问元素，带边界检查。</li><li><code>operator[]</code>: 访问元素。</li><li><code>fill()</code>: 用给定值填充所有元素。</li></ul></li><li><strong>string</strong><ul><li><code>push_back()</code>: 在字符串末尾添加一个字符。</li><li><code>pop_back()</code>: 删除字符串末尾的字符。</li><li><code>size()</code>/<code>length()</code>: 返回字符串长度。</li><li><code>clear()</code>: 清空字符串。</li><li><code>substr()</code>: 返回子字符串。</li><li><code>find()</code>: 查找子字符串的位置。</li></ul></li></ul><h3 id="2-容器适配器-container-adapters">2. 容器适配器（Container Adapters）</h3><ul><li><strong>stack</strong>（栈）<ul><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 删除栈顶元素。</li><li><code>top()</code>: 获取栈顶元素的引用。</li></ul></li><li><strong>queue</strong>（队列）<ul><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 删除队首元素。</li><li><code>front()</code>: 获取队首元素的引用。</li></ul></li><li><strong>priority_queue</strong>（优先队列）<ul><li><code>push()</code>: 在优先队列中添加一个元素。</li><li><code>pop()</code>: 删除具有最高优先级的元素。</li><li><code>top()</code>: 获取最高优先级元素的引用。</li></ul></li></ul><h3 id="3-关联容器-associative-containers">3. 关联容器（Associative Containers）</h3><ul><li><strong>set</strong>（集合）<ul><li><code>insert()</code>: 插入一个元素。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找元素。</li></ul></li><li><strong>multiset</strong><ul><li>与 <code>set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>map</strong>（映射）<ul><li><code>insert()</code>: 插入一个键值对。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找具有特定键的元素。</li></ul></li><li><strong>multimap</strong><ul><li>与 <code>map</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_set</strong>（无序集合）<ul><li>功能类似于 <code>set</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multiset</strong><ul><li>与 <code>unordered_set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_map</strong>（无序映射）<ul><li>功能类似于 <code>map</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multimap</strong><ul><li>与 <code>unordered_map</code> 类似，但允许多个具有相同键的元素。</li></ul></li></ul><h3 id="4-其他容器">4. 其他容器</h3><ul><li><p>bitset</p><p>（位集）</p><ul><li><code>set()</code>: 设置指定位数为1。</li><li><code>reset()</code>: 设置指定位数为0。</li><li><code>flip()</code>: 翻转指定位数的值。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[代码随想录]字符串</title>
      <link href="/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="实现strstr"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">实现strStr()</a></h1><h2 id="题目">题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p>我们把 <code>haystack</code> 称为<strong>主串</strong>，把 <code>needle</code>称为<strong>模式串</strong> 。</p><h2 id="kmp算法">KMP算法</h2><h3 id="基本思想"><strong>基本思想</strong></h3><p>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p><h3 id="前缀和后缀"><strong>前缀和后缀</strong></h3><p>前缀：包含第一个字母但不包含最后一个字母</p><p>后缀：包含最后一个字母但不包含第一个字母</p><p>**注意：**前后缀都是连续抽取的子串</p><p><strong>例子</strong>：</p><p>有字符串&quot;aabaaf&quot;</p><p>前缀是：a,aa,aab…,aabaa</p><p>后缀是：abaaf,baaf,…,f</p><h3 id="前缀表-关键"><strong>前缀表（关键）</strong></h3><p>一般用一个next数组来储存</p><ul><li><p><strong>最长相等前后缀</strong></p><p>指一个字符串里相同前后缀的最长字符串（<strong>注意是要存的一个数值，一个字符串只有一个最长相等前后缀</strong>）</p><p><strong>例子</strong>：</p><p>字符串”aabaa“， 前缀有a, aa, aab, aaba, 后缀有abaa, baa, aa, a. 相同的前后缀有a, aa.所以最长相等前后缀就是2</p></li><li><p><strong>前缀表是什么</strong></p><p>前缀表是一个存储<strong>最长相等前后缀长度</strong>的数组</p><p>换句话说，它告知如果在 <code>needle</code> 中发生了不匹配，我们可以跳过多少个字符继续比较。</p><p><strong>其中第 i 个元素表示的是模式串前 i 个元素所组成的字串的最长相等前后缀</strong>，因此可以直接用next[a]来回退。</p><p><strong>例子</strong>：</p><p>模式串aabaaf，</p><p>前缀表的前 1 个元素构成的字符串为 ：”a“，最大相等前后缀为 0，所以next[0] = 0</p><p>前缀表的前 2 个元素构成的字符串为 ：”aa“，最大相等前后缀为 1，所以next[1] = 1</p><p>前缀表的前 3 个元素构成的字符串为 ：”aab“，最大相等前后缀为 0 ，所以next[2] = 0，以此类推…</p><p>所以字符串 aabaaf 的前缀表就是 {0，1，0，1，2，0}</p></li><li><p><strong>前缀表的作用（关键）</strong></p><p>当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。<strong>而不是一个字符一个字符遍历</strong></p></li><li><p><strong>前缀表的代码实现</strong></p><ol><li><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure><p><strong>变量 j 表示的是最长相等前后缀长度，而s[j] 则表示相等前后缀最后一个字符的再后面一个字符</strong>，而将next数组的第一个元素赋值为-1和KMP理论层面无关，是实现时加入的一个设定，可以更改</p></li><li><p><strong>建立for循环构建next数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br></pre></td></tr></table></figure><p><strong>变量 i 表示的是后缀的最后一个字符</strong>，等于0时是不存在最长相等前后缀的，所以从1开始</p><p>在进入循环介绍前，我们要先知道，在整个构造前缀表的过程中，<strong>变量 j 是一直在来回移动的</strong>，因为每个 i 对应最长相等前后缀是不同的，而<strong>变量 i 则是一个一个遍历下去</strong>，每个 i 对应一个前缀表的数值</p></li><li><p><strong>处理前后缀不相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; </span><br><span class="line">    j = next[j]; <span class="comment">// 前后缀不相同了就向前回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用while循环的原因：i 增加1之后，有可能会导致最长相等前后缀长度直接减少2或更多，</p><p>为什么next[j]是回退：首先明确next数组的作用就是存储最长相等前后缀长度,再明确回退要保证next[i]之前的字符与回退后next[j]之前的是相同的，所以可以利用next数组来进行回退，而因为next数组第一个元素是-1所以可以直接用j作为索引。</p><blockquote><p><strong>注意</strong>：next[j]中直接访问 j 下标的元素是因为next的第一个元素默认为-1，这之后才是有效数值，这便是实现层面上的设定。</p></blockquote></li><li><p><strong>处理前后缀相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure><p><code>j++</code>使得 j 表示最长相等前后缀长度 而不是最后一个字符的索引位置</p><p>这样一来在下一个循环中s[ j ]就会再往后指向一个新的字符来和新的s[ i ]来比较，如果s[ i ]等于s[ j ]，那么就可以直接加上，因为这之前的字符已经在之前的循环中判断过了，如果不等于，就要往前回退到next[ j ]的位置。</p></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="kmp解题主要思路">KMP解题主要思路</h3><ol><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br></pre></td></tr></table></figure></li><li><p>建立for循环遍历haystack</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)</span><br></pre></td></tr></table></figure><p>注意：本题中通过next数组使得 j 不断回退，这样确保了haystack[i]和needle[j + 1]之前的字符已经是相等的，所以从头到尾只需要比较 haystack[i] 和 needle[j + 1] 这两个字符</p></li><li><p>处理不匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到了结束循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line"><span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">            j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">            j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="题目答案">题目答案</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]类模板中的友元函数</title>
      <link href="/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
      <url>/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引入">问题引入</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::<span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::~<span class="built_in">Dvector</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt; Dvector&lt;T&gt;::<span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="function">Dvector&lt;T&gt; <span class="title">result</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        result.data.<span class="built_in">push_back</span>(<span class="keyword">this</span>-&gt;data[i] + d1.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Dvector&lt;T&gt;::<span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        sum += <span class="keyword">this</span>-&gt;data[i] * d1.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">        os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="function">Dvector&lt;<span class="type">int</span>&gt; <span class="title">vecA</span><span class="params">(<span class="number">6</span>, a)</span>,<span class="title">vecB</span><span class="params">(<span class="number">6</span>, b)</span>,<span class="title">vecC</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    vecC = vecA + vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;vecC&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> iResult = vecA * vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;iResult&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在vscode上报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">warning: <span class="title">friend</span> <span class="title">declaration</span> &#x27;<span class="title">std</span>::<span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt;(<span class="title">std</span>::<span class="title">ostream</span>&amp;, <span class="title">linkStack</span>&lt;<span class="title">T</span>&gt;&amp;)&#x27; <span class="title">declares</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">template</span> <span class="title">function</span> [-<span class="title">Wnon</span>-<span class="title">template</span>-<span class="title">friend</span>]|</span></span><br></pre></td></tr></table></figure><h1 id="问题解读">问题解读</h1><h2 id="原因">原因</h2><p><strong>这段报错的意思是这里声明了一个非模板友元函数，编译器识别出来后警告(注意不是报错)</strong></p><p>为了解决这个警告，我们来补充模板类中的三种友元函数：</p><h2 id="非模板友元函数">非模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种友元函数仅仅只对应于一个特定类，<strong>不具有模板化的特性</strong>，因此不应该在模板类中这样定义一个友元函数。</p><h2 id="约束模板友元函数">约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//声明模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//声明类的友元函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Arrat&lt;T&gt; A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Array&lt;T&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>何为约束</strong>：<code>friend ostream&amp; operator &lt;&lt; &lt;&gt;(ostream&amp; os, const Array&lt;T&gt; A)&#123;</code>这行代码中的<code>&lt;&gt;</code>起到了提醒编译器这是一个模板实例化，参数类型与类模板中<strong>相同</strong>，不能接受不同类型的对象，所以是约束模板友元函数。</p><h2 id="非约束模板友元函数">非约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">//另外声明了一个模板</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="type">const</span> Array&lt;U&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过该模板友元函数定义的友元函数可以接受不同的类型，所以是非约束的。</p><hr><h1 id="解决方案">解决方案</h1><ol><li><p><strong>直接再模板类内部定义友元函数体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">       os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为约束模板友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为非约束友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]模板</title>
      <link href="/2024/05/27/c-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/05/27/c-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板">函数模板</h1><h2 id="函数模板与模板函数">函数模板与模板函数</h2><ul><li><p><strong>适用场景</strong>：对处理逻辑相同，只是参数类型不同的函数</p></li><li><p><strong>声明</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表);</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表);</p></li><li><p><strong>定义</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p></li><li><p><strong>示例</strong>：</p><p>定义一个返回数组最小值的函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">MinInArray</span><span class="params">(T* array, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    T min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优先级</strong>：</p><p>当函数模板和重载函数同时存在时，编译器会优先使用重载函数。</p></li></ul><h1 id="类模板">类模板</h1><ul><li><p><strong>声明和定义</strong>：</p><ul><li><p><strong>类的声明定义</strong>：</p><p>template &lt;typename 类型参数名1，…&gt;</p><p>class 类模板名</p><p>{</p><p>​… //类模板体</p><p>}；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyTemplateClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>类的成员函数</strong>：</p><p>template&lt;typename 类型参数名1，…&gt;</p><p>返回值类型  类模板名&lt;类型参数名&gt;::成员函数名（形参表）{</p><p>​…   //函数体</p><p>}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyTemplateClass&lt;T&gt;::<span class="built_in">display</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>用类模板产生模板类</strong>：</p><p>类模板名 &lt;类型1，…&gt;</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p><strong>类模板建立对象</strong>：</p><p>类模板名 &lt;类型参数名&gt; 对象1，对象2…</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTemplateClass&lt;<span class="type">int</span>&gt; obj1,obj2........</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]运算符重载</title>
      <link href="/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="第一操作数">第一操作数</h1><ul><li><strong>第一操作数</strong>：运算符左侧的操作数</li></ul><h1 id="成员运算符重载">成员运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数是当前类对象时</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (const  第二操作数的引用){</p><p>​//所进行的操作</p><p>​return …</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex <span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">        complex result;</span><br><span class="line">        result.real = real + c.real;</span><br><span class="line">        result.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> real;</span><br><span class="line">    <span class="type">int</span> imag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ul><h1 id="友元运算符重载">友元运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数不是当前类对象，但是要访问到类中的私有成员时</p></li><li><p><strong>实现方式</strong>：</p><p>friend  返回值类型  operator  运算符  (第一操作数的引用，第二操作数的引用){</p><p>​//操作</p><p>​return…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">    os&lt;&lt;c.real&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么返回值要设为ostream&amp; ：允许连续输出，例如cout&lt;&lt;c1&lt;&lt;c2&lt;&lt;c3&lt;&lt;endl</p></blockquote></li></ul><h1 id="非成员函数重载">非成员函数重载</h1><ul><li><p><strong>适用场景</strong>：既不需要访问类的私有成员，也不需要直接修改类的对象</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (常引用)  {</p><p>​…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-num.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]继承与多态</title>
      <link href="/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="公有继承和is-a关系">公有继承和is-a关系</h1><h2 id="继承和派生">继承和派生</h2><p><code>派生</code>：同一个类可以派生出多个子类，将这个类称为<strong>基类</strong>，派生出的子类称为<strong>派生类</strong>，同时把子类简介派生出的所有类统称为它的<strong>子孙类</strong>，把一个子类之前的所有类都统称为它的<strong>祖先类</strong></p><p><code>继承</code>：每个派生出的子类继承了基类的<strong>公有(public)属性</strong>和<strong>公有函数</strong>描述的功能</p><p><code>is-a关系</code>（公有继承）：指一个类是另一个类的一种特殊形式，通常用于描述继承关系。比如，狗是一种动物，所以狗类可以继承自动物类。在代码中通常体现为类的继承关系。</p><p>再复习一下<strong>has-a</strong>关系</p><p><code>has-a</code>（私有继承）：指一个类包含另一个类的对象作为其成员变量，通常用于描述组合关系。比如，汽车有一个引擎，所以汽车类可以包含一个引擎对象作为其成员变量。在代码中通常体现为类的成员变量。</p><hr><h1 id="派生类">派生类</h1><h2 id="派生类定义">派生类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类公有函数成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//派生类私有数据成员</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="派生类访问控制">派生类访问控制</h2><p><strong>可以访问</strong>：<strong>public</strong> ,<strong>protected</strong></p><p><strong>不可以访问</strong>：<strong>private</strong></p><p><strong>如何访问</strong>：</p><p>有基类<code>person</code> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有派生类<code>student</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问<code>student</code>的<code>name</code>和<code>age</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; student.name;</span><br><span class="line">cout &lt;&lt; student.age;</span><br></pre></td></tr></table></figure><h2 id="派生类定义样例">派生类定义样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is sleeping&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed) : <span class="built_in">Animal</span>(name), <span class="built_in">m_breed</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_breed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造与析构">派生类构造与析构</h2><blockquote><p><strong>注意</strong>：在调用派生类构造函数时如果不显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。如果基类没有默认构造函数，且派生类构造函数没有显式调用基类构造函数，则会导致编译错误。</p><blockquote><details class="toggle" ><summary class="toggle-button" style="">具体示例</summary><div class="toggle-content"><blockquote><p>在下面的示例中，基类Person没有默认构造函数，而派生类Student的构造函数没有显式调用基类构造函数，将会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> grade) : <span class="built_in">m_grade</span>(grade) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">myStudent</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，派生类Student的构造函数没有显式调用基类Person的构造函数，因为基类Person没有默认构造函数，编译器无法自动调用基类的构造函数，导致编译错误。为了避免这种情况，应该在派生类的构造函数中显式调用基类的构造函数，以确保正确地初始化基类的成员变量。</p><blockquote></blockquote></blockquote></div></details></blockquote></blockquote><p><strong>派生类构造函数示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPerson</span>(string name,<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)</span><br><span class="line">&#123;&#125;<span class="comment">//基类构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CStudent</span>(string name,<span class="type">int</span> age,<span class="type">int</span> number)</span><br><span class="line">:<span class="built_in">CPerson</span>(name,age),<span class="built_in">number</span>(number)</span><br><span class="line">&#123;&#125;<span class="comment">//派生类构造函数</span></span><br></pre></td></tr></table></figure><p><strong>构造函数和析构函数调用顺序</strong>：</p><p>基类 -&gt; 成员对象 -&gt; 派生类</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：ABC</p><hr><h1 id="同名覆盖原则">同名覆盖原则</h1><p>**定义：**如果派生类新增的数据成员或函数成员与基类同名，则基类中的同名成员会被覆盖，如果要访问基类中的同名函数，则需要添加基类名<code>::</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studZhang.Person::<span class="built_in">show</span>();  <span class="comment">//studZhang是一个CStudent类的对象，Person是它的基类</span></span><br></pre></td></tr></table></figure><h1 id="赋值兼容原则">赋值兼容原则</h1><p><strong>定义：</strong></p><ol><li><p><strong>基类指针</strong>可以指向<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p><strong>基类引用对象</strong>可以引用<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p>普通变量，函数传参，函数返回对象时将子孙类对象赋值给基类对象时，会存在切片现象。（变成基类对象）</p></li></ol><hr><h1 id="多态性与虚函数">多态性与虚函数</h1><h2 id="多态性">多态性</h2><p><code>静态多态性</code>：通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现（根据传参类型即可确定要调用的函数，<strong>在编译时完成（静态绑定）</strong>，所以是静态）</p><p><code>动态多态性</code>：通过<strong>虚函数</strong>实现（根据基类指针实际指向的对象类型来确定调用的函数，<strong>在运行时完成（动态绑定）</strong>） ，<strong>在基类指针/对象指向派生类指针/对象时最能体现</strong>。</p><h2 id="虚函数">虚函数</h2><ol><li><p>声明语法：</p><p>在基类中声明：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​在派生类中重写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>到底是干嘛的</p><p>比如同样是动物的叫，狗是bark，猫是meow，这个时候就有动态多态性的感觉了，就会使用虚函数。</p><p>动物是基类，狗和猫是派生类，叫就是一个虚函数。</p></li><li><p>使用时和普通函数的区别</p><p>前文提到了在基类指针/对象指向派生类指针/对象时最能体现动态多样性，这是因为在通过基类指针/对象访问派生类指针/对象的函数时，如果这个函数是虚函数，那么编译器就会在这个类的虚函数表中找到对应的虚函数来调用（这就是动态多样性），而如果是普通函数，那就会直接调用基类的这个函数。</p><p>例如：有一个基类指针<code>Person</code>指向派生类对象<code>Student</code>,基类和派生类中都有一个函数是<code>show()</code></p><ul><li>如果<code>show()</code>是虚函数：</li></ul><p><code>Person-&gt;show()</code>调用的是派生类<code>Student</code>的<code>show()</code></p><ul><li>如果不是：</li></ul><p><code>Person-&gt;show()</code>调用的就是基类<code>person</code>的<code>show()</code>函数</p><ul><li>如果基类没有这个函数：</li></ul><p>编译器会直接报错</p></li><li><p>底层逻辑</p></li></ol><p>对于使用虚函数的类，编译器会在其内部生成一个虚函数表，用来存储该类所有的虚函数，用基类指针或引用调用虚函数时，会从这个表中找到对应的虚函数并返回指针，从而实现动态绑定。</p><h2 id="纯虚函数和抽象类">纯虚函数和抽象类</h2><ol><li>声明语法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Funtion</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><code>抽象类</code>：包含纯虚函数的类</p><h2 id="派生类对象的克隆">派生类对象的克隆</h2><blockquote><p>用虚函数来克隆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* clonedBase = base-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* clonedDerived = derived-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedDerived-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">delete</span> clonedBase;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> clonedDerived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚基类">虚基类</h1><h2 id="菱形继承问题">菱形继承问题</h2><p><strong>在类的继承关系如下时发生</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure><p>在上面的继承结构中，类 <code>A</code> 是基类，类 <code>B</code> 和 <code>C</code> 都直接继承自 <code>A</code>，而类 <code>D</code> 继承自 <code>B</code> 和 <code>C</code>。由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在 <code>D</code> 中将会包含两份来自 <code>A</code> 的数据。这就是有菱形继承问题的原因。</p><p><strong>导致以下问题</strong>：</p><ol><li><p>内存浪费</p></li><li><p>二义性：</p><p>如果 <code>A</code> 类定义了一个成员函数 <code>foo()</code>，<code>B</code> 类和 <code>C</code> 类分别重写了这个函数，在 <code>D</code> 类中调用 <code>foo()</code> 函数，编译器就无法确定应该调用哪个版本的 <code>foo()</code> 函数，从而产生二义性。</p></li></ol><h2 id="用虚基类解决菱形继承问题">用虚基类解决菱形继承问题</h2><ul><li><p><strong>如何解决</strong>：</p><p>声明虚基类后，编译器会自动调用最终重写的版本。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling A&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling B&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling C&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        B::<span class="built_in">foo</span>(); <span class="comment">// 明确调用 B 类的 foo()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();  <span class="comment">// 在 D 类中调用 foo() 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">callFoo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling B<span class="number">&#x27;</span><span class="function">s <span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>如果没有声明虚基类，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference to &#x27;foo&#x27; is ambiguous</span><br></pre></td></tr></table></figure><p>如果没有最终的重写函数，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no unique final overrider <span class="keyword">for</span> &#x27;virtual void A::foo()&#x27; <span class="keyword">in</span> &#x27;D&#x27;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="补充">补充</h1><ul><li><p><strong>将构造函数定义为纯虚函数是没有意义的</strong></p><p>构造函数是用来创造对象的，而含有纯虚函数的类不能创造对象，所以无意义</p></li><li><p><strong>动态绑定只发生在，用基类指针或基类引用调用虚函数时，用派生类指针或引用调用虚函数时会直接确定要调用的虚函数，这是静态绑定</strong></p><p>例：有一个派生类对象a，a类中有虚函数b()，使用a.b()时不会发生动态绑定。</p></li><li><p><strong>派生类中虚函数必须和基类中完全一样（返回值，形参）</strong></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写点什么">写点什么</h1><p>想了很久我的第一篇博客应该写点什么，但是突然发现这好像违背了我创建博客的初心，在我看来博客应该想写什么就写什么，我希望把我的博客当作一个树洞，既可以记录我的生活，又可以倾诉我的情绪，在这里可以看到最真实的自己。</p><p>至于为什么到现在才搭建好我的博客，想到这个问题脑子里突然闪过好多理由，但里有终究是理由，根本还是我自己的原因，因此我想做出改变，我一定可以看到自己的改变。</p><h1 id="最近">最近</h1><h3 id="搭博客">搭博客</h3><p>首先奉上我跟的教程</p><p>​<a href="https://nickxu.me/tags/%E5%BB%BA%E7%AB%99%E6%8A%80%E5%B7%A7/">标签: 建站技巧 | NX の 博客 (nickxu.me)</a></p><p>​<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>搭博客的过程可谓曲折，捣鼓了5、6天却一直报出奇怪的错误，不过也让我对流程十分熟悉，以后有机会一定要写一篇搭博客的教程。</p><h3 id="期中考试-0512">期中考试(0512)</h3><p>上个礼拜都在复习昨天的期中考试，这个学期想努力一下，要拿到奖学金（因为感觉上学期不是很认真都差点成功了），但是昨天的大物让我一言难尽，感觉一拳打在棉花上的感觉，无法读懂出题老师的意图，而且考的知识点像高中物理，甚至出现了万有引力。至于高数感觉还是上学期挖的坑太大了，输在了微积分基础上。但是现在还没出成绩，也许等出了成绩之后会更破防。</p><h3 id="debug杯-0508">Debug杯(0508)</h3><p>第一次参加大学里的比赛，目标是为了混到德育分，但是没想到大部分的人和我的想法是一样的，以至于我最后甚至混到了一个三等奖，真是抽象。</p><h1 id="结语">结语</h1><p>忘记还想要写些什么了，下次再来补吧。最后送自己一句话：Think Less,Do More.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/06/hello-world/"/>
      <url>/2024/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
