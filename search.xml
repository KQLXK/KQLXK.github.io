<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Go]基本语法</title>
      <link href="/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/08/06/Go-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="变量">变量</h1><h2 id="常见变量类型">常见变量类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//布尔型</span><br><span class="line">bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//字符型</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//数值型</span><br><span class="line">有符号 int  int8  int16  int32  int64</span><br><span class="line">无符号 uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">         // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">复数 complex64 complex128</span><br></pre></td></tr></table></figure><blockquote><p>go语言里没有char类型，单个字符会用对应的ASCII码以及别的码以int32类型来存储</p></blockquote><h2 id="变量声明">变量声明</h2><ul><li><p><strong>var关键字</strong>：</p><p>语法：<code>var 变量 类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&#x27;yc&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span>         <span class="comment">//同时定义多个变量</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>短变量声明</strong>：</p><p>语法：<code>变量 := 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&#x27;yc&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认值</strong>:</p><table><thead><tr><th style="text-align:center">变量类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">int, float…</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">‘’</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">切片，函数，指针…</td><td style="text-align:center">null</td></tr></tbody></table></li></ul><h2 id="变量交换">变量交换</h2><p>go语言中由独特的变量交换机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><h2 id="匿名变量">匿名变量</h2><p>匿名变量的特点是是一个下划线&quot;_&quot; , 它可以像别的变量一样被赋值，声明，但不能被使用，因为任何被赋给他的值都会被抛弃</p><p>人话：用来处理不需要的数据，比如多余的函数返回值等</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ = test()</span><br><span class="line">    _ ,b = test()</span><br><span class="line">    fmt.Println(a, b)     <span class="comment">//输出结果为100，200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li><p><strong>局部变量</strong></p><p>函数体内定义的变量，只能在函数体内使用</p></li><li><p><strong>全局变量</strong></p><p>函数外定义的变量，可以在整个go文件使用</p></li></ul><blockquote><p>局部变量可以和全局变量同名，调用时优先考虑局部变量</p></blockquote><hr><h1 id="常量">常量</h1><h2 id="const关键字">const关键字</h2><p>语法：<code>const 常量名 (类型) = 值</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name <span class="type">string</span> = <span class="string">&quot;yc&quot;</span>   <span class="comment">//显示声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;ycc&quot;</span>         <span class="comment">//隐式声明</span></span><br></pre></td></tr></table></figure><h2 id="iota计数器">iota计数器</h2><p>iota计数器在const中定义，每增加一个常量就加一，在下一个const出现时重置为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span>(</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">        b   <span class="comment">//1</span></span><br><span class="line">        c   <span class="comment">//2</span></span><br><span class="line">        d = <span class="string">&quot;yccc&quot;</span></span><br><span class="line">        e   <span class="comment">//yccc</span></span><br><span class="line">        f = <span class="number">100</span></span><br><span class="line">        g   <span class="comment">//100</span></span><br><span class="line">        h = <span class="literal">iota</span>  <span class="comment">//7</span></span><br><span class="line">        i   <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数据类型">数据类型</h1><p>不多做赘述，就写点快忘记的</p><ul><li><p>转义字符</p><p>”\“后的字符是 转义字符</p><p>常见的转义字符</p><ol><li><strong><code>\n</code></strong>: 换行符</li><li><strong><code>\r</code></strong>: 回车符</li><li><strong><code>\t</code></strong>: 制表符（水平Tab）</li><li><strong><code>\\</code></strong>: 反斜杠（<code>\</code>）</li><li><strong><code>\'</code></strong>: 单引号</li><li><strong><code>\&quot;</code></strong>: 双引号</li><li><strong><code>\b</code></strong>: 退格符</li><li><strong><code>\f</code></strong>: 换页符</li><li><strong><code>\v</code></strong>: 垂直制表符</li><li><strong><code>\a</code></strong>: 响铃（警告音）</li></ol></li><li><p>数据类型转换</p><p>同c</p></li></ul><hr><h1 id="运算符">运算符</h1><h2 id="位运算符">位运算符</h2><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符&quot;&amp;&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td style="text-align:left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">按位或运算符&quot;|&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td style="text-align:left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符&quot;^&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td style="text-align:left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移运算符&quot;&lt;&lt;“是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;“左边的运算数的各二进位全部左移若干位，由”&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移运算符&quot;&gt;&gt;“是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数。</td><td style="text-align:left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr><tr><td style="text-align:left">&amp;^</td><td style="text-align:left">位清空，a&amp;^b，对于被上的每一个值，若为0则取a对应位上的数值，若为1，则取0</td><td style="text-align:left">a&amp;^b结果位48</td></tr></tbody></table><h2 id="赋值运算符">赋值运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td style="text-align:left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">相加后再赋值</td><td style="text-align:left">C += A 等于 C = C + A</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">相减后再赋值</td><td style="text-align:left">C -= A 等于 C = C - A</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">相乘后再赋值</td><td style="text-align:left">C *= A 等于 C = C * A</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">相除后再赋值</td><td style="text-align:left">C /= A 等于 C = C / A</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">求余后再赋值</td><td style="text-align:left">C %= A 等于 C = C % A</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">左移后赋值</td><td style="text-align:left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">右移后赋值</td><td style="text-align:left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">按位与后赋值</td><td style="text-align:left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">按位异或后赋值</td><td style="text-align:left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td style="text-align:left">|=</td><td style="text-align:left">按位或后赋值</td><td style="text-align:left">C |= 2 等于 C = C | 2</td></tr></tbody></table><hr><h1 id="流程控制">流程控制</h1><h2 id="选择结构">选择结构</h2><ul><li><strong>if语句</strong>：</li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;  </span><br><span class="line">    <span class="comment">// 条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> anotherCondition &#123;  </span><br><span class="line">    <span class="comment">// 第一个条件为 false 且第二个条件为 true 时执行的代码  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 所有条件均为 false 时执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>switch语句</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> variable &#123;  </span><br><span class="line"><span class="keyword">case</span> value1:  </span><br><span class="line">    <span class="comment">// 当 variable == value1 时执行的代码  </span></span><br><span class="line"><span class="keyword">case</span> value2:  </span><br><span class="line">    <span class="comment">// 当 variable == value2 时执行的代码  </span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">    <span class="comment">// 如果没有匹配的值，执行的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环结构">循环结构</h2><blockquote><p>go语言只有<code>for</code>关键字，没有<code>while</code></p></blockquote><ul><li><p>基本for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件循环（类似于<code>while</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;  </span><br><span class="line">        fmt.Println(i)  </span><br><span class="line">        i++  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>死循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    count := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)  </span><br><span class="line">        count++  </span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// 退出循环  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>range关键字：</p><p>在go语言中，我们可以用<code>range</code>关键字来遍历切片，数组等数据结构</p><p>一般会返回两个值，<code>index</code>和<code>value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, number := <span class="keyword">range</span> numbers &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;索引: %d, 数字: %d\n&quot;</span>, index, number)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="函数">函数</h1><h2 id="函数声明">函数声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数">可变参数</h2><ul><li><p><strong>是什么</strong>：一个函数的参数类型确定，但个数不确定，可以使用可变参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(arg ... <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg ... int会告诉go语言这个函数接收不定数量的参数，类型全是int</span></span><br></pre></td></tr></table></figure></li><li><p><strong>例子</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := getSum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">sum = sum + nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数传递">参数传递</h2><table><thead><tr><th style="text-align:left">传递类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-value.html">值传递</a></td><td style="text-align:left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/go/go-function-call-by-reference.html">引用传递</a></td><td style="text-align:left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><h2 id="递归函数">递归函数</h2><p>递归，就是在运行的过程中调用自己。</p><p>语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  recursion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p><p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p><ul><li>实例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="type">uint64</span>)</span></span>(result <span class="type">uint64</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">15</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(<span class="type">uint64</span>(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例执行输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 的阶乘是 1307674368000</span><br></pre></td></tr></table></figure><h2 id="defer语句">defer语句</h2><p>在 Go 语言中，<code>defer</code> 语句用于在函数返回之前执行某个操作。它常被用于进行清理工作，比如关闭文件、解锁资源、记录日志等。<code>defer</code> 语句会被推迟执行，直到外层函数返回。</p><p>如果有多个defer语句，会按照先进后出的顺序执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)  </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Third  </span><br><span class="line">Second  </span><br><span class="line">First</span><br></pre></td></tr></table></figure><blockquote><p>defer语句一般用于关闭文件，在并发编程中解锁资源等</p></blockquote><h2 id="函数的数据类型">函数的数据类型</h2><p>当我们用printf函数打印函数的类型是，我们会发现编译器会输出函数的类型</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408101757129.png" alt=""></p><p>在 Go 语言中，函数本身也是一种数据类型。这使得函数可以像其他变量一样被赋值、传递和返回。</p><ul><li><p><strong>函数作为变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a + b  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> = add  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := myFunc(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> op(a, b)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    result := operate(<span class="number">3</span>, <span class="number">4</span>, add)  </span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出: 7  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作为返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAdder</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> x + y  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    add5 := getAdder(<span class="number">5</span>)  </span><br><span class="line">    fmt.Println(add5(<span class="number">3</span>)) <span class="comment">// 输出: 8  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="匿名函数">匿名函数</h2><p>匿名函数（又称为闭包）是 Go 语言中一种没有名字的函数。它们可以在定义时立即调用，或者赋值给变量以便之后使用。匿名函数在处理回调、并发等场景中非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f1()</span><br><span class="line">    f2 := f1</span><br><span class="line">    f2()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名函数</span></span><br><span class="line">    f3 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接执行匿名函数（自己调用自己）</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">&quot;我是f3函数&quot;</span>)&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;我是自己调用自己&quot;</span>)</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是f1函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：假设<code>func</code>是一个函数名，则<code>func</code>就是一个函数变量，<code>func()</code>就是在调用这个函数，所以<code>c := func</code> 是在把一个匿名函数赋值给变量c，而 <code>c := func()</code> 则是在就收func的返回值</p></blockquote><h2 id="回调函数">回调函数</h2><ul><li><p><strong>定义</strong>：回调函数是一个函数，它作为参数传递给另一个函数，并在某一时刻被调用。</p></li><li><p><strong>用途</strong>：通常用于处理某些事件或条件后的逻辑执行，例如排序、自定义迭代等。</p></li><li><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, add)</span><br><span class="line"></span><br><span class="line">operate(<span class="number">2</span>, <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a / b &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operate</span><span class="params">(a, b <span class="type">int</span>, fun <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">r := fun(a, b)</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包">闭包</h2><p>闭包（Closure）指的是一个函数包含了其外部环境的状态。也就是说，闭包可以“记住”创建时的上下文，即使外部函数已经返回。闭包通常用于实现数据的封装、私有变量或状态的管理。</p><p>在 Go 语言中，闭包非常常见，以下是对闭包的详细解释和示例。</p><ul><li><p>概念</p><p>环境：闭包可以访问其外部函数的变量。</p><p>持久性：即使外部函数执行完毕，闭包仍然可以使用这些外部变量。</p></li><li><p>闭包示例</p><p>下面是一个简单的示例，演示如何在 Go 中使用闭包：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main  </span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;  </span><br><span class="line"></span><br><span class="line">// 创建一个闭包，生成一个计数器  </span><br><span class="line">func createCounter() func() int &#123;  </span><br><span class="line">    count := 0 // 外部变量  </span><br><span class="line"></span><br><span class="line">    // 返回一个匿名函数（闭包）  </span><br><span class="line">    return func() int &#123;  </span><br><span class="line">        count++ // 修改外部变量  </span><br><span class="line">        return count  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    counter1 := createCounter() // 创建第一个计数器  </span><br><span class="line">    counter2 := createCounter() // 创建第二个计数器  </span><br><span class="line"></span><br><span class="line">    fmt.Println(counter1()) // 输出: 1  </span><br><span class="line">    fmt.Println(counter1()) // 输出: 2  </span><br><span class="line">    fmt.Println(counter2()) // 输出: 1  </span><br><span class="line">    fmt.Println(counter2()) // 输出: 2  </span><br><span class="line">    fmt.Println(counter1()) // 输出: 3  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong>：</p><ol><li><p>定义外部变量：在 <code>createCounter</code> 函数中，定义了一个外部变量 <code>count</code>，初始值为 0。</p></li><li><p>返回闭包：该函数返回一个匿名函数（闭包），这个闭包会增加并返回 <code>count</code> 的值。</p></li><li><p>保持状态：每次调用 <code>counter1</code> 和 <code>counter2</code> 时，返回的闭包都会记住自己的 <code>count</code> 状态。尽管 <code>createCounter</code> 函数已经返回，但闭包仍然可以操作 <code>count</code> 变量。</p></li><li><p>独立状态：<code>counter1</code> 和 <code>counter2</code> 是两个独立的计数器，不会互相影响。</p></li></ol></li><li><p><strong>输出结果</strong></p><p>运行上述代码会得到以下输出：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br></pre></td></tr></table></figure><ul><li><p><strong>总结</strong></p><p>闭包是一种强大的工具，可以让你在函数内部保留状态，从而实现更灵活和强大的程序设计。在 Go 语言中，闭包被广泛使用，例如在并发编程、事件处理和数据封装等场景中。</p></li></ul><hr><h1 id="常见数据结构">常见数据结构</h1><h2 id="数组">数组</h2><h3 id="定义：">定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：go语言数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化</p></blockquote><h3 id="初始化：">初始化：</h3><p>三种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明时初始化列表</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ... 省略长度</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引初始化</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125; </span><br></pre></td></tr></table></figure><blockquote><ol><li>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</li><li>数组支持 “==&quot;、”!=&quot; 操作符，因为内存总是被初始化过的。</li></ol></blockquote><h2 id="多维数组">多维数组</h2><h3 id="二维数组的定义："><strong>二维数组的定义</strong>：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说只有第一个参数可以省略</p></blockquote><h2 id="切片-slice">切片(slice)</h2><p>切片的底层就是数组，不同的是切片非常灵活，支持自动扩容</p><h3 id="定义："><strong>定义</strong>：</h3><p><code>var 切片名 []数据类型</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name[] <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时初始化</span></span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span> = array[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="初始化：">初始化：</h3><ul><li><p><strong>数组得到切片</strong></p><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>切片再次切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="type">string</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;yuchao&quot;</span>, <span class="string">&quot;chenshen&quot;</span>, <span class="string">&quot;chenzeqi&quot;</span>&#125;</span><br><span class="line">name = array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    name2 := name[<span class="number">0</span>:<span class="number">1</span>]     <span class="comment">//切片构造切片</span></span><br><span class="line">fmt.Println(name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用make()函数构造切片</strong></p><p>make函数使用格式：<code>make([]T, size, cap)</code></p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用make函数构造切片时会自动加入size个值，默认为0</p></blockquote></li></ul><h3 id="切片增加复制和删除元素">切片增加复制和删除元素</h3><ul><li><p><strong>append()</strong>:</p><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你调用 <code>append</code> 时，Go 会检查切片的容量。如果容量足够容纳新元素，<code>append</code> 将直接在原来的底层数组上添加元素，并返回同一个切片。</li><li>如果当前切片的容量不够，<code>append</code> 将创建一个新的底层数组，复制原有元素并添加新元素，最后返回指向新底层数组的切片。</li></ul></li><li><p><strong>copy()</strong>:</p><p><code>copy(destSlice, srcSlice []T)</code></p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>相当于深拷贝</p></li><li><p><strong>删除元素</strong>：</p><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p></li></ul><h3 id="切片表达式">切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><p>切片表达式就是刚刚初始化切片用到的[]</p><ul><li><p><strong>简单切片表达式</strong>：</p><p><code>a[low : high]</code></p><ul><li><p><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</p></li><li><p><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br></pre></td></tr></table></figure><p>省略部分参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完整切片表达式</strong>：</p><p><code>a[low : high : max]</code></p><ul><li><code>low</code>: 这是切片的起始索引（包含该索引的元素）。</li><li><code>high</code>: 这是切片的结束索引（不包含该索引的元素）。</li><li><code>max</code>: 这是切片的最大容量，可以大于 <code>high</code>，但是不能超过原数组的长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表-map">哈希表(map)</h2><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="定义">定义</h3><p><code>map [KeyType]ValueType</code></p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><h3 id="初始化">初始化</h3><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><p><code>make(map[KeyType]ValueType, [cap])</code></p><blockquote><p>注意：map在进行操作前必须用make进行初始化，不然其地址默认为nil</p></blockquote><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本使用">基本使用</h3><ul><li><p>添加数据：</p><p><code>map[key] = value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>          <span class="comment">// 添加键为 &quot;apple&quot;，值为 5  </span></span><br><span class="line">m[<span class="string">&quot;banana&quot;</span>] = <span class="number">3</span>         <span class="comment">// 添加键为 &quot;banana&quot;，值为 3  </span></span><br><span class="line">m[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span>         <span class="comment">// 添加键为 &quot;orange&quot;，值为 7</span></span><br></pre></td></tr></table></figure></li><li><p>删除数据：</p><p><code>delete(map, key)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断某个键是否存在：</p><p><code>value, ok := map[key]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="指针">指针</h1><h2 id="声明">声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>   <span class="comment">// 声明一个指向 int 的指针 p  </span></span><br></pre></td></tr></table></figure><h2 id="初始化">初始化</h2><p>指针的初始化通常有两种方式：</p><ol><li><p><strong>使用 <code>new</code> 函数</strong>：<br><code>new(T)</code> 会分配零值的类型 <code>T</code> 的空间，并返回一个指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p 是指向 int 的指针  </span></span><br><span class="line">*p = <span class="number">42</span>       <span class="comment">// 设置指针指向的值为 42  </span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过取地址运算符 <code>&amp;</code></strong>：<br>可以通过取已有变量的地址来初始化指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">10</span>  </span><br><span class="line">p := &amp;x       <span class="comment">// p 是指向 x 的指针  </span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]作业题</title>
      <link href="/2024/08/03/Mysql-%E4%BD%9C%E4%B8%9A%E9%A2%98/"/>
      <url>/2024/08/03/Mysql-%E4%BD%9C%E4%B8%9A%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目">题目</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031408188.png" alt=""></p><ol><li>查询姓“朱&quot;&quot;的学生名单</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where sname like &#x27;朱%&#x27;</span><br></pre></td></tr></table></figure></div></details><ol start="2"><li>查询同名同性学生名单，并统计同名人数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname, ssex, count(*) from Student group by sname, ssex having count(*) &gt;= 2</span><br></pre></td></tr></table></figure></div></details><ol start="3"><li>查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cid, avg(score) as score from sc group by cid order by score asc, cid desc;</span><br></pre></td></tr></table></figure></div></details><ol start="4"><li>查询平均成绩大于85的所有学生的学号、姓名和平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sid, s.sname, avg(score) </span><br><span class="line">from sc inner join student s on sc.sid = s.sid </span><br><span class="line">group by s.sid, s.sname having avg(score) &gt;= 85</span><br></pre></td></tr></table></figure></div></details><ol start="5"><li>查询课程名称为“睡觉”&quot;，且分数低于60的学生姓名和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--关联查询</span><br><span class="line">select s.sname, c.cname, sc.score </span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid </span><br><span class="line">where sc.score &lt; 60 and c.cname = &#x27;睡觉&#x27;</span><br><span class="line"></span><br><span class="line">--子查询</span><br><span class="line">select s.sname, sc.score from student s, sc where s.sid = sc.sid and sc.score &lt; 60 and sc.cid in (select cid from course c where c.cname = &#x27;睡觉&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="6"><li>查询所有学生的选课情况</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname</span><br><span class="line">from course c left join sc on c.cid = sc.cid left join student s on s.sid = sc.sid</span><br></pre></td></tr></table></figure></div></details><ol start="7"><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sname, c.cname, sc.score</span><br><span class="line">from course c inner join sc on c.cid = sc.cid inner join student s on s.sid = sc.sid</span><br><span class="line">where sc.score &gt; 70</span><br></pre></td></tr></table></figure></div></details><ol start="8"><li>查询每门课程被选修的学生数</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.cname, count(*)</span><br><span class="line">from sc inner join course c on sc.cid = c.cid</span><br><span class="line">group by c.cname</span><br></pre></td></tr></table></figure></div></details><ol start="9"><li>查询不同老师所教不同课程平均分从高到低显示</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">t.tname as &#x27;老师&#x27;, </span><br><span class="line">c.cname as &#x27;课程名&#x27;, </span><br><span class="line">avg(sc.score) as &#x27;平均分&#x27;</span><br><span class="line">from </span><br><span class="line">course c inner join sc on sc.cid = c.cid </span><br><span class="line">inner join teacher t on t.tid = c.tid</span><br><span class="line">group by </span><br><span class="line">t.tname, </span><br><span class="line">c.cname</span><br><span class="line">order by </span><br><span class="line">avg(sc.score) desc</span><br></pre></td></tr></table></figure></div></details><ol start="10"><li>按各科平均成绩从低到高和及格率的百分数从高到低顺序</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">sc.cid, </span><br><span class="line">avg(sc.score),</span><br><span class="line">(select count(*) from sc sc2 where sc2.cid = sc.cid and </span><br><span class="line">     sc2.score &gt;= 60)/count(*)</span><br><span class="line">from </span><br><span class="line">course c inner join sc on c.cid = sc.cid</span><br><span class="line">group by </span><br><span class="line">sc.cid</span><br><span class="line">order by </span><br><span class="line">avg(sc.score)desc</span><br></pre></td></tr></table></figure></div></details><ol start="11"><li>查询和“2&quot;号的同学学习的课程完全相同的其他同学学号和姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select sc.sid, s.sname </span><br><span class="line">from sc </span><br><span class="line">inner join student s on sc.sid = s.sid </span><br><span class="line">where sc.sid not in(</span><br><span class="line">select sc.sid from sc where sc.cid not in(</span><br><span class="line">    select sc.cid from sc where sc.sid = 2</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">group by sc.sid, s.sname</span><br></pre></td></tr></table></figure></div></details><ol start="12"><li>查询学过“黄观&quot;老师所教的所有课的同学的学号、姓名.</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT sc.sid   </span><br><span class="line">FROM sc   </span><br><span class="line">WHERE sc.cid IN (  </span><br><span class="line">    SELECT c.cid   </span><br><span class="line">    FROM course c   </span><br><span class="line">    INNER JOIN teacher t ON t.tid = c.tid   </span><br><span class="line">    WHERE t.tname = &#x27;黄观&#x27;  </span><br><span class="line">)   </span><br><span class="line">GROUP BY sc.sid   </span><br><span class="line">HAVING COUNT(*) = 2;</span><br></pre></td></tr></table></figure></div></details><ol start="13"><li>把“SC“表中&quot;黄观&quot;老师教的课的成绩都更改为此课程的平均成绩</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details><ol start="14"><li>查询课程编号“2&quot;的成绩比课程编号&quot;1&quot;课程低的所有同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select sc1.sid, s.sname</span><br><span class="line">from sc sc2, sc sc1 </span><br><span class="line">inner join student s on s.sid = sc1.sid</span><br><span class="line">where (</span><br><span class="line">sc2.score &lt; sc1.score </span><br><span class="line">and sc2.cid = 2 and sc1.cid = 1 </span><br><span class="line">and sc1.sid = sc2.sid</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><ol start="15"><li>查询没学过“黄观&quot;老师课的同学的学号、姓名</li></ol><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.sid, s.sname </span><br><span class="line">from student s</span><br><span class="line">where s.sid not in(</span><br><span class="line">select sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    where sc.cid in(</span><br><span class="line">    select c.cid </span><br><span class="line">        from course c</span><br><span class="line">        inner join teacher t on t.tid = c.tid</span><br><span class="line">        where t.tname = &#x27;黄观&#x27;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></details><blockquote><p>select from 只会往from后面的第一个数据表里做查询，不会对inner join的表里查询，因此如果写了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct s.sid, s.sname </span><br><span class="line">from sc</span><br><span class="line">inner join student s on s.sid = sc.sid</span><br><span class="line">where s.sid not in(</span><br><span class="line"><span class="keyword">select</span> sc.sid </span><br><span class="line">    from sc</span><br><span class="line">    inner join course c on c.cid = sc.cid</span><br><span class="line">    inner join teacher t on t.tid = c.tid</span><br><span class="line">    where t.tname = <span class="string">&#x27;黄观&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样是查不出在student表里但不在sc表里的同学的</p></blockquote><ol><li>查询平均成绩大于60分的同学的学号和平均成绩</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]多表查询</title>
      <link href="/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2024/07/30/Mysql-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="创建多表关系">创建多表关系</h1><blockquote><p><strong>外键</strong>：把一张表的主键拿到另一张表中作为一个普通的字段，用来联系起两张表</p><p>语法：constraint 外键名 foreign key 字段 references 表(字段名)</p><p>示例：constraint fk_deptNo foreign key (deptNo) references dept(id)</p><p>其中 fk_deptNo是外键名，deptNo是在这张表里这个外键对应的是字段deptNo，dept(id)是在表dept中，外键对应的是字段id</p></blockquote><h2 id="一对一">一对一</h2><ul><li><p>案例：用户与用户详情的关系</p></li><li><p>关系： 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情</p><p>字段放在另外一张表中，以提升操作效率（呈现的是一些分类的信息）</p></li><li><p>实现： 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique)</p><p>例如每个学员有各种信息，然后每种信息都有ID表示，这个时候就能够用id来建立</p><p>（unique）外键实现两个表的关联（这个外键可以特地设置）</p></li></ul><h2 id="一对多">一对多</h2><ul><li><p>案例： 部门与员工的关系</p></li><li><p>关系： 一个部门对应多个员工，一个员工对应一个部门 （员工是多，部门是一）</p></li><li><p>实现： 在多的一方建立外键，指向一的一方的主键</p></li></ul><p><strong>一对多代码实现</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">------dept------</span><br><span class="line">create table dept(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">deptName varchat(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">deptLeader varchar(<span class="number">10</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------employee------</span><br><span class="line">create table employee(</span><br><span class="line">id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">salary decimal(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">deptNo varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_deptNo foreign key (deptNo) references dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="多对多">多对多</h2><ul><li><p>案例： 学生与课程的关系</p></li><li><p>关系： 一个学生可以选修多个课程，一门课程也能供多个学生选择</p></li><li><p>实现： 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><strong>多对多代码实现</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------student-------</span><br><span class="line">create table stu(</span><br><span class="line">stu_id varchar(<span class="number">10</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">name varchar(<span class="number">255</span>) <span class="keyword">not</span> null,</span><br><span class="line">age int(<span class="number">4</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------course-------</span><br><span class="line">create table course(</span><br><span class="line">course_id varchar(<span class="number">10</span>) primary key,</span><br><span class="line">course_name varchar(<span class="number">255</span>) <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------student_course------</span><br><span class="line">create table stu_course(</span><br><span class="line">id varchar(<span class="number">100</span>) <span class="keyword">not</span> null primary key,</span><br><span class="line">courseID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">stuID varchar(<span class="number">10</span>) <span class="keyword">not</span> null,</span><br><span class="line">constraint fk_courseID foreign key (courseID) references </span><br><span class="line">course(course_id),</span><br><span class="line">constraint fk_stuID foreign key (stuID) references stu(stu_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="多表查询">多表查询</h1><h2 id="子查询">子查询</h2><h2 id="关联查询">关联查询</h2><p><strong>语法规则</strong>：<code>A xxx join B on A.字段 = B.字段</code>，当a字段的值和b字段的值相等时就join</p><ol><li><p><strong>inner join</strong></p><p><code>select 字段列表 from 表1 [inner] join 表2 on 连接条件；</code></p><p>相当于查询两表交集</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011937904.png" alt=""></p></li><li><p><strong>left join</strong></p><p><code>select 字段列表 from 表1 left [outer] join 表2 on 条件….；</code></p><p>相当于查询表1的所有数据 包含表1与表2交集部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408011938059.png" alt=""></p></li><li><p><strong>right join</strong></p><p><code>select 字段列表 from 表1 right [outer] join 表2 on 条件… ；</code></p><p>相当于查询表2的所有数据，包含表1与表2交集的部分的数据</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408041326679.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]排序</title>
      <link href="/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/07/30/Mysql-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="order-by">order by</h1><p>select * from 表名 order by 字段名 asc(升序)/desc(降序)；</p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301502381.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DQL基本查询语句</title>
      <link href="/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/07/30/Mysql-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="查询所有内容："><strong>查询所有内容</strong>：</h1><p><code>select * from 表名</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291824531.png" alt=""></p><h1 id="查询部分信息："><strong>查询部分信息</strong>：</h1><p><code>select 字段名1，字段名2 from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291825490.png" alt=""></p><h1 id="指定列名："><strong>指定列名</strong>：</h1><p><code>select 字段1 as 名称1，字段2 as 名称2.... from 表名；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291829760.png" alt=""></p><h1 id="根据指定字段查询："><strong>根据指定字段查询</strong>：</h1><p><strong>where</strong>：</p><ul><li><p><strong>单条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292039972.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>select * from 表名 where 约束条件；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407291834601.png" alt=""></p></li><li><p><strong>模糊查询</strong>：</p><p><code>select * from 表名 where 字段名 like '%值%'；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001897.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292001206.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292003232.png" alt=""></p></li><li><p><strong>in</strong>：</p><p><code>select * from 表名 where 字段名 in &#123;....&#125;；</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407292005949.png" alt=""></p></li><li><p><strong>判空查询</strong>：</p><p><code>select * from 表名 where 字段名 is null / is not null;</code></p><p>懒得举例子了</p></li></ul><h1 id="聚合函数查询">聚合函数查询</h1><ul><li><strong>语法</strong>: <code>select function(字段名) from 表名;</code><ol><li><strong>max()</strong></li><li><strong>min()</strong></li><li><strong>avg()</strong></li><li><strong>count()</strong></li><li><strong>sum()</strong></li></ol></li></ul><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301345917.png" alt=""></p><ul><li><p><strong>聚合函数配合group by</strong>:</p><p>作用：按照需要字段分组查询</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301431926.png" alt=""></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301432410.png" alt=""></p></li><li><p><strong>having</strong>：</p><p>作用：<strong>对于分组后的数据</strong>按照指定字段进行筛选</p><p><code>select 查询字段1，查询字段2..，聚合函数 from 表 group by 查询字段1，查询字段2    having 约束;</code></p><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202407301437352.png" alt=""></p></li></ul><h1 id="综合使用">综合使用</h1><p><img src="https://blog0417.oss-cn-hangzhou.aliyuncs.com/img_for_Blog/202408031428620.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]DML增删改操作</title>
      <link href="/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/29/Mysql-DML%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="增加">增加</h1><ol><li><p><strong>单条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values(值1，值2，值3....)</code></p><blockquote><p>注意：传字符串时要手动加上单引号</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291655861.png" alt=""></p></li><li><p><strong>多条数据</strong>：</p><p><code>insert into 表名(字段1，字段2，字段3....) values</code></p><p>(值1，值2，值3…),</p><p>(值1，值2，值3…);</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291659546.png" alt=""></p></li></ol><h1 id="修改">修改</h1><ul><li><p><code>update 表名 set 字段名1 = 值1，字段名2 = 值2，..... where(限定条件)；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291707563.png" alt=""></p></li></ul><h1 id="删除">删除</h1><ul><li><p><code>delete from 表名 条件限制</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291709519.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Mysql]基本DDL操作</title>
      <link href="/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/28/Mysql-%E5%9F%BA%E6%9C%ACDDL%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ddl是什么">DDL是什么</h1><p>数据定义语言，用来创建删除修改数据结构</p><h1 id="数据库操作">数据库操作</h1><ol><li><p><strong>创建</strong>：</p><p><code>create database 数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281956271.png" alt=""></p></li><li><p><strong>删除</strong>：</p><p><code>drop database 数据库名；</code></p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958803.png" style="zoom:150%;" /></li><li><p><strong>查询所有数据库</strong>：</p><p><code>show databases;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281958717.png" alt=""></p></li><li><p><strong>查询当前数据库</strong>：</p><p><code>select database();</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407281959343.png" alt=""></p></li><li><p><strong>使用数据库</strong>：</p><p><code>use  数据库名；</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282000951.png" alt=""></p></li></ol><h1 id="表的操作">表的操作</h1><h2 id="创建">创建</h2><p>要先指定使用一个数据库</p><p>create table 表的名字{</p><p>​字段名 类型(长度) 约束，</p><p>​字段…</p><p>};</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282007932.png" alt=""></p><p><strong>约束</strong>：</p><ol><li><p>主键约束：唯一地表示一条数据，使其不可以重复，主键不可以为空。</p><p>primary key auto_increment</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282024574.png" alt=""></p></li><li><p>非空约束：这一列数据不允许为空</p><p>not null</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282027885.png" alt=""></p></li><li><p>默认值约束：设置默认值</p><p>default 默认值</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282028665.png" alt=""></p></li><li><p>唯一性约束：数据不允许重复</p><p>unique</p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407282030689.png" alt=""></p></li></ol><h2 id="删除">删除</h2><p><code>drop table 表名;</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291403019.png" alt=""></p><h2 id="修改表结构">修改表结构</h2><ol><li><p><strong>添加字段</strong>：</p><p><code>alter table 表名 add 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291407182.png" alt=""></p></li><li><p><strong>删除字段</strong>：</p><p><code>alter table 表名 drop column 字段名</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291409972.png" alt=""></p></li><li><p><strong>修改字段</strong>：</p><p><code>alter table 表明 modify 字段名 类型 约束</code></p><p><img src="https://cdn.jsdelivr.net/gh/KQLXK/Picgo@main/img/202407291412790.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]STL标准库</title>
      <link href="/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2024/07/03/c-STL%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>C++ STL（标准模板库）提供了多种容器，每种容器都有其特定的功能和一组基本函数。以下是一些常用容器及其基本函数的概览：</p><h3 id="1-序列容器-sequential-containers">1. 序列容器（Sequential Containers）</h3><ul><li><strong>vector</strong><ul><li><code>push_back()</code>: 在容器末尾添加一个元素。</li><li><code>pop_back()</code>: 删除容器末尾的元素。</li><li><code>size()</code>: 返回容器中元素的数量。</li><li><code>capacity()</code>: 返回容器分配的内存足以容纳的元素数量。</li><li><code>reserve()</code>: 改变当前容器的容量。</li><li><code>clear()</code>: 移除容器中的所有元素。</li><li><code>begin()</code>/<code>end()</code>: 返回指向容器开始和结束的迭代器。</li></ul></li><li><strong>deque</strong>（双端队列）<ul><li><code>push_front()</code>: 在容器开头添加一个元素。</li><li><code>pop_front()</code>: 删除容器开头的元素。</li><li>其他函数与 <code>vector</code> 类似。</li></ul></li><li><strong>list</strong><ul><li><code>push_front()</code>: 在列表开头添加一个元素。</li><li><code>pop_front()</code>: 删除列表开头的元素。</li><li><code>sort()</code>: 排序列表中的元素。</li><li>其他函数与 <code>vector</code> 类似，但不支持随机访问迭代器。</li></ul></li><li><strong>forward_list</strong><ul><li>功能类似于 <code>list</code>，但只支持单向迭代。</li></ul></li><li><strong>array</strong><ul><li><code>at()</code>: 安全访问元素，带边界检查。</li><li><code>operator[]</code>: 访问元素。</li><li><code>fill()</code>: 用给定值填充所有元素。</li></ul></li><li><strong>string</strong><ul><li><code>push_back()</code>: 在字符串末尾添加一个字符。</li><li><code>pop_back()</code>: 删除字符串末尾的字符。</li><li><code>size()</code>/<code>length()</code>: 返回字符串长度。</li><li><code>clear()</code>: 清空字符串。</li><li><code>substr()</code>: 返回子字符串。</li><li><code>find()</code>: 查找子字符串的位置。</li></ul></li></ul><h3 id="2-容器适配器-container-adapters">2. 容器适配器（Container Adapters）</h3><ul><li><strong>stack</strong>（栈）<ul><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 删除栈顶元素。</li><li><code>top()</code>: 获取栈顶元素的引用。</li></ul></li><li><strong>queue</strong>（队列）<ul><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 删除队首元素。</li><li><code>front()</code>: 获取队首元素的引用。</li></ul></li><li><strong>priority_queue</strong>（优先队列）<ul><li><code>push()</code>: 在优先队列中添加一个元素。</li><li><code>pop()</code>: 删除具有最高优先级的元素。</li><li><code>top()</code>: 获取最高优先级元素的引用。</li></ul></li></ul><h3 id="3-关联容器-associative-containers">3. 关联容器（Associative Containers）</h3><ul><li><strong>set</strong>（集合）<ul><li><code>insert()</code>: 插入一个元素。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找元素。</li></ul></li><li><strong>multiset</strong><ul><li>与 <code>set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>map</strong>（映射）<ul><li><code>insert()</code>: 插入一个键值对。</li><li><code>erase()</code>: 删除一个元素。</li><li><code>find()</code>: 查找具有特定键的元素。</li></ul></li><li><strong>multimap</strong><ul><li>与 <code>map</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_set</strong>（无序集合）<ul><li>功能类似于 <code>set</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multiset</strong><ul><li>与 <code>unordered_set</code> 类似，但允许多个具有相同键的元素。</li></ul></li><li><strong>unordered_map</strong>（无序映射）<ul><li>功能类似于 <code>map</code>，但提供平均常数时间复杂度的性能。</li></ul></li><li><strong>unordered_multimap</strong><ul><li>与 <code>unordered_map</code> 类似，但允许多个具有相同键的元素。</li></ul></li></ul><h3 id="4-其他容器">4. 其他容器</h3><ul><li><p>bitset</p><p>（位集）</p><ul><li><code>set()</code>: 设置指定位数为1。</li><li><code>reset()</code>: 设置指定位数为0。</li><li><code>flip()</code>: 翻转指定位数的值。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[代码随想录]字符串</title>
      <link href="/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/06/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="实现strstr"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">实现strStr()</a></h1><h2 id="题目">题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p>我们把 <code>haystack</code> 称为<strong>主串</strong>，把 <code>needle</code>称为<strong>模式串</strong> 。</p><h2 id="kmp算法">KMP算法</h2><h3 id="基本思想"><strong>基本思想</strong></h3><p>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p><h3 id="前缀和后缀"><strong>前缀和后缀</strong></h3><p>前缀：包含第一个字母但不包含最后一个字母</p><p>后缀：包含最后一个字母但不包含第一个字母</p><p>**注意：**前后缀都是连续抽取的子串</p><p><strong>例子</strong>：</p><p>有字符串&quot;aabaaf&quot;</p><p>前缀是：a,aa,aab…,aabaa</p><p>后缀是：abaaf,baaf,…,f</p><h3 id="前缀表-关键"><strong>前缀表（关键）</strong></h3><p>一般用一个next数组来储存</p><ul><li><p><strong>最长相等前后缀</strong></p><p>指一个字符串里相同前后缀的最长字符串（<strong>注意是要存的一个数值，一个字符串只有一个最长相等前后缀</strong>）</p><p><strong>例子</strong>：</p><p>字符串”aabaa“， 前缀有a, aa, aab, aaba, 后缀有abaa, baa, aa, a. 相同的前后缀有a, aa.所以最长相等前后缀就是2</p></li><li><p><strong>前缀表是什么</strong></p><p>前缀表是一个存储<strong>最长相等前后缀长度</strong>的数组</p><p>换句话说，它告知如果在 <code>needle</code> 中发生了不匹配，我们可以跳过多少个字符继续比较。</p><p><strong>其中第 i 个元素表示的是模式串前 i 个元素所组成的字串的最长相等前后缀</strong>，因此可以直接用next[a]来回退。</p><p><strong>例子</strong>：</p><p>模式串aabaaf，</p><p>前缀表的前 1 个元素构成的字符串为 ：”a“，最大相等前后缀为 0，所以next[0] = 0</p><p>前缀表的前 2 个元素构成的字符串为 ：”aa“，最大相等前后缀为 1，所以next[1] = 1</p><p>前缀表的前 3 个元素构成的字符串为 ：”aab“，最大相等前后缀为 0 ，所以next[2] = 0，以此类推…</p><p>所以字符串 aabaaf 的前缀表就是 {0，1，0，1，2，0}</p></li><li><p><strong>前缀表的作用（关键）</strong></p><p>当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。<strong>而不是一个字符一个字符遍历</strong></p></li><li><p><strong>前缀表的代码实现</strong></p><ol><li><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure><p><strong>变量 j 表示的是最长相等前后缀长度，而s[j] 则表示相等前后缀最后一个字符的再后面一个字符</strong>，而将next数组的第一个元素赋值为-1和KMP理论层面无关，是实现时加入的一个设定，可以更改</p></li><li><p><strong>建立for循环构建next数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br></pre></td></tr></table></figure><p><strong>变量 i 表示的是后缀的最后一个字符</strong>，等于0时是不存在最长相等前后缀的，所以从1开始</p><p>在进入循环介绍前，我们要先知道，在整个构造前缀表的过程中，<strong>变量 j 是一直在来回移动的</strong>，因为每个 i 对应最长相等前后缀是不同的，而<strong>变量 i 则是一个一个遍历下去</strong>，每个 i 对应一个前缀表的数值</p></li><li><p><strong>处理前后缀不相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; </span><br><span class="line">    j = next[j]; <span class="comment">// 前后缀不相同了就向前回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用while循环的原因：i 增加1之后，有可能会导致最长相等前后缀长度直接减少2或更多，</p><p>为什么next[j]是回退：首先明确next数组的作用就是存储最长相等前后缀长度,再明确回退要保证next[i]之前的字符与回退后next[j]之前的是相同的，所以可以利用next数组来进行回退，而因为next数组第一个元素是-1所以可以直接用j作为索引。</p><blockquote><p><strong>注意</strong>：next[j]中直接访问 j 下标的元素是因为next的第一个元素默认为-1，这之后才是有效数值，这便是实现层面上的设定。</p></blockquote></li><li><p><strong>处理前后缀相同的情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure><p><code>j++</code>使得 j 表示最长相等前后缀长度 而不是最后一个字符的索引位置</p><p>这样一来在下一个循环中s[ j ]就会再往后指向一个新的字符来和新的s[ i ]来比较，如果s[ i ]等于s[ j ]，那么就可以直接加上，因为这之前的字符已经在之前的循环中判断过了，如果不等于，就要往前回退到next[ j ]的位置。</p></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="kmp解题主要思路">KMP解题主要思路</h3><ol><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br></pre></td></tr></table></figure></li><li><p>建立for循环遍历haystack</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)</span><br></pre></td></tr></table></figure><p>注意：本题中通过next数组使得 j 不断回退，这样确保了haystack[i]和needle[j + 1]之前的字符已经是相等的，所以从头到尾只需要比较 haystack[i] 和 needle[j + 1] 这两个字符</p></li><li><p>处理不匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理匹配的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到了结束循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line"><span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">            j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">            j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="题目答案">题目答案</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]类模板中的友元函数</title>
      <link href="/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
      <url>/2024/06/03/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引入">问题引入</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::<span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt;::~<span class="built_in">Dvector</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Dvector&lt;T&gt; Dvector&lt;T&gt;::<span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="function">Dvector&lt;T&gt; <span class="title">result</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        result.data.<span class="built_in">push_back</span>(<span class="keyword">this</span>-&gt;data[i] + d1.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Dvector&lt;T&gt;::<span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1) &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        sum += <span class="keyword">this</span>-&gt;data[i] * d1.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">        os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="function">Dvector&lt;<span class="type">int</span>&gt; <span class="title">vecA</span><span class="params">(<span class="number">6</span>, a)</span>,<span class="title">vecB</span><span class="params">(<span class="number">6</span>, b)</span>,<span class="title">vecC</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    vecC = vecA + vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;vecC&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> iResult = vecA * vecB;</span><br><span class="line">    cout&lt;&lt;vecA&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;vecB&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;iResult&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在vscode上报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">warning: <span class="title">friend</span> <span class="title">declaration</span> &#x27;<span class="title">std</span>::<span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt;(<span class="title">std</span>::<span class="title">ostream</span>&amp;, <span class="title">linkStack</span>&lt;<span class="title">T</span>&gt;&amp;)&#x27; <span class="title">declares</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">template</span> <span class="title">function</span> [-<span class="title">Wnon</span>-<span class="title">template</span>-<span class="title">friend</span>]|</span></span><br></pre></td></tr></table></figure><h1 id="问题解读">问题解读</h1><h2 id="原因">原因</h2><p><strong>这段报错的意思是这里声明了一个非模板友元函数，编译器识别出来后警告(注意不是报错)</strong></p><p>为了解决这个警告，我们来补充模板类中的三种友元函数：</p><h2 id="非模板友元函数">非模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种友元函数仅仅只对应于一个特定类，<strong>不具有模板化的特性</strong>，因此不应该在模板类中这样定义一个友元函数。</p><h2 id="约束模板友元函数">约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//声明模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//声明类的友元函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Arrat&lt;T&gt; A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Array&lt;T&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>何为约束</strong>：<code>friend ostream&amp; operator &lt;&lt; &lt;&gt;(ostream&amp; os, const Array&lt;T&gt; A)&#123;</code>这行代码中的<code>&lt;&gt;</code>起到了提醒编译器这是一个模板实例化，参数类型与类模板中<strong>相同</strong>，不能接受不同类型的对象，所以是约束模板友元函数。</p><h2 id="非约束模板友元函数">非约束模板友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">//另外声明了一个模板</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="type">const</span> Array&lt;U&gt; A)&#123;</span><br><span class="line">    ....    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过该模板友元函数定义的友元函数可以接受不同的类型，所以是非约束的。</p><hr><h1 id="解决方案">解决方案</h1><ol><li><p><strong>直接再模板类内部定义友元函数体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">       os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为约束模板友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;T&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将该友元函数声明为非约束友元函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dvector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dvector</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Dvector</span>(<span class="type">int</span> size, T* array = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dvector</span>();</span><br><span class="line">    Dvector <span class="keyword">operator</span> + (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> * (<span class="type">const</span> Dvector &amp;d1);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1); <span class="comment">//警告的地方</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; &lt;&gt;(ostream&amp; os, <span class="type">const</span> Dvector&lt;U&gt; &amp;d1)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d1.size; i++) &#123;</span><br><span class="line">    os &lt;&lt; d1.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]模板</title>
      <link href="/2024/05/27/c-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/05/27/c-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板">函数模板</h1><h2 id="函数模板与模板函数">函数模板与模板函数</h2><ul><li><p><strong>适用场景</strong>：对处理逻辑相同，只是参数类型不同的函数</p></li><li><p><strong>声明</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表);</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表);</p></li><li><p><strong>定义</strong>：</p><p>template &lt;typename 类型参数名&gt;</p><p>返回值类型 函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p><p>或</p><p>template &lt;typename 类型参数名1， typename 类型参数名2， …&gt;</p><p>返回值类型  函数模板名(形参表){</p><p>​…     //函数模板体</p><p>}</p></li><li><p><strong>示例</strong>：</p><p>定义一个返回数组最小值的函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">MinInArray</span><span class="params">(T* array, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    T min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优先级</strong>：</p><p>当函数模板和重载函数同时存在时，编译器会优先使用重载函数。</p></li></ul><h1 id="类模板">类模板</h1><ul><li><p><strong>声明和定义</strong>：</p><ul><li><p><strong>类的声明定义</strong>：</p><p>template &lt;typename 类型参数名1，…&gt;</p><p>class 类模板名</p><p>{</p><p>​… //类模板体</p><p>}；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplateClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyTemplateClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>类的成员函数</strong>：</p><p>template&lt;typename 类型参数名1，…&gt;</p><p>返回值类型  类模板名&lt;类型参数名&gt;::成员函数名（形参表）{</p><p>​…   //函数体</p><p>}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyTemplateClass&lt;T&gt;::<span class="built_in">display</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>用类模板产生模板类</strong>：</p><p>类模板名 &lt;类型1，…&gt;</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p><strong>类模板建立对象</strong>：</p><p>类模板名 &lt;类型参数名&gt; 对象1，对象2…</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTemplateClass&lt;<span class="type">int</span>&gt; obj1,obj2........</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]运算符重载</title>
      <link href="/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/05/17/c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="第一操作数">第一操作数</h1><ul><li><strong>第一操作数</strong>：运算符左侧的操作数</li></ul><h1 id="成员运算符重载">成员运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数是当前类对象时</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (const  第二操作数的引用){</p><p>​//所进行的操作</p><p>​return …</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex <span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">        complex result;</span><br><span class="line">        result.real = real + c.real;</span><br><span class="line">        result.imag = imag + c.imag;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> real;</span><br><span class="line">    <span class="type">int</span> imag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ul><h1 id="友元运算符重载">友元运算符重载</h1><ul><li><p><strong>适用场景</strong>：第一操作数不是当前类对象，但是要访问到类中的私有成员时</p></li><li><p><strong>实现方式</strong>：</p><p>friend  返回值类型  operator  运算符  (第一操作数的引用，第二操作数的引用){</p><p>​//操作</p><p>​return…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> complex&amp; c)&#123;</span><br><span class="line">    os&lt;&lt;c.real&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么返回值要设为ostream&amp; ：允许连续输出，例如cout&lt;&lt;c1&lt;&lt;c2&lt;&lt;c3&lt;&lt;endl</p></blockquote></li></ul><h1 id="非成员函数重载">非成员函数重载</h1><ul><li><p><strong>适用场景</strong>：既不需要访问类的私有成员，也不需要直接修改类的对象</p></li><li><p><strong>实现方式</strong>：</p><p>返回值类型  operator  运算符  (常引用)  {</p><p>​…</p><p>}</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Number</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number <span class="keyword">operator</span>-(<span class="type">const</span> Number&amp; num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(-num.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[c++]继承与多态</title>
      <link href="/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/14/c-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="公有继承和is-a关系">公有继承和is-a关系</h1><h2 id="继承和派生">继承和派生</h2><p><code>派生</code>：同一个类可以派生出多个子类，将这个类称为<strong>基类</strong>，派生出的子类称为<strong>派生类</strong>，同时把子类简介派生出的所有类统称为它的<strong>子孙类</strong>，把一个子类之前的所有类都统称为它的<strong>祖先类</strong></p><p><code>继承</code>：每个派生出的子类继承了基类的<strong>公有(public)属性</strong>和<strong>公有函数</strong>描述的功能</p><p><code>is-a关系</code>（公有继承）：指一个类是另一个类的一种特殊形式，通常用于描述继承关系。比如，狗是一种动物，所以狗类可以继承自动物类。在代码中通常体现为类的继承关系。</p><p>再复习一下<strong>has-a</strong>关系</p><p><code>has-a</code>（私有继承）：指一个类包含另一个类的对象作为其成员变量，通常用于描述组合关系。比如，汽车有一个引擎，所以汽车类可以包含一个引擎对象作为其成员变量。在代码中通常体现为类的成员变量。</p><hr><h1 id="派生类">派生类</h1><h2 id="派生类定义">派生类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">public</span> 基类名&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类公有函数成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//派生类私有数据成员</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="派生类访问控制">派生类访问控制</h2><p><strong>可以访问</strong>：<strong>public</strong> ,<strong>protected</strong></p><p><strong>不可以访问</strong>：<strong>private</strong></p><p><strong>如何访问</strong>：</p><p>有基类<code>person</code> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有派生类<code>student</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问<code>student</code>的<code>name</code>和<code>age</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; student.name;</span><br><span class="line">cout &lt;&lt; student.age;</span><br></pre></td></tr></table></figure><h2 id="派生类定义样例">派生类定义样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is sleeping&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; breed) : <span class="built_in">Animal</span>(name), <span class="built_in">m_breed</span>(breed) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_breed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span></span>;</span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造与析构">派生类构造与析构</h2><blockquote><p><strong>注意</strong>：在调用派生类构造函数时如果不显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。如果基类没有默认构造函数，且派生类构造函数没有显式调用基类构造函数，则会导致编译错误。</p><blockquote><details class="toggle" ><summary class="toggle-button" style="">具体示例</summary><div class="toggle-content"><blockquote><p>在下面的示例中，基类Person没有默认构造函数，而派生类Student的构造函数没有显式调用基类构造函数，将会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> grade) : <span class="built_in">m_grade</span>(grade) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">myStudent</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，派生类Student的构造函数没有显式调用基类Person的构造函数，因为基类Person没有默认构造函数，编译器无法自动调用基类的构造函数，导致编译错误。为了避免这种情况，应该在派生类的构造函数中显式调用基类的构造函数，以确保正确地初始化基类的成员变量。</p><blockquote></blockquote></blockquote></div></details></blockquote></blockquote><p><strong>派生类构造函数示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPerson</span>(string name,<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)</span><br><span class="line">&#123;&#125;<span class="comment">//基类构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CStudent</span>(string name,<span class="type">int</span> age,<span class="type">int</span> number)</span><br><span class="line">:<span class="built_in">CPerson</span>(name,age),<span class="built_in">number</span>(number)</span><br><span class="line">&#123;&#125;<span class="comment">//派生类构造函数</span></span><br></pre></td></tr></table></figure><p><strong>构造函数和析构函数调用顺序</strong>：</p><p>基类 -&gt; 成员对象 -&gt; 派生类</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：ABC</p><hr><h1 id="同名覆盖原则">同名覆盖原则</h1><p>**定义：**如果派生类新增的数据成员或函数成员与基类同名，则基类中的同名成员会被覆盖，如果要访问基类中的同名函数，则需要添加基类名<code>::</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studZhang.Person::<span class="built_in">show</span>();  <span class="comment">//studZhang是一个CStudent类的对象，Person是它的基类</span></span><br></pre></td></tr></table></figure><h1 id="赋值兼容原则">赋值兼容原则</h1><p><strong>定义：</strong></p><ol><li><p><strong>基类指针</strong>可以指向<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p><strong>基类引用对象</strong>可以引用<strong>派生类对象</strong>（本质是派生类对象）</p></li><li><p>普通变量，函数传参，函数返回对象时将子孙类对象赋值给基类对象时，会存在切片现象。（变成基类对象）</p></li></ol><hr><h1 id="多态性与虚函数">多态性与虚函数</h1><h2 id="多态性">多态性</h2><p><code>静态多态性</code>：通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现（根据传参类型即可确定要调用的函数，<strong>在编译时完成（静态绑定）</strong>，所以是静态）</p><p><code>动态多态性</code>：通过<strong>虚函数</strong>实现（根据基类指针实际指向的对象类型来确定调用的函数，<strong>在运行时完成（动态绑定）</strong>） ，<strong>在基类指针/对象指向派生类指针/对象时最能体现</strong>。</p><h2 id="虚函数">虚函数</h2><ol><li><p>声明语法：</p><p>在基类中声明：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​在派生类中重写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">virtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写基类中的虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>到底是干嘛的</p><p>比如同样是动物的叫，狗是bark，猫是meow，这个时候就有动态多态性的感觉了，就会使用虚函数。</p><p>动物是基类，狗和猫是派生类，叫就是一个虚函数。</p></li><li><p>使用时和普通函数的区别</p><p>前文提到了在基类指针/对象指向派生类指针/对象时最能体现动态多样性，这是因为在通过基类指针/对象访问派生类指针/对象的函数时，如果这个函数是虚函数，那么编译器就会在这个类的虚函数表中找到对应的虚函数来调用（这就是动态多样性），而如果是普通函数，那就会直接调用基类的这个函数。</p><p>例如：有一个基类指针<code>Person</code>指向派生类对象<code>Student</code>,基类和派生类中都有一个函数是<code>show()</code></p><ul><li>如果<code>show()</code>是虚函数：</li></ul><p><code>Person-&gt;show()</code>调用的是派生类<code>Student</code>的<code>show()</code></p><ul><li>如果不是：</li></ul><p><code>Person-&gt;show()</code>调用的就是基类<code>person</code>的<code>show()</code>函数</p><ul><li>如果基类没有这个函数：</li></ul><p>编译器会直接报错</p></li><li><p>底层逻辑</p></li></ol><p>对于使用虚函数的类，编译器会在其内部生成一个虚函数表，用来存储该类所有的虚函数，用基类指针或引用调用虚函数时，会从这个表中找到对应的虚函数并返回指针，从而实现动态绑定。</p><h2 id="纯虚函数和抽象类">纯虚函数和抽象类</h2><ol><li>声明语法：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Funtion</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><code>抽象类</code>：包含纯虚函数的类</p><h2 id="派生类对象的克隆">派生类对象的克隆</h2><blockquote><p>用虚函数来克隆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* clonedBase = base-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedBase-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* clonedDerived = derived-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">show</span>();</span><br><span class="line">    clonedDerived-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">delete</span> clonedBase;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> clonedDerived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚基类">虚基类</h1><h2 id="菱形继承问题">菱形继承问题</h2><p><strong>在类的继承关系如下时发生</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure><p>在上面的继承结构中，类 <code>A</code> 是基类，类 <code>B</code> 和 <code>C</code> 都直接继承自 <code>A</code>，而类 <code>D</code> 继承自 <code>B</code> 和 <code>C</code>。由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在 <code>D</code> 中将会包含两份来自 <code>A</code> 的数据。这就是有菱形继承问题的原因。</p><p><strong>导致以下问题</strong>：</p><ol><li><p>内存浪费</p></li><li><p>二义性：</p><p>如果 <code>A</code> 类定义了一个成员函数 <code>foo()</code>，<code>B</code> 类和 <code>C</code> 类分别重写了这个函数，在 <code>D</code> 类中调用 <code>foo()</code> 函数，编译器就无法确定应该调用哪个版本的 <code>foo()</code> 函数，从而产生二义性。</p></li></ol><h2 id="用虚基类解决菱形继承问题">用虚基类解决菱形继承问题</h2><ul><li><p><strong>如何解决</strong>：</p><p>声明虚基类后，编译器会自动调用最终重写的版本。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling A&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling B&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling C&#x27;s foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        B::<span class="built_in">foo</span>(); <span class="comment">// 明确调用 B 类的 foo()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>();  <span class="comment">// 在 D 类中调用 foo() 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">callFoo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling B<span class="number">&#x27;</span><span class="function">s <span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>如果没有声明虚基类，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference to &#x27;foo&#x27; is ambiguous</span><br></pre></td></tr></table></figure><p>如果没有最终的重写函数，会报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no unique final overrider <span class="keyword">for</span> &#x27;virtual void A::foo()&#x27; <span class="keyword">in</span> &#x27;D&#x27;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="补充">补充</h1><ul><li><p><strong>将构造函数定义为纯虚函数是没有意义的</strong></p><p>构造函数是用来创造对象的，而含有纯虚函数的类不能创造对象，所以无意义</p></li><li><p><strong>动态绑定只发生在，用基类指针或基类引用调用虚函数时，用派生类指针或引用调用虚函数时会直接确定要调用的虚函数，这是静态绑定</strong></p><p>例：有一个派生类对象a，a类中有虚函数b()，使用a.b()时不会发生动态绑定。</p></li><li><p><strong>派生类中虚函数必须和基类中完全一样（返回值，形参）</strong></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/05/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写点什么">写点什么</h1><p>想了很久我的第一篇博客应该写点什么，但是突然发现这好像违背了我创建博客的初心，在我看来博客应该想写什么就写什么，我希望把我的博客当作一个树洞，既可以记录我的生活，又可以倾诉我的情绪，在这里可以看到最真实的自己。</p><p>至于为什么到现在才搭建好我的博客，想到这个问题脑子里突然闪过好多理由，但里有终究是理由，根本还是我自己的原因，因此我想做出改变，我一定可以看到自己的改变。</p><h1 id="最近">最近</h1><h3 id="搭博客">搭博客</h3><p>首先奉上我跟的教程</p><p>​<a href="https://nickxu.me/tags/%E5%BB%BA%E7%AB%99%E6%8A%80%E5%B7%A7/">标签: 建站技巧 | NX の 博客 (nickxu.me)</a></p><p>​<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>搭博客的过程可谓曲折，捣鼓了5、6天却一直报出奇怪的错误，不过也让我对流程十分熟悉，以后有机会一定要写一篇搭博客的教程。</p><h3 id="期中考试-0512">期中考试(0512)</h3><p>上个礼拜都在复习昨天的期中考试，这个学期想努力一下，要拿到奖学金（因为感觉上学期不是很认真都差点成功了），但是昨天的大物让我一言难尽，感觉一拳打在棉花上的感觉，无法读懂出题老师的意图，而且考的知识点像高中物理，甚至出现了万有引力。至于高数感觉还是上学期挖的坑太大了，输在了微积分基础上。但是现在还没出成绩，也许等出了成绩之后会更破防。</p><h3 id="debug杯-0508">Debug杯(0508)</h3><p>第一次参加大学里的比赛，目标是为了混到德育分，但是没想到大部分的人和我的想法是一样的，以至于我最后甚至混到了一个三等奖，真是抽象。</p><h1 id="结语">结语</h1><p>忘记还想要写些什么了，下次再来补吧。最后送自己一句话：Think Less,Do More.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 新技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/06/hello-world/"/>
      <url>/2024/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
